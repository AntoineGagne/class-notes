# Processus et threads

## Processus

### Définition

Une instance de programme qui s'exécute.

### Ordonnanceur

Responsable de choisir le processus à exécuter.

## `fork()`

Lorsque `fork()` est appelé

- Le processus se duplique
- Un processus enfant est créé
- La mémoire qui va être écrite est copiée
- Si la mémoire n'est pas écrite, le système d'exploitation va faire pointer les adresses virtuelles
vers les mêmes adresses physiques

### Exemple de `fork()`

```C
int main(void)
{
   pid_t pid = fork();

   if (pid == -1) {
      perror("fork failed");
      exit(EXIT_FAILURE);
   }
   else if (pid == 0) {
      printf("Hello from the child process!\n");
      _exit(EXIT_SUCCESS);
   }
   else {
      int status;
      (void)waitpid(pid, &status, 0);
   }
   return EXIT_SUCCESS;
}
```

```C
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main ( int argc, char *argv[ ] ) {
    int LePid;
    LePid=fork();
    if (LePid==0) { /* fils */
        printf(“je suis le fils %d\n”,getpid());
        sleep(10); exit();
    }
    else { /* le parent seulement */
        printf(“je suis le père %d\n”,getpid());
        wait(0);
    }
}
```

## Threads

- Partage de l'espace d'adressage
    - Partager variables globales
    - Pas de protection mémoire entre thread
- Partage des ressources
- Chaque thread a sa pile
- Beaucoup plus rapide à créer qu'un processus, car moins
de ressources associées (tableau de données beaucoup plus
petit)

### Exemple de code de threads

```C
void *print_hello(void *tnum) {
    printf(“Bonjour je suis le thread %d\n”,*(int*)tnum);
    pthread_exit(NULL);
}
int main(int argc, char *argv[]) {
    // Le programme cree 10 threads et se termine
    int status, i, Arg[N_THREADS];
    for (i=0; i < N_THREADS; i++) {
        Arg[i] = i;
        printf(“Main(): en train de creer thread %d\n”,i);
        status = pthread_create(&threads[i], NULL, print_hello, (void *)&Arg[i]);
        if (status != 0) {
        printf(“oops, pthread a retourne le code d’erreur %d\n”,status);
        exit(-1);
        }
    }
    // Attendre la fin des threads
    for (i=0; i < N_THREADS; i++) { pthread_join(threads[i], NULL); }
    exit(NULL);
}
```

```C
void *print_hello(void *tnum) {
    printf(“Bonjour je suis le thread %d\n”,*(int*)tnum);
    pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
    // Le programme cree 10 threads et se termine
    pthread_t threads[N_THREADS];
    int status, i, Arg[N_THREADS];
    for (i=0; i < N_THREADS; i++) {
        Arg[i] = i;
        printf(“Main(): en train de creer thread %d\n”,i);
        status = pthread_create(&threads[i], NULL, print_hello, (void *)&Arg[i]);
        if (status != 0) {
            printf(“oops, pthread a retourne le code d’erreur %d\n”,status);
            exit(-1);
        }
        pthread_join(threads[i], NULL);
    }
    exit(NULL);
}
```

### Threads utilisateurs

#### Avantages

- Plus efficace, car pas besoin de passer par le noyau

#### Désavantages

- Difficile d'implémenter parfaitement
    - Détecter les appels bloquants
        - pour occuper un autre thread pendant l'attente
    - l'idée de base des threads était de ne pas s'en faire avec les
    appels bloquants
    - Réécrire certaines fonctions systèmes avec `select()`
- Pas de préemption
    - Processus ne peut pas interrompre un thread
    - Les threads doivent coopérer

### Threads noyau

#### Avantages

- Ordonnanceur du système d'exploitation va pouvoir
    - préemption du thread en cours
    - détecter appels systèmes bloquants

## Conditions de concurrence

- Partager un système de stockage (écriture/lecture)
    - fichiers (e.g. ajouts parallèles dans un répertoire)
    - base de données
    - mémoire partagée (*shared memory*)
- Si deux processus tentent d'accéder à ce stockage partagé,
il peut y avoir des bogues subtils:
    - conditions de concurrence / *race condition*

### Spinlocks

#### Solution de Peterson

```C
int critical[2];

void enter_region(int process) {
    int other;
    other = 1 - process; // Position 1
    critical[process]=1; // Position 2
    waiting = process;
    while(waiting==process&&critical[other] == 1);
}

void leave_region(int process) {
    critical[process] = 0;
}
```

#### Test and Set Lock

```ARM
enter_region:
    TSL EAX, LOCK    | copie LOCK dans registre EAX, LOCK = 1
    CMP EAX, #0      | LOCK était-elle à 0?
    JNE enter_region | si LOCK pas à 0, boucle
    RET              | LOCK libre, entre dans section critique

leave_region:
    MOV LOCK, #0     | écrit un 0 dans LOCK
    RET              | retourne à l’appelant
```

#### XCHG

```ASM
enter_region:
    MOV EAX, #1       | copie LOCK dans registre, LOCK = EAX
    XCHG EAX, LOCK    | LOCK était-elle à 0?
    CMP EAX, #0       | si LOCK pas à 0, boucle
    JNE enter_region  | LOCK libre, entre dans section critique
    RET
leave_region:
    MOV LOCK, #0      | écrit un 0 dans LOCK
    RET               | retourne à l’appelant
```

### Sémaphores

#### POSIX

```C
sem_init()      // initialiser sémaphore sans nom
sem_open()      // ouvrir un sémaphore avec nom
sem_close()     // fermer un sémaphore avec nom
sem_unlink()    // enlever sémaphore avec nom
sem_wait()      // down
sem_post()      // up
sem_getvalue()  // valeur du sémaphore
sem_destroy()   // détruire un sémaphore créé par sem_init
```

#### Exemple d'utilisation

```C
int main(int argc, char *argv[]) {
    // Un seul sémaphore, pour le processus
    sem_t *pSemaphore = sem_open("UnNomUnique5", O_CREAT, 0644, 1);
    if (pSemaphore == SEM_FAILED) {
        return -1;
    }
    int i;
    for (i = 0; i<10; i++) {
        sem_wait(pSemaphore);
        printf("Processus %d dans la section critique\n",getpid());
        sleep(1);
        sem_post(pSemaphore);
    }
    exit(0);
}
```

## Ordonnancement

### First Come, First Served

Le premier arrivé dans la file de threads/processus est le
premier exécuté.

### Shortest Job First

Celui qui a le temps d'exécution le plus court est exécuté en
premier. Si un processus a un temps d'exécution plus court que
que les autres, mais qu'il a un temps d'arrivé qui fait qu'il 
arrive après les autres, il sera exécuté après l'exécution du
processus courant.

### Shortest Remaining Time

On prend le processus qui a le temps le plus court et on
l'effectue en premier. À chaque fois qu'un nouveau processus
arrive, on déduit le temps d'exécution qui s'est écoulé du temps
du processus actuel et on regarde si avec cette déduction, on est
mieux de changer de processus.

### Round Robin

L'ordonnanceur prend un quanta de temps (exemple: 4 ms)
et exécute le premier processus. Si celui peut encore s'exécuter
à la fin du quanta, l'ordonnanceur le place à la fin de la file
et il prend le prochain processus. Il effectue ensuite la même
étape avec le nouveau processus et ainsi de suite jusqu'à ce 
que tous les processus soient finis.

#### Taille du quanta

Il ne faut pas que le quanta soit trop petit, car, sinon, il y
aura des pertes de temps lors des fréquents changements de 
processus. Il ne faut pas non plus qu'il soit trop long, sinon
il risque d'y avoir des pertes de temps si les processus sont 
plus courts. Aussi, la réponse sera moins fluide, car les
processus seront exécutés plus longtemps individuellement.
