# Interblocages

## Conditions à remplir pour interblocage

1. Exclusion mutuelle
    - Ressource est attribuée ou disponible, pas les deux
2. Détention et attente
    - Processus peut redemander plus de ressources
3. Pas de réquisition
    - Ressources ne peuvent pas être retirée: libération
    seulement par le processus possédant les ressources
4. Attente circulaire
    - Un cycle d'au moins 2 processus

### Approches de solution

1. Autruche
2. Détection et reprise
3. Les éviter de manière dynamique en allouant les ressources avec
précaution
4. Prévenir en empêchant l'une des 4 conditions

#### Autruche

- Prétendre qu'il n'y a pas de problème
- Dépend de la probabilité d'un interblocage

#### Détection et reprise

- On ne cherche pas à les empêcher
- Cherche
    - À les détecter
    - Puis remédier *a posteriori*
- Première étape: avoir un algorithme de détection d'interblocage

##### Algorithme

L'algorithme est le suivant:

```
while (graphe n'est pas vide) {
    trouver un noeud n sans arc sortants
    if (ne peut pas en trouver) {
        return oui, a un cycle
    }
    effacer le noeud n et les arcs entrants
}
return non, on n'a pas de cycle
```

##### Reprendre un interblocage

- Préemption
    - Va retirer la ressource avec les conséquences
- Rollback (Point de reprise)
    - Enregistrer des points de reprise dans le processus
- Suppression de processus
    - Dans le cycle ou non
    - Avec les conséquences (compilation vs. base de données)

#### Évitement des interblocages

Un état est sûr[^1] s'il existe un ordonnancement selon lequel tous
les processus terminent, même si **tous** demandent leur nombre
**maximum** de ressources d'un coup.

[^1]: Un état non sûr ne conduit pas nécessairement à un interblocage.
      Il y a seulement une perte de garantie de ne pas en avoir.

##### Algorithme du banquier

Nous avons $C$ qui est la matrice des ressources attribuées et $Max$,
la matrice du maximum de ressources demandées. Nous avons 

$$
    R = Max - C
$$

###### Inconvénients

- Difficile à utiliser car on a besoin de savoir les ressources maximum
- Nombre de processus est dynamique
- En pratique, peu utilisé
    - Plus d'intérêt théorique

#### Prévenir en empêchant une des quatre conditions

##### Exclusion mutuelle

On marque une ressource comme attribuée ou disponible, mais
pas les deux.

##### Détention et attente

Forcer tous les processus à demander toutes les ressources
nécessaires au début, avant l'exécution du processus.

##### Pas de réquisition (non-préemption)

Les ressources ne peuvent pas être retirée: libération par
le processus possédant les ressources.

##### Attente circulaire

Éliminer les cycles.

## Dîner des N philosophes

```C
#define N 5                     /* number of philosophers */
#define LEFT (i + N − 1) % N    /* number of i’s left neighbor */
#define RIGHT (i + 1) % N       /* number of i’s right neighbor */
#define THINKING 0              /* philosopher is thinking */
#define HUNGRY 1                /* philosopher is trying to get forks */
#define EATING 2                /* philosopher is eating */

typedef int semaphore;          /* semaphores are a special kind of int */
int state[N];                   /* array to keep track of everyone’s state */
semaphore mutex = 1;            /* mutual exclusion for critical regions */
semaphore s[N];                 /* one semaphore per philosopher */

void philosopher(int i)         /* i: philosopher number, from 0 to N−1 */
{
    while (TRUE) {              /* repeat forever */
        think( );               /* philosopher is thinking */
        take_forks(i);          /* acquire two forks or block */
        eat( );                 /* yum-yum, spaghetti */
        put_forks(i);           /* put both for ks back on table */
    }
} 

void take_forks(int i)          /* i: philosopher number, from 0 to N−1 */
{
    down(&mutex);               /* enter critical region */
    state[i] = HUNGRY;          /* record fact that philosopher i is hungry */
    test(i);                    /* try to acquire 2 for ks */
    up(&mutex);                 /* exit critical region */
    down(&s[i]);                /* block if forks were not acquired */
} 

void put_forks(int i)           /* i: philosopher number, from 0 to N−1 */
{
    down(&mutex);               /* enter critical region */
    state[i] = THINKING;        /* philosopher has finished eating */
    test(LEFT);                 /* see if left neighbor can now eat */
    test(RIGHT);                /* see if right neighbor can now eat */
    up(&mutex);                 /* exit critical region */
}




void test(i) /* i: philosopher number, from 0 to N−1 */
{
    if (state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] != EATING) {
        state[i] = EATING;
        up(&s[i]);
    }
}
```
