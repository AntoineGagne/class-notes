<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Antoine Gagné">
  <title>Notes de cours</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="../../web_notes/css/notes_style.css">
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<div class="navbar">
    <button id="toggle-nav">
        <span class="sr-only">Toggle navigation</span>
        <span class="bar"></span>
        <span class="bar"></span>
        <span class="bar"></span>
    </button>
</div>
<header>
<h1 class="title">Notes de cours</h1>
<h2 class="author">Antoine Gagné</h2>
<h3 class="date">19 février 2016</h3>
</header>
<nav id="TOC">
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a><ul>
<li><a href="#architecture-dun-ordinateur"><span class="toc-section-number">1.1</span> Architecture d’un ordinateur</a><ul>
<li><a href="#couche-logiciel"><span class="toc-section-number">1.1.1</span> Couche logiciel</a></li>
<li><a href="#couche-noyau"><span class="toc-section-number">1.1.2</span> Couche noyau</a></li>
<li><a href="#couche-matériel"><span class="toc-section-number">1.1.3</span> Couche matériel</a></li>
</ul></li>
<li><a href="#système-dexploitation"><span class="toc-section-number">1.2</span> Système d’exploitation</a><ul>
<li><a href="#définition-dun-système-dexploitation"><span class="toc-section-number">1.2.1</span> Définition d’un système d’exploitation</a></li>
<li><a href="#buts-principaux"><span class="toc-section-number">1.2.2</span> Buts principaux</a></li>
<li><a href="#composantes"><span class="toc-section-number">1.2.3</span> Composantes</a><ul>
<li><a href="#noyau"><span class="toc-section-number">1.2.3.1</span> Noyau</a></li>
<li><a href="#librairie-système"><span class="toc-section-number">1.2.3.2</span> Librairie système</a></li>
<li><a href="#programmes-systèmes"><span class="toc-section-number">1.2.3.3</span> Programmes systèmes</a></li>
</ul></li>
</ul></li>
<li><a href="#processeurs"><span class="toc-section-number">1.3</span> Processeurs</a><ul>
<li><a href="#principaux-registres"><span class="toc-section-number">1.3.1</span> Principaux registres</a><ul>
<li><a href="#compteur-ordinal-program-counter-pc"><span class="toc-section-number">1.3.1.1</span> Compteur ordinal / <em>Program Counter</em> (PC)</a></li>
<li><a href="#pointeur-de-pile-stack-pointer"><span class="toc-section-number">1.3.1.2</span> Pointeur de pile / <em>Stack pointer</em></a><ul>
<li><a href="#pile"><span class="toc-section-number">1.3.1.2.1</span> Pile</a></li>
</ul></li>
<li><a href="#mot-détat-program-status-word"><span class="toc-section-number">1.3.1.3</span> Mot d’état / <em>Program status word</em></a></li>
</ul></li>
</ul></li>
<li><a href="#mémoire"><span class="toc-section-number">1.4</span> Mémoire</a></li>
<li><a href="#appel-système"><span class="toc-section-number">1.5</span> Appel système</a><ul>
<li><a href="#définition"><span class="toc-section-number">1.5.1</span> Définition</a><ul>
<li><a href="#exemples"><span class="toc-section-number">1.5.1.1</span> Exemples</a></li>
</ul></li>
<li><a href="#privilèges"><span class="toc-section-number">1.5.2</span> Privilèges</a></li>
<li><a href="#table-des-interruptions-idt"><span class="toc-section-number">1.5.3</span> Table des interruptions IDT</a></li>
<li><a href="#exemple-dexécution-dun-appel-système"><span class="toc-section-number">1.5.4</span> Exemple d’exécution d’un appel système</a></li>
</ul></li>
</ul></li>
<li><a href="#processus-et-threads"><span class="toc-section-number">2</span> Processus et threads</a><ul>
<li><a href="#processus"><span class="toc-section-number">2.1</span> Processus</a><ul>
<li><a href="#définition-1"><span class="toc-section-number">2.1.1</span> Définition</a></li>
<li><a href="#ordonnanceur"><span class="toc-section-number">2.1.2</span> Ordonnanceur</a></li>
</ul></li>
<li><a href="#fork"><span class="toc-section-number">2.2</span> <code>fork()</code></a><ul>
<li><a href="#exemple-de-fork"><span class="toc-section-number">2.2.1</span> Exemple de <code>fork()</code></a></li>
</ul></li>
<li><a href="#threads"><span class="toc-section-number">2.3</span> Threads</a><ul>
<li><a href="#exemple-de-code-de-threads"><span class="toc-section-number">2.3.1</span> Exemple de code de threads</a></li>
<li><a href="#threads-utilisateurs"><span class="toc-section-number">2.3.2</span> Threads utilisateurs</a><ul>
<li><a href="#avantages"><span class="toc-section-number">2.3.2.1</span> Avantages</a></li>
<li><a href="#désavantages"><span class="toc-section-number">2.3.2.2</span> Désavantages</a></li>
</ul></li>
<li><a href="#threads-noyau"><span class="toc-section-number">2.3.3</span> Threads noyau</a><ul>
<li><a href="#avantages-1"><span class="toc-section-number">2.3.3.1</span> Avantages</a></li>
</ul></li>
</ul></li>
<li><a href="#conditions-de-concurrence"><span class="toc-section-number">2.4</span> Conditions de concurrence</a><ul>
<li><a href="#spinlocks"><span class="toc-section-number">2.4.1</span> Spinlocks</a><ul>
<li><a href="#solution-de-peterson"><span class="toc-section-number">2.4.1.1</span> Solution de Peterson</a></li>
<li><a href="#test-and-set-lock"><span class="toc-section-number">2.4.1.2</span> Test and Set Lock</a></li>
<li><a href="#xchg"><span class="toc-section-number">2.4.1.3</span> XCHG</a></li>
</ul></li>
<li><a href="#sémaphores"><span class="toc-section-number">2.4.2</span> Sémaphores</a><ul>
<li><a href="#posix"><span class="toc-section-number">2.4.2.1</span> POSIX</a></li>
<li><a href="#exemple-dutilisation"><span class="toc-section-number">2.4.2.2</span> Exemple d’utilisation</a></li>
</ul></li>
</ul></li>
<li><a href="#ordonnancement"><span class="toc-section-number">2.5</span> Ordonnancement</a><ul>
<li><a href="#first-come-first-served"><span class="toc-section-number">2.5.1</span> First Come, First Served</a></li>
<li><a href="#shortest-job-first"><span class="toc-section-number">2.5.2</span> Shortest Job First</a></li>
<li><a href="#shortest-remaining-time"><span class="toc-section-number">2.5.3</span> Shortest Remaining Time</a></li>
<li><a href="#round-robin"><span class="toc-section-number">2.5.4</span> Round Robin</a><ul>
<li><a href="#taille-du-quanta"><span class="toc-section-number">2.5.4.1</span> Taille du quanta</a></li>
<li><a href="#file-dexécution"><span class="toc-section-number">2.5.4.2</span> File d’exécution</a></li>
</ul></li>
<li><a href="#ordonnanceurs-linux-o1"><span class="toc-section-number">2.5.5</span> Ordonnanceurs Linux (O(1))</a><ul>
<li><a href="#sched_fifo"><span class="toc-section-number">2.5.5.1</span> <code>SCHED_FIFO</code></a></li>
<li><a href="#sched_rr"><span class="toc-section-number">2.5.5.2</span> <code>SCHED_RR</code></a><ul>
<li><a href="#sched_fifo-et-sched_rr"><span class="toc-section-number">2.5.5.2.0.1</span> <code>SCHED_FIFO</code> et <code>SCHED_RR</code></a></li>
</ul></li>
<li><a href="#sched_normal"><span class="toc-section-number">2.5.5.3</span> <code>SCHED_NORMAL</code></a><ul>
<li><a href="#priorité-statique"><span class="toc-section-number">2.5.5.3.1</span> Priorité statique</a></li>
<li><a href="#priorité-dynamique"><span class="toc-section-number">2.5.5.3.2</span> Priorité dynamique</a></li>
<li><a href="#niveaux-de-priorités"><span class="toc-section-number">2.5.5.3.3</span> Niveaux de priorités</a></li>
<li><a href="#timeslice"><span class="toc-section-number">2.5.5.3.4</span> Timeslice</a><ul>
<li><a href="#algorithme"><span class="toc-section-number">2.5.5.3.4.1</span> Algorithme</a></li>
<li><a href="#pourcentage-de-temps-de-processeur"><span class="toc-section-number">2.5.5.3.4.2</span> Pourcentage de temps de processeur</a></li>
<li><a href="#sched_yield"><span class="toc-section-number">2.5.5.3.4.3</span> <code>sched_yield()</code></a></li>
</ul></li>
</ul></li>
<li><a href="#faiblesses"><span class="toc-section-number">2.5.5.4</span> Faiblesses</a></li>
</ul></li>
<li><a href="#ordonnanceur-linux-completely-fair-scheduler-ou-cfs"><span class="toc-section-number">2.5.6</span> Ordonnanceur Linux (Completely Fair Scheduler ou CFS)</a><ul>
<li><a href="#poids-w"><span class="toc-section-number">2.5.6.1</span> Poids <span class="math">\(w\)</span></a></li>
<li><a href="#période-t_period"><span class="toc-section-number">2.5.6.2</span> Période <span class="math">\(T_{period}\)</span></a></li>
<li><a href="#réalisation"><span class="toc-section-number">2.5.6.3</span> Réalisation</a></li>
<li><a href="#nouveaux-processus"><span class="toc-section-number">2.5.6.4</span> Nouveaux processus</a></li>
<li><a href="#processus-bloqué-qui-se-réveille"><span class="toc-section-number">2.5.6.5</span> Processus bloqué qui se réveille</a></li>
<li><a href="#avoir-le-pourcentage-de-temps-de-processeur"><span class="toc-section-number">2.5.6.6</span> Avoir le pourcentage de temps de processeur</a></li>
</ul></li>
<li><a href="#ordonnanceur-windows-vista"><span class="toc-section-number">2.5.7</span> Ordonnanceur Windows Vista</a><ul>
<li><a href="#ordonnancement-windows"><span class="toc-section-number">2.5.7.1</span> Ordonnancement Windows</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#interblocages"><span class="toc-section-number">3</span> Interblocages</a><ul>
<li><a href="#conditions-à-remplir-pour-interblocage"><span class="toc-section-number">3.1</span> Conditions à remplir pour interblocage</a><ul>
<li><a href="#approches-de-solution"><span class="toc-section-number">3.1.1</span> Approches de solution</a><ul>
<li><a href="#autruche"><span class="toc-section-number">3.1.1.1</span> Autruche</a></li>
<li><a href="#détection-et-reprise"><span class="toc-section-number">3.1.1.2</span> Détection et reprise</a><ul>
<li><a href="#algorithme-1"><span class="toc-section-number">3.1.1.2.1</span> Algorithme</a></li>
<li><a href="#reprendre-un-interblocage"><span class="toc-section-number">3.1.1.2.2</span> Reprendre un interblocage</a></li>
</ul></li>
<li><a href="#évitement-des-interblocages"><span class="toc-section-number">3.1.1.3</span> Évitement des interblocages</a><ul>
<li><a href="#algorithme-du-banquier"><span class="toc-section-number">3.1.1.3.1</span> Algorithme du banquier</a><ul>
<li><a href="#inconvénients"><span class="toc-section-number">3.1.1.3.1.1</span> Inconvénients</a></li>
</ul></li>
</ul></li>
<li><a href="#prévenir-en-empêchant-une-des-quatre-conditions"><span class="toc-section-number">3.1.1.4</span> Prévenir en empêchant une des quatre conditions</a><ul>
<li><a href="#exclusion-mutuelle"><span class="toc-section-number">3.1.1.4.1</span> Exclusion mutuelle</a></li>
<li><a href="#détention-et-attente"><span class="toc-section-number">3.1.1.4.2</span> Détention et attente</a></li>
<li><a href="#pas-de-réquisition-non-préemption"><span class="toc-section-number">3.1.1.4.3</span> Pas de réquisition (non-préemption)</a></li>
<li><a href="#attente-circulaire"><span class="toc-section-number">3.1.1.4.4</span> Attente circulaire</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#dîner-des-n-philosophes"><span class="toc-section-number">3.2</span> Dîner des N philosophes</a></li>
</ul></li>
<li><a href="#annexe"><span class="toc-section-number">4</span> Annexe</a></li>
</ul>
</nav>
<section id="introduction" class="level1">
<h1><a href="#introduction"><span class="header-section-number">1</span> Introduction</a></h1>
<p>Ce chapitre est une introduction et fera une brève introduction des systèmes d’exploitation.</p>
<section id="architecture-dun-ordinateur" class="level2">
<h2><a href="#architecture-dun-ordinateur"><span class="header-section-number">1.1</span> Architecture d’un ordinateur</a></h2>
<p>Un ordinateur est composé de plusieurs couches:</p>
<ul>
<li>Couche logiciel</li>
<li>Couche noyau</li>
<li>Couche matériel</li>
</ul>
<section id="couche-logiciel" class="level3">
<h3><a href="#couche-logiciel"><span class="header-section-number">1.1.1</span> Couche logiciel</a></h3>
<p>La couche logiciel est la couche dans laquelle vit l’utilisateur. Elle ne peut exécuter que quelques instructions machines. En particulier, les opérations qui modifient le contrôle de la machine ou qui font de l’<strong>entrée/sortie</strong> (<strong>I/O</strong>) sont interdites dans cette couche.</p>
</section>
<section id="couche-noyau" class="level3">
<h3><a href="#couche-noyau"><span class="header-section-number">1.1.2</span> Couche noyau</a></h3>
<p>La couche noyau est la couche dans laquelle vit le système d’exploitation. Elle a un contrôle absolu sur le matériel et peut exécuter n’importe quelles instructions que la machine permet.</p>
</section>
<section id="couche-matériel" class="level3">
<h3><a href="#couche-matériel"><span class="header-section-number">1.1.3</span> Couche matériel</a></h3>
<p>La couche matériel est la couche dans laquelle on retrouve le matériel qui compose l’ordinateur ainsi que les instructions machines que les composants permettent.</p>
</section>
</section>
<section id="système-dexploitation" class="level2">
<h2><a href="#système-dexploitation"><span class="header-section-number">1.2</span> Système d’exploitation</a></h2>
<p>Dans cette section, nous verrons brièvement les systèmes d’exploitation.</p>
<section id="définition-dun-système-dexploitation" class="level3">
<h3><a href="#définition-dun-système-dexploitation"><span class="header-section-number">1.2.1</span> Définition d’un système d’exploitation</a></h3>
<p>Un système d’exploitation est l’ensemble des programmes qui communiquent avec le matériel et contrôlent l’<strong>allocation des ressources</strong> aux autres programmes du système.</p>
</section>
<section id="buts-principaux" class="level3">
<h3><a href="#buts-principaux"><span class="header-section-number">1.2.2</span> Buts principaux</a></h3>
<p>Les buts d’un système d’exploitation sont</p>
<ul>
<li>Offrir une abstraction de haut-niveau des ressources</li>
<li>Gérer les ressources matérielles de l’ordinateur</li>
</ul>
</section>
<section id="composantes" class="level3">
<h3><a href="#composantes"><span class="header-section-number">1.2.3</span> Composantes</a></h3>
<section id="noyau" class="level4">
<h4><a href="#noyau"><span class="header-section-number">1.2.3.1</span> Noyau</a></h4>
<ul>
<li>Niveau privilège noyau</li>
<li>Accès à toutes les ressources</li>
</ul>
</section>
<section id="librairie-système" class="level4">
<h4><a href="#librairie-système"><span class="header-section-number">1.2.3.2</span> Librairie système</a></h4>
<ul>
<li>Niveau privilège utilisateur</li>
<li>Interface pour les appels systèmes</li>
</ul>
</section>
<section id="programmes-systèmes" class="level4">
<h4><a href="#programmes-systèmes"><span class="header-section-number">1.2.3.3</span> Programmes systèmes</a></h4>
</section>
</section>
</section>
<section id="processeurs" class="level2">
<h2><a href="#processeurs"><span class="header-section-number">1.3</span> Processeurs</a></h2>
<section id="principaux-registres" class="level3">
<h3><a href="#principaux-registres"><span class="header-section-number">1.3.1</span> Principaux registres</a></h3>
<p>Il y a plusieurs registres dans un processeur</p>
<ul>
<li>Compteur ordinal / <em>Program Counter</em> (PC)</li>
<li>Pointeur de pile / <em>Stack pointer</em></li>
<li>Mot d’état / <em>Program status word</em></li>
</ul>
<p>Ces registres sont préservés lors d’un changement de contexte.</p>
<section id="compteur-ordinal-program-counter-pc" class="level4">
<h4><a href="#compteur-ordinal-program-counter-pc"><span class="header-section-number">1.3.1.1</span> Compteur ordinal / <em>Program Counter</em> (PC)</a></h4>
<p>Ce registre donne l’adresse de l’instruction en cours.</p>
</section>
<section id="pointeur-de-pile-stack-pointer" class="level4">
<h4><a href="#pointeur-de-pile-stack-pointer"><span class="header-section-number">1.3.1.2</span> Pointeur de pile / <em>Stack pointer</em></a></h4>
<p>Ce registre donne l’adresse courante du sommet de la pile.</p>
<section id="pile" class="level5">
<h5><a href="#pile"><span class="header-section-number">1.3.1.2.1</span> Pile</a></h5>
<p>La pile contient l’adresse de retour des fonctions. Elle contient aussi les paramètres lors de l’appel de fonction. Elle contient aussi les variables locales de la fonction.</p>
</section>
</section>
<section id="mot-détat-program-status-word" class="level4">
<h4><a href="#mot-détat-program-status-word"><span class="header-section-number">1.3.1.3</span> Mot d’état / <em>Program status word</em></a></h4>
<p>Ce registre donne l’état du processeur et les bits de comparaison (zéro, overflow, etc.). Il est très important pour les opérations IO.</p>
</section>
</section>
</section>
<section id="mémoire" class="level2">
<h2><a href="#mémoire"><span class="header-section-number">1.4</span> Mémoire</a></h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Temps d’accès</th>
<th style="text-align: left;">Couche</th>
<th style="text-align: left;">Capacité</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1 nsec</td>
<td style="text-align: left;">Registres</td>
<td style="text-align: left;">&lt; 1 KB</td>
</tr>
<tr class="even">
<td style="text-align: left;">2 nsec</td>
<td style="text-align: left;">Cache</td>
<td style="text-align: left;">4 MB</td>
</tr>
<tr class="odd">
<td style="text-align: left;">10 nsec</td>
<td style="text-align: left;">Mémoire pricipale</td>
<td style="text-align: left;">1-8 GB</td>
</tr>
<tr class="even">
<td style="text-align: left;">10 msec</td>
<td style="text-align: left;">Bande magnétique</td>
<td style="text-align: left;">1-4 TB</td>
</tr>
</tbody>
</table>
</section>
<section id="appel-système" class="level2">
<h2><a href="#appel-système"><span class="header-section-number">1.5</span> Appel système</a></h2>
<section id="définition" class="level3">
<h3><a href="#définition"><span class="header-section-number">1.5.1</span> Définition</a></h3>
<ul>
<li>Fonctionnalité fournie par le noyau du système d’exploitation</li>
<li>Fait par l’entremise de la librairie système</li>
<li>Doit ultimement tourner en mode noyau</li>
<li>L’appelant tourne en mode utilisateur</li>
</ul>
<section id="exemples" class="level4">
<h4><a href="#exemples"><span class="header-section-number">1.5.1.1</span> Exemples</a></h4>
<ul>
<li><code>read</code>/<code>write</code>: lecture/écriture fichier</li>
<li><code>brk</code>: gestion de la mémoire</li>
<li><code>fork</code>: créer un nouveau processus</li>
<li><code>waitpid</code>: attendre la fin d’un processus</li>
<li><code>kill</code>: signaler un processus</li>
<li><code>time</code>: avoir l’heure</li>
</ul>
<p>Il y en a environ 300 sur Linux.</p>
</section>
</section>
<section id="privilèges" class="level3">
<h3><a href="#privilèges"><span class="header-section-number">1.5.2</span> Privilèges</a></h3>
<ul>
<li>Nécessite un changement de niveau de privilège</li>
<li>Se fait lors de l’exécution d’instructions machines particulières:
<ul>
<li>interruption logiciel <code>INT n</code> ou</li>
<li><code>SYSCALL</code>/<code>SYSENTER</code></li>
</ul></li>
</ul>
</section>
<section id="table-des-interruptions-idt" class="level3">
<h3><a href="#table-des-interruptions-idt"><span class="header-section-number">1.5.3</span> Table des interruptions IDT</a></h3>
<ul>
<li>Remplie lors du démarrage par la fonction <code>trap_init()</code></li>
<li>Toutes des fonctions du noyau</li>
<li><code>int 0x80</code> est une instruction assembleur qui spécifie au système de passer le contrôle au noyau</li>
</ul>
</section>
<section id="exemple-dexécution-dun-appel-système" class="level3">
<h3><a href="#exemple-dexécution-dun-appel-système"><span class="header-section-number">1.5.4</span> Exemple d’exécution d’un appel système</a></h3>
<pre class="sourceCode C"><code class="sourceCode c">cpt = read(df, &amp;tampon, nbOctets);</code></pre>
</section>
</section>
</section>
<section id="processus-et-threads" class="level1">
<h1><a href="#processus-et-threads"><span class="header-section-number">2</span> Processus et threads</a></h1>
<section id="processus" class="level2">
<h2><a href="#processus"><span class="header-section-number">2.1</span> Processus</a></h2>
<section id="définition-1" class="level3">
<h3><a href="#définition-1"><span class="header-section-number">2.1.1</span> Définition</a></h3>
<p>Une instance de programme qui s’exécute.</p>
</section>
<section id="ordonnanceur" class="level3">
<h3><a href="#ordonnanceur"><span class="header-section-number">2.1.2</span> Ordonnanceur</a></h3>
<p>Responsable de choisir le processus à exécuter.</p>
</section>
</section>
<section id="fork" class="level2">
<h2><a href="#fork"><span class="header-section-number">2.2</span> <code>fork()</code></a></h2>
<p>Lorsque <code>fork()</code> est appelé</p>
<ul>
<li>Le processus se duplique</li>
<li>Un processus enfant est créé</li>
<li>La mémoire qui va être écrite est copiée</li>
<li>Si la mémoire n’est pas écrite, le système d’exploitation va faire pointer les adresses virtuelles vers les mêmes adresses physiques</li>
</ul>
<section id="exemple-de-fork" class="level3">
<h3><a href="#exemple-de-fork"><span class="header-section-number">2.2.1</span> Exemple de <code>fork()</code></a></h3>
<pre class="sourceCode C"><code class="sourceCode c"><span class="dt">int</span> main(<span class="dt">void</span>)
{
   pid_t pid = fork();

   <span class="kw">if</span> (pid == -<span class="dv">1</span>) {
      perror(<span class="st">&quot;fork failed&quot;</span>);
      exit(EXIT_FAILURE);
   }
   <span class="kw">else</span> <span class="kw">if</span> (pid == <span class="dv">0</span>) {
      printf(<span class="st">&quot;Hello from the child process!</span><span class="ch">\n</span><span class="st">&quot;</span>);
      _exit(EXIT_SUCCESS);
   }
   <span class="kw">else</span> {
      <span class="dt">int</span> status;
      (<span class="dt">void</span>)waitpid(pid, &amp;status, <span class="dv">0</span>);
   }
   <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre>
<pre class="sourceCode C"><code class="sourceCode c"><span class="ot">#include &lt;unistd.h&gt;</span>
<span class="ot">#include &lt;sys/types.h&gt;</span>
<span class="ot">#include &lt;sys/wait.h&gt;</span>

<span class="dt">int</span> main ( <span class="dt">int</span> argc, <span class="dt">char</span> *argv[ ] ) {
    <span class="dt">int</span> LePid;
    LePid=fork();
    <span class="kw">if</span> (LePid==<span class="dv">0</span>) { <span class="co">/* fils */</span>
        printf(“je suis le fils %d\n”,getpid());
        sleep(<span class="dv">10</span>); exit();
    }
    <span class="kw">else</span> { <span class="co">/* le parent seulement */</span>
        printf(“je suis le père %d\n”,getpid());
        wait(<span class="dv">0</span>);
    }
}</code></pre>
</section>
</section>
<section id="threads" class="level2">
<h2><a href="#threads"><span class="header-section-number">2.3</span> Threads</a></h2>
<ul>
<li>Partage de l’espace d’adressage
<ul>
<li>Partager variables globales</li>
<li>Pas de protection mémoire entre thread</li>
</ul></li>
<li>Partage des ressources</li>
<li>Chaque thread a sa pile</li>
<li>Beaucoup plus rapide à créer qu’un processus, car moins de ressources associées (tableau de données beaucoup plus petit)</li>
</ul>
<section id="exemple-de-code-de-threads" class="level3">
<h3><a href="#exemple-de-code-de-threads"><span class="header-section-number">2.3.1</span> Exemple de code de threads</a></h3>
<pre class="sourceCode C"><code class="sourceCode c"><span class="dt">void</span> *print_hello(<span class="dt">void</span> *tnum) {
    printf(“Bonjour je suis le thread %d\n”,*(<span class="dt">int</span>*)tnum);
    pthread_exit(NULL);
}
<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[]) {
    <span class="co">// Le programme cree 10 threads et se termine</span>
    <span class="dt">int</span> status, i, Arg[N_THREADS];
    <span class="kw">for</span> (i=<span class="dv">0</span>; i &lt; N_THREADS; i++) {
        Arg[i] = i;
        printf(“Main(): en train de creer thread %d\n”,i);
        status = pthread_create(&amp;threads[i], NULL, print_hello, (<span class="dt">void</span> *)&amp;Arg[i]);
        <span class="kw">if</span> (status != <span class="dv">0</span>) {
        printf(“oops, pthread a retourne le code d’erreur %d\n”,status);
        exit(-<span class="dv">1</span>);
        }
    }
    <span class="co">// Attendre la fin des threads</span>
    <span class="kw">for</span> (i=<span class="dv">0</span>; i &lt; N_THREADS; i++) { pthread_join(threads[i], NULL); }
    exit(NULL);
}</code></pre>
<pre class="sourceCode C"><code class="sourceCode c"><span class="dt">void</span> *print_hello(<span class="dt">void</span> *tnum) {
    printf(“Bonjour je suis le thread %d\n”,*(<span class="dt">int</span>*)tnum);
    pthread_exit(NULL);
}

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[]) {
    <span class="co">// Le programme cree 10 threads et se termine</span>
    pthread_t threads[N_THREADS];
    <span class="dt">int</span> status, i, Arg[N_THREADS];
    <span class="kw">for</span> (i=<span class="dv">0</span>; i &lt; N_THREADS; i++) {
        Arg[i] = i;
        printf(“Main(): en train de creer thread %d\n”,i);
        status = pthread_create(&amp;threads[i], NULL, print_hello, (<span class="dt">void</span> *)&amp;Arg[i]);
        <span class="kw">if</span> (status != <span class="dv">0</span>) {
            printf(“oops, pthread a retourne le code d’erreur %d\n”,status);
            exit(-<span class="dv">1</span>);
        }
        pthread_join(threads[i], NULL);
    }
    exit(NULL);
}</code></pre>
</section>
<section id="threads-utilisateurs" class="level3">
<h3><a href="#threads-utilisateurs"><span class="header-section-number">2.3.2</span> Threads utilisateurs</a></h3>
<section id="avantages" class="level4">
<h4><a href="#avantages"><span class="header-section-number">2.3.2.1</span> Avantages</a></h4>
<ul>
<li>Plus efficace, car pas besoin de passer par le noyau</li>
</ul>
</section>
<section id="désavantages" class="level4">
<h4><a href="#désavantages"><span class="header-section-number">2.3.2.2</span> Désavantages</a></h4>
<ul>
<li>Difficile d’implémenter parfaitement
<ul>
<li>Détecter les appels bloquants
<ul>
<li>pour occuper un autre thread pendant l’attente</li>
</ul></li>
<li>l’idée de base des threads était de ne pas s’en faire avec les appels bloquants</li>
<li>Réécrire certaines fonctions systèmes avec <code>select()</code></li>
</ul></li>
<li>Pas de préemption
<ul>
<li>Processus ne peut pas interrompre un thread</li>
<li>Les threads doivent coopérer</li>
</ul></li>
</ul>
</section>
</section>
<section id="threads-noyau" class="level3">
<h3><a href="#threads-noyau"><span class="header-section-number">2.3.3</span> Threads noyau</a></h3>
<section id="avantages-1" class="level4">
<h4><a href="#avantages-1"><span class="header-section-number">2.3.3.1</span> Avantages</a></h4>
<ul>
<li>Ordonnanceur du système d’exploitation va pouvoir
<ul>
<li>préemption du thread en cours</li>
<li>détecter appels systèmes bloquants</li>
</ul></li>
</ul>
</section>
</section>
</section>
<section id="conditions-de-concurrence" class="level2">
<h2><a href="#conditions-de-concurrence"><span class="header-section-number">2.4</span> Conditions de concurrence</a></h2>
<ul>
<li>Partager un système de stockage (écriture/lecture)
<ul>
<li>fichiers (e.g. ajouts parallèles dans un répertoire)</li>
<li>base de données</li>
<li>mémoire partagée (<em>shared memory</em>)</li>
</ul></li>
<li>Si deux processus tentent d’accéder à ce stockage partagé, il peut y avoir des bogues subtils:
<ul>
<li>conditions de concurrence / <em>race condition</em></li>
</ul></li>
</ul>
<section id="spinlocks" class="level3">
<h3><a href="#spinlocks"><span class="header-section-number">2.4.1</span> Spinlocks</a></h3>
<section id="solution-de-peterson" class="level4">
<h4><a href="#solution-de-peterson"><span class="header-section-number">2.4.1.1</span> Solution de Peterson</a></h4>
<pre class="sourceCode C"><code class="sourceCode c"><span class="dt">int</span> critical[<span class="dv">2</span>];

<span class="dt">void</span> enter_region(<span class="dt">int</span> process) {
    <span class="dt">int</span> other;
    other = <span class="dv">1</span> - process; <span class="co">// Position 1</span>
    critical[process]=<span class="dv">1</span>; <span class="co">// Position 2</span>
    waiting = process;
    <span class="kw">while</span>(waiting==process&amp;&amp;critical[other] == <span class="dv">1</span>);
}

<span class="dt">void</span> leave_region(<span class="dt">int</span> process) {
    critical[process] = <span class="dv">0</span>;
}</code></pre>
</section>
<section id="test-and-set-lock" class="level4">
<h4><a href="#test-and-set-lock"><span class="header-section-number">2.4.1.2</span> Test and Set Lock</a></h4>
<pre class="ARM"><code>enter_region:
    TSL EAX, LOCK    | copie LOCK dans registre EAX, LOCK = 1
    CMP EAX, #0      | LOCK était-elle à 0?
    JNE enter_region | si LOCK pas à 0, boucle
    RET              | LOCK libre, entre dans section critique

leave_region:
    MOV LOCK, #0     | écrit un 0 dans LOCK
    RET              | retourne à l’appelant</code></pre>
</section>
<section id="xchg" class="level4">
<h4><a href="#xchg"><span class="header-section-number">2.4.1.3</span> XCHG</a></h4>
<pre class="ASM"><code>enter_region:
    MOV EAX, #1       | copie LOCK dans registre, LOCK = EAX
    XCHG EAX, LOCK    | LOCK était-elle à 0?
    CMP EAX, #0       | si LOCK pas à 0, boucle
    JNE enter_region  | LOCK libre, entre dans section critique
    RET
leave_region:
    MOV LOCK, #0      | écrit un 0 dans LOCK
    RET               | retourne à l’appelant</code></pre>
</section>
</section>
<section id="sémaphores" class="level3">
<h3><a href="#sémaphores"><span class="header-section-number">2.4.2</span> Sémaphores</a></h3>
<section id="posix" class="level4">
<h4><a href="#posix"><span class="header-section-number">2.4.2.1</span> POSIX</a></h4>
<pre class="sourceCode C"><code class="sourceCode c">sem_init()      <span class="co">// initialiser sémaphore sans nom</span>
sem_open()      <span class="co">// ouvrir un sémaphore avec nom</span>
sem_close()     <span class="co">// fermer un sémaphore avec nom</span>
sem_unlink()    <span class="co">// enlever sémaphore avec nom</span>
sem_wait()      <span class="co">// down</span>
sem_post()      <span class="co">// up</span>
sem_getvalue()  <span class="co">// valeur du sémaphore</span>
sem_destroy()   <span class="co">// détruire un sémaphore créé par sem_init</span></code></pre>
</section>
<section id="exemple-dutilisation" class="level4">
<h4><a href="#exemple-dutilisation"><span class="header-section-number">2.4.2.2</span> Exemple d’utilisation</a></h4>
<pre class="sourceCode C"><code class="sourceCode c"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[]) {
    <span class="co">// Un seul sémaphore, pour le processus</span>
    sem_t *pSemaphore = sem_open(<span class="st">&quot;UnNomUnique5&quot;</span>, O_CREAT, <span class="dv">0644</span>, <span class="dv">1</span>);
    <span class="kw">if</span> (pSemaphore == SEM_FAILED) {
        <span class="kw">return</span> -<span class="dv">1</span>;
    }
    <span class="dt">int</span> i;
    <span class="kw">for</span> (i = <span class="dv">0</span>; i&lt;<span class="dv">10</span>; i++) {
        sem_wait(pSemaphore);
        printf(<span class="st">&quot;Processus %d dans la section critique</span><span class="ch">\n</span><span class="st">&quot;</span>,getpid());
        sleep(<span class="dv">1</span>);
        sem_post(pSemaphore);
    }
    exit(<span class="dv">0</span>);
}</code></pre>
</section>
</section>
</section>
<section id="ordonnancement" class="level2">
<h2><a href="#ordonnancement"><span class="header-section-number">2.5</span> Ordonnancement</a></h2>
<section id="first-come-first-served" class="level3">
<h3><a href="#first-come-first-served"><span class="header-section-number">2.5.1</span> First Come, First Served</a></h3>
<p>Le premier arrivé dans la file de threads/processus est le premier exécuté.</p>
</section>
<section id="shortest-job-first" class="level3">
<h3><a href="#shortest-job-first"><span class="header-section-number">2.5.2</span> Shortest Job First</a></h3>
<p>Celui qui a le temps d’exécution le plus court est exécuté en premier. Si un processus a un temps d’exécution plus court que que les autres, mais qu’il a un temps d’arrivé qui fait qu’il arrive après les autres, il sera exécuté après l’exécution du processus courant.</p>
</section>
<section id="shortest-remaining-time" class="level3">
<h3><a href="#shortest-remaining-time"><span class="header-section-number">2.5.3</span> Shortest Remaining Time</a></h3>
<p>On prend le processus qui a le temps le plus court et on l’effectue en premier. À chaque fois qu’un nouveau processus arrive, on déduit le temps d’exécution qui s’est écoulé du temps du processus actuel et on regarde si avec cette déduction, on est mieux de changer de processus.</p>
</section>
<section id="round-robin" class="level3">
<h3><a href="#round-robin"><span class="header-section-number">2.5.4</span> Round Robin</a></h3>
<p>L’ordonnanceur prend un quanta de temps (exemple: 4 ms) et exécute le premier processus. Si celui peut encore s’exécuter à la fin du quanta, l’ordonnanceur le place à la fin de la file et il prend le prochain processus. Il effectue ensuite la même étape avec le nouveau processus et ainsi de suite jusqu’à ce que tous les processus soient finis.</p>
<section id="taille-du-quanta" class="level4">
<h4><a href="#taille-du-quanta"><span class="header-section-number">2.5.4.1</span> Taille du quanta</a></h4>
<p>Il ne faut pas que le quanta soit trop petit, car, sinon, il y aura des pertes de temps lors des fréquents changements de processus. Il ne faut pas non plus qu’il soit trop long, sinon il risque d’y avoir des pertes de temps si les processus sont plus courts. Aussi, la réponse sera moins fluide, car les processus seront exécutés plus longtemps individuellement.</p>
</section>
<section id="file-dexécution" class="level4">
<h4><a href="#file-dexécution"><span class="header-section-number">2.5.4.2</span> File d’exécution</a></h4>
<ul>
<li>1 file <strong>expirée</strong>, 1 file <strong>active</strong></li>
<li>1 paire par CPU</li>
<li>140 niveaux de priorités</li>
<li>Petit numéro = grande priorité</li>
<li>Quand toutes les tâches sont expirées, échanger les files: <strong>epoch</strong> (intervertir les pointeurs des files)</li>
</ul>
</section>
</section>
<section id="ordonnanceurs-linux-o1" class="level3">
<h3><a href="#ordonnanceurs-linux-o1"><span class="header-section-number">2.5.5</span> Ordonnanceurs Linux (O(1))</a></h3>
<ul>
<li>Trois <strong>policy</strong>:
<ul>
<li><code>SCHE_FIFO</code>
<ul>
<li>Temps réel, pas de préemption -&gt; pas de quantum</li>
</ul></li>
<li><code>SCHED_RR</code>
<ul>
<li>Temps réel, préemption -&gt; timeslice</li>
</ul></li>
<li><code>SCHED_NORMAL</code>
<ul>
<li>Pour les threads normaux</li>
<li>Vos processus et threads</li>
</ul></li>
</ul></li>
</ul>
<section id="sched_fifo" class="level4">
<h4><a href="#sched_fifo"><span class="header-section-number">2.5.5.1</span> <code>SCHED_FIFO</code></a></h4>
<dl>
<dt><strong>FIFO</strong></dt>
<dd>First In First Out
</dd>
</dl>
<ul>
<li>Premier arrivé, premier servi</li>
<li>Sans préemption, sauf si nouveau plut haute priorité arrive (<em>danger boucle sans fin!</em>)</li>
<li>Processus doit avoir les droits <strong>superuser</strong></li>
</ul>
</section>
<section id="sched_rr" class="level4">
<h4><a href="#sched_rr"><span class="header-section-number">2.5.5.2</span> <code>SCHED_RR</code></a></h4>
<ul>
<li>Peuvent être préempter par <code>SCHED_FIFO</code></li>
<li>Possèdent un quantum</li>
<li>Tourniquet par niveau de priorité</li>
<li>Processus doit avoir les droits <strong>superuser</strong></li>
</ul>
<section id="sched_fifo-et-sched_rr" class="level6">
<h6><a href="#sched_fifo-et-sched_rr"><span class="header-section-number">2.5.5.2.0.1</span> <code>SCHED_FIFO</code> et <code>SCHED_RR</code></a></h6>
<ul>
<li>Vont tourner tant qu’ils ont besoin de temps</li>
<li>Lorsqu’ils ont tout terminé, l’ordonnanceur O(1) commence à exécuter les threads dans <code>SCHED_NORMAL</code></li>
</ul>
</section>
</section>
<section id="sched_normal" class="level4">
<h4><a href="#sched_normal"><span class="header-section-number">2.5.5.3</span> <code>SCHED_NORMAL</code></a></h4>
<section id="priorité-statique" class="level5">
<h5><a href="#priorité-statique"><span class="header-section-number">2.5.5.3.1</span> Priorité statique</a></h5>
<ul>
<li>On attribue un niveau de priorité statique <span class="math">\(P_{statique}\)</span> à chaque processus</li>
<li>Varie entre -20 et -19</li>
<li>Par défaut, <span class="math">\(P_{statique} = 0\)</span></li>
<li>Changer <span class="math">\(P_{statique}\)</span> avec <strong>nice</strong> ou <strong>setpriority()</strong>
<ul>
<li>valeur positive -&gt; réduire priorité
<ul>
<li>pour des longues simulations à tourner</li>
</ul></li>
<li>valeur négative -&gt; augmenter priorité
<ul>
<li>besoin d’être <strong>superuser</strong></li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="priorité-dynamique" class="level5">
<h5><a href="#priorité-dynamique"><span class="header-section-number">2.5.5.3.2</span> Priorité dynamique</a></h5>
<ul>
<li><span class="math">\(P_{dynamique}\)</span> est ajustée automatiquement par le système d’exploitation</li>
<li>Basée sur des heuristiques</li>
<li>Calculé à partir du temps qu’un thread passe bloqué
<ul>
<li>plus il bloque longtemps, plus $P_{dynamique} augmente</li>
</ul></li>
<li>Ne s’applique pas au temps réel
<ul>
<li><code>SCHED_FIFO</code></li>
<li><code>SCHED_RR</code></li>
</ul></li>
</ul>
<p><span class="math">\[
    -5 \leq P_{dynamique} \leq 5
\]</span></p>
</section>
<section id="niveaux-de-priorités" class="level5">
<h5><a href="#niveaux-de-priorités"><span class="header-section-number">2.5.5.3.3</span> Niveaux de priorités</a></h5>
<p><span class="math">\[P_{sched} = 120 + P_{statique} + P_{dynamique}\]</span></p>
<p>où <span class="math">\(-20 \leq P_{statique} \leq 19\)</span> et <span class="math">\(-5 \leq P_{dynamique} \leq +5\)</span></p>
<ul>
<li>Doit rester dans la plage 100 à 139</li>
</ul>
</section>
<section id="timeslice" class="level5">
<h5><a href="#timeslice"><span class="header-section-number">2.5.5.3.4</span> Timeslice</a></h5>
<p>Les processus <strong>hautes priorités statiques</strong> vont recevoir plus de temps de calcul: <strong>timeslice</strong></p>
<p><span class="math">\[
    \text{Timeslice} =
    \begin{cases}
        (140 - SP) \times 20 &amp;\text{if}~~ SP &lt; 120 \text{(besoin superuser)} \\
        (140 - SP) \times 5  &amp;\text{if}~~ SP \geq 120\\
    \end{cases}
\]</span></p>
<section id="algorithme" class="level6">
<h6><a href="#algorithme"><span class="header-section-number">2.5.5.3.4.1</span> Algorithme</a></h6>
<ol type="1">
<li>On commence par la priorité 100</li>
<li><span class="math">\(\forall P\)</span>:
<ol type="a">
<li>On exécute chaque processus pendant le <strong>timeslice</strong></li>
<li>Si le processu ne termine pas, préempte et transfert dans la file expirée, et exécute le suivant dans <span class="math">\(P\)</span></li>
<li>Si <span class="math">\(P\)</span> est vide, on fait <span class="math">\(P = P + 1\)</span> (on descend)</li>
<li>Si <span class="math">\(P\)</span> est à 140, la file active est vide:
<ol type="i">
<li>Intervertit la file vide avec la file expirée</li>
<li><span class="math">\(P = 100\)</span></li>
<li>On recommence les étapes précédentes</li>
</ol></li>
</ol></li>
</ol>
</section>
<section id="pourcentage-de-temps-de-processeur" class="level6">
<h6><a href="#pourcentage-de-temps-de-processeur"><span class="header-section-number">2.5.5.3.4.2</span> Pourcentage de temps de processeur</a></h6>
<p>Pour avoir le pourcentage de temps de processeur utilisé, on utilise la formule suivante:</p>
<p><span class="math">\[
    \frac{\mathrm{Timeslice}_i}{\sum\limits_{j = 1}^{N} \mathrm{Timeslice}_j}
\]</span></p>
<p>où <span class="math">\(\mathrm{Timeslice}_i\)</span> est le timeslice du processus dont on souhaite avoir le pourcentage et <span class="math">\(\sum\limits_{j = 1}^{N} \mathrm{Timeslice}_j\)</span> est la somme des timeslices de tous les autres processus (y compris le processus courant).</p>
</section>
<section id="sched_yield" class="level6">
<h6><a href="#sched_yield"><span class="header-section-number">2.5.5.3.4.3</span> <code>sched_yield()</code></a></h6>
<ul>
<li>Dit au système d’exploitation qu’on veut céder son tour</li>
<li>L’ordonnanceur déplace le thread appelant de la <strong>file active</strong> à la <strong>file expirée</strong></li>
<li>Tous les autres threads seront ré-exécutés avant que l’appelant du <code>sched_yield()</code> ne reçoive le processeur de nouveau.</li>
</ul>
</section>
</section>
</section>
<section id="faiblesses" class="level4">
<h4><a href="#faiblesses"><span class="header-section-number">2.5.5.4</span> Faiblesses</a></h4>
<ul>
<li>Performe bien pour des serveurs de calcul</li>
<li>Pour des ordinateurs personnels, processus interactifs souffrent
<ul>
<li><em>IO-bound</em>, car ils attendent sur le clavier et la souris</li>
</ul></li>
<li>Processus de faibles priorités peuvent souffrir de famine</li>
<li>Ratio entre les <em>timeslices</em> de priorité consécutives varie grandement</li>
</ul>
</section>
</section>
<section id="ordonnanceur-linux-completely-fair-scheduler-ou-cfs" class="level3">
<h3><a href="#ordonnanceur-linux-completely-fair-scheduler-ou-cfs"><span class="header-section-number">2.5.6</span> Ordonnanceur Linux (Completely Fair Scheduler ou CFS)</a></h3>
<ul>
<li>Cherche à simuler un processeur parfait et offrir <span class="math">\(\frac{1}{N}\)</span> du processeur aux <span class="math">\(N\)</span> processus…</li>
<li>… mais aussi en tenant compte de leur priorité</li>
<li>Juste entre les différents utilisateurs aussi</li>
<li>L’algorithme s’applique seulement à <code>SCHED_NORMAL</code></li>
</ul>
<section id="poids-w" class="level4">
<h4><a href="#poids-w"><span class="header-section-number">2.5.6.1</span> Poids <span class="math">\(w\)</span></a></h4>
<ul>
<li>Pour chaque niveau de priorité, on associe un poids <span class="math">\(w\)</span></li>
<li>Progression géométrique, avec ratio de 1.25 entre les valeurs de priorités consécutives</li>
</ul>
<p><span class="math">\[
    \frac{w(p - 1)}{w(p)} \approx 1.25
\]</span></p>
<ul>
<li>La fraction moyenne d’exécution désirée pour chaque thread <span class="math">\(i\)</span> sera</li>
</ul>
<p><span class="math">\[
    \frac{w_i}{\sum\limits_{j = 1}^{N} w_j}
\]</span></p>
<p>où <span class="math">\(N\)</span> est le nombre de processus prêt à tourner</p>
</section>
<section id="période-t_period" class="level4">
<h4><a href="#période-t_period"><span class="header-section-number">2.5.6.2</span> Période <span class="math">\(T_{period}\)</span></a></h4>
<ul>
<li><span class="math">\(T_{period}\)</span>: Période pendant laquelle on voudrait idéalement faire tourner chacun des <span class="math">\(N\)</span> threads une fois</li>
<li><span class="math">\(T_{slice}\)</span>: Temps d’exécution du thread <span class="math">\(i\)</span>:</li>
</ul>
<p><span class="math">\[
    T_{slice} = T_{period} \frac{w_i}{\sum\limits_{j = 1}^{N}}
\]</span></p>
<p>Idéalement, <span class="math">\(T_{period} = 15 ~\mathrm{ms}\)</span></p>
</section>
<section id="réalisation" class="level4">
<h4><a href="#réalisation"><span class="header-section-number">2.5.6.3</span> Réalisation</a></h4>
<ul>
<li>À chaque <em>top d’horloge</em> (intervalle <span class="math">\(\Delta t = 1.4\)</span> ou <span class="math">\(10 ~\mathrm{ms}\)</span>), l’ordonnanceur:
<ul>
<li>Ajuste le <strong>vruntime</strong> du processus en cours par plus <span class="math">\(\frac{1024}{w}\Delta t\)</span></li>
<li>Vérifie s’il a tourné plus que <span class="math">\(T_{slice}\)</span>. Si oui, on insère le processus en cours dans la liste, puis on choisi le nouveau processus (ou thread) qui a le plus petit <strong>vruntime</strong> dans la liste triée (un <em>red-black tree</em>)</li>
</ul></li>
<li><strong>vruntime</strong> va permettre de corriger, à la longue, les erreurs d’arrondi d’exécution</li>
</ul>
</section>
<section id="nouveaux-processus" class="level4">
<h4><a href="#nouveaux-processus"><span class="header-section-number">2.5.6.4</span> Nouveaux processus</a></h4>
<ul>
<li>Ordonnanceur lui donne le plus petit runtime de la liste:</li>
</ul>
<p><span class="math">\[
    \mathrm{vruntime}~=~\mathrm{min}(P_i.\mathrm{vruntime})
\]</span></p>
<ul>
<li>Favorise l’exécution rapide du nouveau processus</li>
</ul>
</section>
<section id="processus-bloqué-qui-se-réveille" class="level4">
<h4><a href="#processus-bloqué-qui-se-réveille"><span class="header-section-number">2.5.6.5</span> Processus bloqué qui se réveille</a></h4>
<ul>
<li>Donner une certaine priorité au réveil: <strong>interactivité</strong></li>
<li>Si processus dors moins longtemps que <span class="math">\(T_{period}\)</span>:
<ul>
<li>Ordonnanceur réinsère dans la file sans toucher à son <strong>vruntime</strong></li>
</ul></li>
<li>Si processus dort plus longtemps que <span class="math">\(T_{period}\)</span>:
<ul>
<li>Lui donner <span class="math">\(\mathrm{vruntime}~=~\mathrm{min}(P_i.\mathrm{vruntime})\)</span> dans la file</li>
<li>A pour effet de le faire démarrer rapidement</li>
<li>Assure que son vruntime n’est pas artificiellement très faible (si a dormi longtemps)</li>
</ul></li>
</ul>
</section>
<section id="avoir-le-pourcentage-de-temps-de-processeur" class="level4">
<h4><a href="#avoir-le-pourcentage-de-temps-de-processeur"><span class="header-section-number">2.5.6.6</span> Avoir le pourcentage de temps de processeur</a></h4>
<p>Pour avoir le pourcentage de temps de processeur pour chaque processus, on utilise la formule suivante:</p>
<p><span class="math">\[
    \frac{w_i}{\sum\limits_{j = 1}^{N}}
\]</span></p>
<p>où <span class="math">\(w_i\)</span> est le poid processus dont on souhaite avoir le pourcentage de temps de processeur et <span class="math">\(\sum\limits_{j = 1}^{N}\)</span> est la somme du poid de chacun des processus (y compris celui qui est exécuté).</p>
</section>
</section>
<section id="ordonnanceur-windows-vista" class="level3">
<h3><a href="#ordonnanceur-windows-vista"><span class="header-section-number">2.5.7</span> Ordonnanceur Windows Vista</a></h3>
<section id="ordonnancement-windows" class="level4">
<h4><a href="#ordonnancement-windows"><span class="header-section-number">2.5.7.1</span> Ordonnancement Windows</a></h4>
<ul>
<li>Ordonnanceur appelé lors des conditions suivantes:
<ol type="1">
<li>Bloque sur sémaphore, mutex, événement, I/O</li>
<li>Signale un objet (sémaphore, mutex, etc.) <code>ReleaseMutex()</code></li>
<li>Quantum de temps a expiré</li>
<li>Thread voit sa priorité rehaussée</li>
</ol></li>
</ul>
</section>
</section>
</section>
</section>
<section id="interblocages" class="level1">
<h1><a href="#interblocages"><span class="header-section-number">3</span> Interblocages</a></h1>
<section id="conditions-à-remplir-pour-interblocage" class="level2">
<h2><a href="#conditions-à-remplir-pour-interblocage"><span class="header-section-number">3.1</span> Conditions à remplir pour interblocage</a></h2>
<ol type="1">
<li>Exclusion mutuelle
<ul>
<li>Ressource est attribuée ou disponible, pas les deux</li>
</ul></li>
<li>Détention et attente
<ul>
<li>Processus peut redemander plus de ressources</li>
</ul></li>
<li>Pas de réquisition
<ul>
<li>Ressources ne peuvent pas être retirée: libération seulement par le processus possédant les ressources</li>
</ul></li>
<li>Attente circulaire
<ul>
<li>Un cycle d’au moins 2 processus</li>
</ul></li>
</ol>
<section id="approches-de-solution" class="level3">
<h3><a href="#approches-de-solution"><span class="header-section-number">3.1.1</span> Approches de solution</a></h3>
<ol type="1">
<li>Autruche</li>
<li>Détection et reprise</li>
<li>Les éviter de manière dynamique en allouant les ressources avec précaution</li>
<li>Prévenir en empêchant l’une des 4 conditions</li>
</ol>
<section id="autruche" class="level4">
<h4><a href="#autruche"><span class="header-section-number">3.1.1.1</span> Autruche</a></h4>
<ul>
<li>Prétendre qu’il n’y a pas de problème</li>
<li>Dépend de la probabilité d’un interblocage</li>
</ul>
</section>
<section id="détection-et-reprise" class="level4">
<h4><a href="#détection-et-reprise"><span class="header-section-number">3.1.1.2</span> Détection et reprise</a></h4>
<ul>
<li>On ne cherche pas à les empêcher</li>
<li>Cherche
<ul>
<li>À les détecter</li>
<li>Puis remédier <em>a posteriori</em></li>
</ul></li>
<li>Première étape: avoir un algorithme de détection d’interblocage</li>
</ul>
<section id="algorithme-1" class="level5">
<h5><a href="#algorithme-1"><span class="header-section-number">3.1.1.2.1</span> Algorithme</a></h5>
<p>L’algorithme est le suivant:</p>
<pre><code>while (graphe n&#39;est pas vide) {
    trouver un noeud n sans arc sortants
    if (ne peut pas en trouver) {
        return oui, a un cycle
    }
    effacer le noeud n et les arcs entrants
}
return non, on n&#39;a pas de cycle</code></pre>
</section>
<section id="reprendre-un-interblocage" class="level5">
<h5><a href="#reprendre-un-interblocage"><span class="header-section-number">3.1.1.2.2</span> Reprendre un interblocage</a></h5>
<ul>
<li>Préemption
<ul>
<li>Va retirer la ressource avec les conséquences</li>
</ul></li>
<li>Rollback (Point de reprise)
<ul>
<li>Enregistrer des points de reprise dans le processus</li>
</ul></li>
<li>Suppression de processus
<ul>
<li>Dans le cycle ou non</li>
<li>Avec les conséquences (compilation vs. base de données)</li>
</ul></li>
</ul>
</section>
</section>
<section id="évitement-des-interblocages" class="level4">
<h4><a href="#évitement-des-interblocages"><span class="header-section-number">3.1.1.3</span> Évitement des interblocages</a></h4>
<p>Un état est sûr<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> s’il existe un ordonnancement selon lequel tous les processus terminent, même si <strong>tous</strong> demandent leur nombre <strong>maximum</strong> de ressources d’un coup.</p>
<section id="algorithme-du-banquier" class="level5">
<h5><a href="#algorithme-du-banquier"><span class="header-section-number">3.1.1.3.1</span> Algorithme du banquier</a></h5>
<p>Nous avons <span class="math">\(C\)</span> qui est la matrice des ressources attribuées et <span class="math">\(Max\)</span>, la matrice du maximum de ressources demandées. Nous avons</p>
<p><span class="math">\[
    R = Max - C
\]</span></p>
<section id="inconvénients" class="level6">
<h6><a href="#inconvénients"><span class="header-section-number">3.1.1.3.1.1</span> Inconvénients</a></h6>
<ul>
<li>Difficile à utiliser car on a besoin de savoir les ressources maximum</li>
<li>Nombre de processus est dynamique</li>
<li>En pratique, peu utilisé
<ul>
<li>Plus d’intérêt théorique</li>
</ul></li>
</ul>
</section>
</section>
</section>
<section id="prévenir-en-empêchant-une-des-quatre-conditions" class="level4">
<h4><a href="#prévenir-en-empêchant-une-des-quatre-conditions"><span class="header-section-number">3.1.1.4</span> Prévenir en empêchant une des quatre conditions</a></h4>
<section id="exclusion-mutuelle" class="level5">
<h5><a href="#exclusion-mutuelle"><span class="header-section-number">3.1.1.4.1</span> Exclusion mutuelle</a></h5>
<p>On marque une ressource comme attribuée ou disponible, mais pas les deux.</p>
</section>
<section id="détention-et-attente" class="level5">
<h5><a href="#détention-et-attente"><span class="header-section-number">3.1.1.4.2</span> Détention et attente</a></h5>
<p>Forcer tous les processus à demander toutes les ressources nécessaires au début, avant l’exécution du processus.</p>
</section>
<section id="pas-de-réquisition-non-préemption" class="level5">
<h5><a href="#pas-de-réquisition-non-préemption"><span class="header-section-number">3.1.1.4.3</span> Pas de réquisition (non-préemption)</a></h5>
<p>Les ressources ne peuvent pas être retirée: libération par le processus possédant les ressources.</p>
</section>
<section id="attente-circulaire" class="level5">
<h5><a href="#attente-circulaire"><span class="header-section-number">3.1.1.4.4</span> Attente circulaire</a></h5>
<p>Éliminer les cycles.</p>
</section>
</section>
</section>
</section>
<section id="dîner-des-n-philosophes" class="level2">
<h2><a href="#dîner-des-n-philosophes"><span class="header-section-number">3.2</span> Dîner des N philosophes</a></h2>
<pre class="sourceCode C"><code class="sourceCode c"><span class="ot">#define N 5                     </span><span class="co">/* number of philosophers */</span>
<span class="ot">#define LEFT (i + N − 1) % N    </span><span class="co">/* number of i’s left neighbor */</span>
<span class="ot">#define RIGHT (i + 1) % N       </span><span class="co">/* number of i’s right neighbor */</span>
<span class="ot">#define THINKING 0              </span><span class="co">/* philosopher is thinking */</span>
<span class="ot">#define HUNGRY 1                </span><span class="co">/* philosopher is trying to get forks */</span>
<span class="ot">#define EATING 2                </span><span class="co">/* philosopher is eating */</span>

<span class="kw">typedef</span> <span class="dt">int</span> semaphore;          <span class="co">/* semaphores are a special kind of int */</span>
<span class="dt">int</span> state[N];                   <span class="co">/* array to keep track of everyone’s state */</span>
semaphore mutex = <span class="dv">1</span>;            <span class="co">/* mutual exclusion for critical regions */</span>
semaphore s[N];                 <span class="co">/* one semaphore per philosopher */</span>

<span class="dt">void</span> philosopher(<span class="dt">int</span> i)         <span class="co">/* i: philosopher number, from 0 to N−1 */</span>
{
    <span class="kw">while</span> (TRUE) {              <span class="co">/* repeat forever */</span>
        think( );               <span class="co">/* philosopher is thinking */</span>
        take_forks(i);          <span class="co">/* acquire two forks or block */</span>
        eat( );                 <span class="co">/* yum-yum, spaghetti */</span>
        put_forks(i);           <span class="co">/* put both for ks back on table */</span>
    }
} 

<span class="dt">void</span> take_forks(<span class="dt">int</span> i)          <span class="co">/* i: philosopher number, from 0 to N−1 */</span>
{
    down(&amp;mutex);               <span class="co">/* enter critical region */</span>
    state[i] = HUNGRY;          <span class="co">/* record fact that philosopher i is hungry */</span>
    test(i);                    <span class="co">/* try to acquire 2 for ks */</span>
    up(&amp;mutex);                 <span class="co">/* exit critical region */</span>
    down(&amp;s[i]);                <span class="co">/* block if forks were not acquired */</span>
} 

<span class="dt">void</span> put_forks(<span class="dt">int</span> i)           <span class="co">/* i: philosopher number, from 0 to N−1 */</span>
{
    down(&amp;mutex);               <span class="co">/* enter critical region */</span>
    state[i] = THINKING;        <span class="co">/* philosopher has finished eating */</span>
    test(LEFT);                 <span class="co">/* see if left neighbor can now eat */</span>
    test(RIGHT);                <span class="co">/* see if right neighbor can now eat */</span>
    up(&amp;mutex);                 <span class="co">/* exit critical region */</span>
}




<span class="dt">void</span> test(i) <span class="co">/* i: philosopher number, from 0 to N−1 */</span>
{
    <span class="kw">if</span> (state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] != EATING) {
        state[i] = EATING;
        up(&amp;s[i]);
    }
}</code></pre>
</section>
</section>
<section id="annexe" class="level1">
<h1><a href="#annexe"><span class="header-section-number">4</span> Annexe</a></h1>
<dl>
<dt><strong>Préemption</strong></dt>
<dd>La capacité de l’ordonnanceur à changer de processus en plein milieu de son exécution.
</dd>
</dl>
</section>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Un état non sûr ne conduit pas nécessairement à un interblocage. Il y a seulement une perte de garantie de ne pas en avoir.<a href="#fnref1">↩</a></p></li>
</ol>
</section>
<script>
    document.getElementById("TOC").className = "mobile-hidden";

    var button = document.getElementById("toggle-nav");

    button.addEventListener("click", function() {
        var tableOfContents = document.getElementById("TOC");
        var navbar = document.getElementsByClassName("navbar")[0];
        if (tableOfContents.className === "") {
            navbar.id = "";
            tableOfContents.className = "mobile-hidden";
        }
        else {
            navbar.id = "fixed-navbar";
            tableOfContents.className = "";
        }
    }, false);
</script>
</body>
</html>
