<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Antoine Gagné">
  <title>Notes de cours</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="../../web_notes/css/notes_style.css">
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<div class="navbar">
    <button id="toggle-nav">
        <span class="sr-only">Toggle navigation</span>
        <span class="bar"></span>
        <span class="bar"></span>
        <span class="bar"></span>
    </button>
</div>
<header>
<h1 class="title">Notes de cours</h1>
<h2 class="author">Antoine Gagné</h2>
<h3 class="date">5 février 2016</h3>
</header>
<nav id="TOC">
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a><ul>
<li><a href="#lancêtre-des-bases-de-données"><span class="toc-section-number">1.1</span> L’ancêtre des bases de données</a><ul>
<li><a href="#problèmes"><span class="toc-section-number">1.1.1</span> Problèmes</a><ul>
<li><a href="#séparation-et-isolation-des-données"><span class="toc-section-number">1.1.1.1</span> Séparation et isolation des données</a></li>
<li><a href="#duplication-des-données"><span class="toc-section-number">1.1.1.2</span> Duplication des données</a></li>
<li><a href="#dépendences-des-données"><span class="toc-section-number">1.1.1.3</span> Dépendences des données</a></li>
<li><a href="#format-de-fichiers"><span class="toc-section-number">1.1.1.4</span> Format de fichiers</a></li>
<li><a href="#requêtes-fixes-et-prolifération-de-programmes"><span class="toc-section-number">1.1.1.5</span> Requêtes fixes et prolifération de programmes</a></li>
<li><a href="#résumé"><span class="toc-section-number">1.1.1.6</span> Résumé</a></li>
</ul></li>
</ul></li>
<li><a href="#lapproche-par-base-de-données"><span class="toc-section-number">1.2</span> L’approche par base de données</a><ul>
<li><a href="#les-bases-de-données"><span class="toc-section-number">1.2.1</span> Les bases de données</a><ul>
<li><a href="#définition"><span class="toc-section-number">1.2.1.1</span> Définition</a></li>
<li><a href="#avantages"><span class="toc-section-number">1.2.1.2</span> Avantages</a></li>
</ul></li>
<li><a href="#les-systèmes-de-gestion-de-bases-de-données-dbms-ou-sgbd"><span class="toc-section-number">1.2.2</span> Les systèmes de gestion de bases de données (DBMS ou SGBD)</a><ul>
<li><a href="#définition-1"><span class="toc-section-number">1.2.2.1</span> Définition</a></li>
<li><a href="#fonctionnalités-fournies"><span class="toc-section-number">1.2.2.2</span> Fonctionnalités fournies</a></li>
<li><a href="#avantages-1"><span class="toc-section-number">1.2.2.3</span> Avantages</a><ul>
<li><a href="#contrôle-de-la-redondance-des-données"><span class="toc-section-number">1.2.2.3.1</span> Contrôle de la redondance des données</a></li>
<li><a href="#cohérence-des-données"><span class="toc-section-number">1.2.2.3.2</span> Cohérence des données</a></li>
<li><a href="#plus-dinformations-avec-le-même-nombre-de-données"><span class="toc-section-number">1.2.2.3.3</span> Plus d’informations avec le même nombre de données</a></li>
<li><a href="#partage-des-données"><span class="toc-section-number">1.2.2.3.4</span> Partage des données</a></li>
<li><a href="#meilleure-intégrité-des-données"><span class="toc-section-number">1.2.2.3.5</span> Meilleure intégrité des données</a></li>
<li><a href="#sécurité-accrue"><span class="toc-section-number">1.2.2.3.6</span> Sécurité accrue</a></li>
<li><a href="#application-des-standards"><span class="toc-section-number">1.2.2.3.7</span> Application des standards</a></li>
<li><a href="#économies-de-taille"><span class="toc-section-number">1.2.2.3.8</span> Économies de taille</a></li>
<li><a href="#balance-de-besoins-contradictoires"><span class="toc-section-number">1.2.2.3.9</span> Balance de besoins contradictoires</a></li>
<li><a href="#amélioration-de-laccessibilité-et-de-la-réactivité-des-données"><span class="toc-section-number">1.2.2.3.10</span> Amélioration de l’accessibilité et de la réactivité des données</a></li>
<li><a href="#productivité-accrue"><span class="toc-section-number">1.2.2.3.11</span> Productivité accrue</a></li>
<li><a href="#maintenance-améliorée-grâce-à-lindépendence-des-données"><span class="toc-section-number">1.2.2.3.12</span> Maintenance améliorée grâce à l’indépendence des données</a></li>
<li><a href="#amélioration-de-laccès-simultané"><span class="toc-section-number">1.2.2.3.13</span> Amélioration de l’accès simultané</a></li>
<li><a href="#meilleurs-services-de-restauration-et-de-sauvegarde-des-données"><span class="toc-section-number">1.2.2.3.14</span> Meilleurs services de restauration et de sauvegarde des données</a></li>
</ul></li>
<li><a href="#désavantages"><span class="toc-section-number">1.2.2.4</span> Désavantages</a><ul>
<li><a href="#complexité"><span class="toc-section-number">1.2.2.4.1</span> Complexité</a></li>
<li><a href="#taille"><span class="toc-section-number">1.2.2.4.2</span> Taille</a></li>
<li><a href="#coût-des-systèmes-de-gestion-de-bases-de-données"><span class="toc-section-number">1.2.2.4.3</span> Coût des systèmes de gestion de bases de données</a></li>
<li><a href="#coûts-additionnels-de-matériel"><span class="toc-section-number">1.2.2.4.4</span> Coûts additionnels de matériel</a></li>
<li><a href="#coût-de-conversion"><span class="toc-section-number">1.2.2.4.5</span> Coût de conversion</a></li>
<li><a href="#performance"><span class="toc-section-number">1.2.2.4.6</span> Performance</a></li>
<li><a href="#plus-gros-impact-en-cas-de-défaillance."><span class="toc-section-number">1.2.2.4.7</span> Plus gros impact en cas de défaillance.</a></li>
</ul></li>
<li><a href="#mécanisme-de-vision"><span class="toc-section-number">1.2.2.5</span> Mécanisme de vision</a><ul>
<li><a href="#bénéfices"><span class="toc-section-number">1.2.2.5.1</span> Bénéfices</a></li>
</ul></li>
<li><a href="#composants-dun-système-de-gestion-de-bases-de-données"><span class="toc-section-number">1.2.2.6</span> Composants d’un système de gestion de bases de données</a><ul>
<li><a href="#matériel"><span class="toc-section-number">1.2.2.6.1</span> Matériel</a></li>
<li><a href="#logiciel"><span class="toc-section-number">1.2.2.6.2</span> Logiciel</a></li>
<li><a href="#données"><span class="toc-section-number">1.2.2.6.3</span> Données</a></li>
<li><a href="#procédures"><span class="toc-section-number">1.2.2.6.4</span> Procédures</a></li>
<li><a href="#humains"><span class="toc-section-number">1.2.2.6.5</span> Humains</a></li>
</ul></li>
<li><a href="#conception-de-bases-de-données"><span class="toc-section-number">1.2.2.7</span> Conception de bases de données</a></li>
<li><a href="#rôles-dans-un-environnement-de-bases-de-données"><span class="toc-section-number">1.2.2.8</span> Rôles dans un environnement de bases de données</a><ul>
<li><a href="#administrateurs-des-données-et-de-la-base-de-données"><span class="toc-section-number">1.2.2.8.1</span> Administrateurs des données et de la base de données</a></li>
<li><a href="#concepteurs-de-bases-de-données"><span class="toc-section-number">1.2.2.8.2</span> Concepteurs de bases de données</a></li>
<li><a href="#développeurs-dapplication"><span class="toc-section-number">1.2.2.8.3</span> Développeurs d’application</a></li>
<li><a href="#utilisateurs"><span class="toc-section-number">1.2.2.8.4</span> Utilisateurs</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#modèle-relationnel"><span class="toc-section-number">2</span> Modèle relationnel</a><ul>
<li><a href="#structure-des-données-relationnelles"><span class="toc-section-number">2.1</span> Structure des données relationnelles</a></li>
<li><a href="#relations-mathématiques"><span class="toc-section-number">2.2</span> Relations mathématiques</a></li>
<li><a href="#relations-des-bases-de-données"><span class="toc-section-number">2.3</span> Relations des bases de données</a></li>
<li><a href="#propriétés-des-relations"><span class="toc-section-number">2.4</span> Propriétés des relations</a></li>
<li><a href="#clés-relationnelles"><span class="toc-section-number">2.5</span> Clés relationnelles</a><ul>
<li><a href="#superclé"><span class="toc-section-number">2.5.1</span> Superclé</a></li>
<li><a href="#clé-candidate"><span class="toc-section-number">2.5.2</span> Clé candidate</a></li>
<li><a href="#clé-composée"><span class="toc-section-number">2.5.3</span> Clé composée</a></li>
<li><a href="#clé-primaire"><span class="toc-section-number">2.5.4</span> Clé primaire</a></li>
<li><a href="#clé-alternative"><span class="toc-section-number">2.5.5</span> Clé alternative</a></li>
<li><a href="#clé-étrangère"><span class="toc-section-number">2.5.6</span> Clé étrangère</a></li>
</ul></li>
<li><a href="#contraintes-dintégrité"><span class="toc-section-number">2.6</span> Contraintes d’intégrité</a><ul>
<li><a href="#null"><span class="toc-section-number">2.6.1</span> Null</a></li>
<li><a href="#intégrité-dentité"><span class="toc-section-number">2.6.2</span> Intégrité d’entité</a></li>
<li><a href="#intégrité-référentielle"><span class="toc-section-number">2.6.3</span> Intégrité référentielle</a></li>
<li><a href="#contraintes-générales"><span class="toc-section-number">2.6.4</span> Contraintes générales</a></li>
</ul></li>
<li><a href="#vues"><span class="toc-section-number">2.7</span> Vues</a><ul>
<li><a href="#définition-2"><span class="toc-section-number">2.7.1</span> Définition</a></li>
<li><a href="#utilités"><span class="toc-section-number">2.7.2</span> Utilités</a></li>
<li><a href="#mise-à-jour-des-vues"><span class="toc-section-number">2.7.3</span> Mise à jour des vues</a></li>
</ul></li>
</ul></li>
<li><a href="#normalisation"><span class="toc-section-number">3</span> Normalisation</a><ul>
<li><a href="#redondance-de-données-et-anomalies-de-mises-à-jour"><span class="toc-section-number">3.1</span> Redondance de données et anomalies de mises à jour</a><ul>
<li><a href="#anomalies-dinsertion"><span class="toc-section-number">3.1.1</span> Anomalies d’insertion</a></li>
<li><a href="#anomalies-de-suppression"><span class="toc-section-number">3.1.2</span> Anomalies de suppression</a></li>
<li><a href="#anomalies-de-modification"><span class="toc-section-number">3.1.3</span> Anomalies de modification</a></li>
</ul></li>
<li><a href="#dépendances-fonctionnelles"><span class="toc-section-number">3.2</span> Dépendances fonctionnelles</a><ul>
<li><a href="#définition-3"><span class="toc-section-number">3.2.1</span> Définition</a></li>
<li><a href="#déterminant"><span class="toc-section-number">3.2.2</span> Déterminant</a></li>
<li><a href="#dépendance-fonctionnelle-complète"><span class="toc-section-number">3.2.3</span> Dépendance fonctionnelle complète</a></li>
<li><a href="#dépendance-fonctionnelle-partielle"><span class="toc-section-number">3.2.4</span> Dépendance fonctionnelle partielle</a></li>
<li><a href="#dépendance-transitive"><span class="toc-section-number">3.2.5</span> Dépendance transitive</a></li>
<li><a href="#résumé-1"><span class="toc-section-number">3.2.6</span> Résumé</a></li>
</ul></li>
<li><a href="#normalisation-et-formes-normales"><span class="toc-section-number">3.3</span> Normalisation et formes normales</a><ul>
<li><a href="#définition-de-la-normalisation"><span class="toc-section-number">3.3.1</span> Définition de la normalisation</a></li>
<li><a href="#forme-non-normalisée-unf-à-première-forme-normale"><span class="toc-section-number">3.3.2</span> Forme non normalisée (UNF) à première forme normale</a><ul>
<li><a href="#définition-de-la-forme-non-normalisée-unf"><span class="toc-section-number">3.3.2.1</span> Définition de la forme non normalisée (UNF)</a></li>
<li><a href="#définition-de-la-première-forme-normale-1nf"><span class="toc-section-number">3.3.2.2</span> Définition de la première forme normale (1NF)</a></li>
<li><a href="#technique-de-normalisation"><span class="toc-section-number">3.3.2.3</span> Technique de normalisation</a><ul>
<li><a href="#mise-à-plat"><span class="toc-section-number">3.3.2.3.1</span> Mise à plat</a></li>
<li><a href="#séparer-les-données-dupliquées"><span class="toc-section-number">3.3.2.3.2</span> Séparer les données dupliquées</a></li>
</ul></li>
</ul></li>
<li><a href="#première-forme-normale-à-la-deuxième-forme-normale"><span class="toc-section-number">3.3.3</span> Première forme normale à la deuxième forme normale</a><ul>
<li><a href="#définition-de-la-deuxième-forme-normale-2nf"><span class="toc-section-number">3.3.3.1</span> Définition de la deuxième forme normale (2NF)</a></li>
<li><a href="#technique-de-normalisation-1"><span class="toc-section-number">3.3.3.2</span> Technique de normalisation</a></li>
</ul></li>
<li><a href="#deuxième-forme-normale-à-la-troisième-forme-normale"><span class="toc-section-number">3.3.4</span> Deuxième forme normale à la troisième forme normale</a><ul>
<li><a href="#définition-de-la-troisième-forme-normale-3nf"><span class="toc-section-number">3.3.4.1</span> Définition de la troisième forme normale (3NF)</a></li>
<li><a href="#technique-de-normalisation-2"><span class="toc-section-number">3.3.4.2</span> Technique de normalisation</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#normalisation-avancée"><span class="toc-section-number">4</span> Normalisation avancée</a><ul>
<li><a href="#règles-dinférence-des-dépendances-fonctionnelles"><span class="toc-section-number">4.1</span> Règles d’inférence des dépendances fonctionnelles</a><ul>
<li><a href="#axiomes-darmstrong"><span class="toc-section-number">4.1.1</span> Axiomes d’Armstrong</a></li>
<li><a href="#ensembles-minimaux-de-dépendances-fonctionnelles"><span class="toc-section-number">4.1.2</span> Ensembles minimaux de dépendances fonctionnelles</a></li>
</ul></li>
<li><a href="#forme-normale-de-boyce-codd-bcnf"><span class="toc-section-number">4.2</span> Forme normale de Boyce-Codd (BCNF)</a><ul>
<li><a href="#définition-4"><span class="toc-section-number">4.2.1</span> Définition</a></li>
<li><a href="#technique-de-normalisation-3"><span class="toc-section-number">4.2.2</span> Technique de normalisation</a></li>
</ul></li>
<li><a href="#dépendance-multi-valuée"><span class="toc-section-number">4.3</span> Dépendance multi-valuée</a><ul>
<li><a href="#définition-5"><span class="toc-section-number">4.3.1</span> Définition</a></li>
<li><a href="#types-de-dépendances-multi-valuées"><span class="toc-section-number">4.3.2</span> Types de dépendances multi-valuées</a></li>
</ul></li>
<li><a href="#quatrième-forme-normale"><span class="toc-section-number">4.4</span> Quatrième forme normale</a><ul>
<li><a href="#définition-6"><span class="toc-section-number">4.4.1</span> Définition</a></li>
<li><a href="#technique-de-normalisation-4"><span class="toc-section-number">4.4.2</span> Technique de normalisation</a></li>
</ul></li>
</ul></li>
<li><a href="#algèbre-relationnelle"><span class="toc-section-number">5</span> Algèbre relationnelle</a><ul>
<li><a href="#définition-7"><span class="toc-section-number">5.1</span> Définition</a></li>
<li><a href="#opérations"><span class="toc-section-number">5.2</span> Opérations</a><ul>
<li><a href="#opérations-unaires"><span class="toc-section-number">5.2.1</span> Opérations unaires</a><ul>
<li><a href="#sélection-ou-restriction"><span class="toc-section-number">5.2.1.1</span> Sélection (ou restriction)</a></li>
<li><a href="#projection"><span class="toc-section-number">5.2.1.2</span> Projection</a></li>
</ul></li>
<li><a href="#opérations-binaires"><span class="toc-section-number">5.2.2</span> Opérations binaires</a><ul>
<li><a href="#union"><span class="toc-section-number">5.2.2.1</span> Union</a></li>
<li><a href="#différence"><span class="toc-section-number">5.2.2.2</span> Différence</a></li>
<li><a href="#intersection"><span class="toc-section-number">5.2.2.3</span> Intersection</a></li>
<li><a href="#produit-cartésien"><span class="toc-section-number">5.2.2.4</span> Produit cartésien</a></li>
<li><a href="#décomposition-dopérations-complexes"><span class="toc-section-number">5.2.2.5</span> Décomposition d’opérations complexes</a></li>
</ul></li>
<li><a href="#opérations-de-jointure"><span class="toc-section-number">5.2.3</span> Opérations de jointure</a><ul>
<li><a href="#jointure-theta-theta-join"><span class="toc-section-number">5.2.3.1</span> Jointure theta (<span class="math">\(\theta\)</span>-join)</a></li>
<li><a href="#equijointure"><span class="toc-section-number">5.2.3.2</span> Equijointure</a><ul>
<li><a href="#exemple-dequijointure"><span class="toc-section-number">5.2.3.2.1</span> Exemple d’equijointure</a></li>
</ul></li>
<li><a href="#jointure-naturelle"><span class="toc-section-number">5.2.3.3</span> Jointure naturelle</a><ul>
<li><a href="#exemple-de-jointure-naturelle"><span class="toc-section-number">5.2.3.3.1</span> Exemple de jointure naturelle</a></li>
</ul></li>
<li><a href="#jointure-externe"><span class="toc-section-number">5.2.3.4</span> Jointure externe</a><ul>
<li><a href="#exemple-de-jointure-externe"><span class="toc-section-number">5.2.3.4.1</span> Exemple de jointure externe</a></li>
</ul></li>
<li><a href="#semi-jointure"><span class="toc-section-number">5.2.3.5</span> Semi-jointure</a><ul>
<li><a href="#exemple-de-semi-jointure"><span class="toc-section-number">5.2.3.5.1</span> Exemple de semi-jointure</a></li>
</ul></li>
</ul></li>
<li><a href="#division"><span class="toc-section-number">5.2.4</span> Division</a><ul>
<li><a href="#exemple-de-division"><span class="toc-section-number">5.2.4.1</span> Exemple de division</a></li>
</ul></li>
<li><a href="#agrégation"><span class="toc-section-number">5.2.5</span> Agrégation</a><ul>
<li><a href="#exemple-dagrégation"><span class="toc-section-number">5.2.5.1</span> Exemple d’agrégation</a></li>
</ul></li>
<li><a href="#regroupement"><span class="toc-section-number">5.2.6</span> Regroupement</a><ul>
<li><a href="#exemple-de-regroupement"><span class="toc-section-number">5.2.6.1</span> Exemple de regroupement</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#structured-query-language-sql-manipulation-des-données"><span class="toc-section-number">6</span> Structured Query Language (SQL) : Manipulation des données</a><ul>
<li><a href="#objectifs-du-sql"><span class="toc-section-number">6.1</span> Objectifs du SQL</a></li>
<li><a href="#informations-sur-le-sql"><span class="toc-section-number">6.2</span> Informations sur le SQL</a><ul>
<li><a href="#terminalogie"><span class="toc-section-number">6.2.1</span> Terminalogie</a></li>
</ul></li>
<li><a href="#écrire-des-commandes-sql"><span class="toc-section-number">6.3</span> Écrire des commandes SQL</a><ul>
<li><a href="#convention-de-code"><span class="toc-section-number">6.3.1</span> Convention de code</a></li>
<li><a href="#manipulation-des-données"><span class="toc-section-number">6.3.2</span> Manipulation des données</a></li>
<li><a href="#litéraux"><span class="toc-section-number">6.3.3</span> Litéraux</a></li>
<li><a href="#select"><span class="toc-section-number">6.3.4</span> SELECT</a><ul>
<li><a href="#exemples-dutilisation-du-select"><span class="toc-section-number">6.3.4.1</span> Exemples d’utilisation du SELECT</a><ul>
<li><a href="#aller-chercher-toutes-les-colonnes-et-rangées"><span class="toc-section-number">6.3.4.1.1</span> Aller chercher toutes les colonnes et rangées</a></li>
<li><a href="#aller-chercher-des-colonnes-spécifiques-et-toutes-les-rangées"><span class="toc-section-number">6.3.4.1.2</span> Aller chercher des colonnes spécifiques et toutes les rangées</a></li>
<li><a href="#utiliser-distinct"><span class="toc-section-number">6.3.4.1.3</span> Utiliser DISTINCT</a></li>
<li><a href="#champs-calculés"><span class="toc-section-number">6.3.4.1.4</span> Champs calculés</a></li>
</ul></li>
<li><a href="#sélection-de-rangées-where"><span class="toc-section-number">6.3.4.2</span> Sélection de rangées (WHERE)</a><ul>
<li><a href="#exemples-dutilisation-du-where"><span class="toc-section-number">6.3.4.2.1</span> Exemples d’utilisation du WHERE</a><ul>
<li><a href="#prédicat-de-comparaison"><span class="toc-section-number">6.3.4.2.1.1</span> Prédicat de comparaison</a></li>
<li><a href="#prédicat-de-comparaison-composé"><span class="toc-section-number">6.3.4.2.1.2</span> Prédicat de comparaison composé</a></li>
<li><a href="#prédicat-de-recherche-décart-betweennot-between"><span class="toc-section-number">6.3.4.2.1.3</span> Prédicat de recherche d’écart (BETWEEN/NOT BETWEEN)</a></li>
<li><a href="#prédicat-dappartenance-à-un-ensemble-innot-in"><span class="toc-section-number">6.3.4.2.1.4</span> Prédicat d’appartenance à un ensemble (IN/NOT IN)</a></li>
<li><a href="#prédicat-de-correspondance-à-un-masque-likenot-like"><span class="toc-section-number">6.3.4.2.1.5</span> Prédicat de correspondance à un masque (LIKE/NOT LIKE)</a></li>
<li><a href="#prédicat-de-recherche-de-null-is-nullis-not-null"><span class="toc-section-number">6.3.4.2.1.6</span> Prédicat de recherche de NULL (IS NULL/IS NOT NULL)</a></li>
</ul></li>
</ul></li>
<li><a href="#trier-les-résultats-order-by"><span class="toc-section-number">6.3.4.3</span> Trier les résultats (ORDER BY)</a><ul>
<li><a href="#exemples-dutilisation-du-order-by"><span class="toc-section-number">6.3.4.3.1</span> Exemples d’utilisation du ORDER BY</a><ul>
<li><a href="#tri-avec-une-seule-colonne"><span class="toc-section-number">6.3.4.3.1.1</span> Tri avec une seule colonne</a></li>
<li><a href="#tri-avec-plusieurs-colonnes"><span class="toc-section-number">6.3.4.3.1.2</span> Tri avec plusieurs colonnes</a></li>
</ul></li>
</ul></li>
<li><a href="#fonctions-sql-dagrégation"><span class="toc-section-number">6.3.4.4</span> Fonctions SQL d’agrégation</a><ul>
<li><a href="#exemples-dutilisation-des-fonctions-sql-dagrégation"><span class="toc-section-number">6.3.4.4.1</span> Exemples d’utilisation des fonctions SQL d’agrégation</a><ul>
<li><a href="#utilisation-de-count"><span class="toc-section-number">6.3.4.4.1.1</span> Utilisation de <code>COUNT(*)</code></a></li>
<li><a href="#utilisation-de-countdistinct"><span class="toc-section-number">6.3.4.4.1.2</span> Utilisation de <code>COUNT(DISTINCT)</code></a></li>
<li><a href="#utilisation-de-count-et-sum"><span class="toc-section-number">6.3.4.4.1.3</span> Utilisation de <code>COUNT</code> et <code>SUM</code></a></li>
<li><a href="#utilisation-de-min-max-et-avg"><span class="toc-section-number">6.3.4.4.1.4</span> Utilisation de <code>MIN</code>, <code>MAX</code> et <code>AVG</code></a></li>
</ul></li>
</ul></li>
<li><a href="#grouper-les-résultats-group-by"><span class="toc-section-number">6.3.4.5</span> Grouper les résultats (<code>GROUP BY</code>)</a><ul>
<li><a href="#exemple-dutilisation-de-group-by"><span class="toc-section-number">6.3.4.5.1</span> Exemple d’utilisation de <code>GROUP BY</code></a></li>
</ul></li>
<li><a href="#restreindre-les-groupements-having"><span class="toc-section-number">6.3.4.6</span> Restreindre les groupements (<code>HAVING</code>)</a><ul>
<li><a href="#exemple-dutilisation-de-having"><span class="toc-section-number">6.3.4.6.1</span> Exemple d’utilisation de <code>HAVING</code></a></li>
</ul></li>
<li><a href="#sous-requêtes"><span class="toc-section-number">6.3.4.7</span> Sous-requêtes</a><ul>
<li><a href="#mots-clés-any-et-all"><span class="toc-section-number">6.3.4.7.1</span> Mots clés <code>ANY</code> et <code>ALL</code></a></li>
<li><a href="#exemple-dutilisation-de-sous-requêtes"><span class="toc-section-number">6.3.4.7.2</span> Exemple d’utilisation de sous-requêtes</a><ul>
<li><a href="#sous-requête-avec-lopérateur-dégalité"><span class="toc-section-number">6.3.4.7.2.1</span> Sous-requête avec l’opérateur d’égalité</a></li>
<li><a href="#sous-requête-avec-une-fonction-dagrégation"><span class="toc-section-number">6.3.4.7.2.2</span> Sous-requête avec une fonction d’agrégation</a></li>
<li><a href="#utilisation-de-in"><span class="toc-section-number">6.3.4.7.2.3</span> Utilisation de <code>IN</code></a></li>
<li><a href="#utilisation-de-anysome"><span class="toc-section-number">6.3.4.7.2.4</span> Utilisation de <code>ANY</code>/<code>SOME</code></a></li>
<li><a href="#utilisation-de-all"><span class="toc-section-number">6.3.4.7.2.5</span> Utilisation de <code>ALL</code></a></li>
</ul></li>
</ul></li>
<li><a href="#requêtes-multi-tables"><span class="toc-section-number">6.3.4.8</span> Requêtes multi-tables</a><ul>
<li><a href="#calculer-une-jointure"><span class="toc-section-number">6.3.4.8.1</span> Calculer une jointure</a></li>
<li><a href="#jointures-externes"><span class="toc-section-number">6.3.4.8.2</span> Jointures externes</a></li>
<li><a href="#mots-clés-exists-et-not-exists"><span class="toc-section-number">6.3.4.8.3</span> Mots clés <code>EXISTS</code> et <code>NOT EXISTS</code></a></li>
<li><a href="#combiner-les-tables-résultantes-union-intersect-except"><span class="toc-section-number">6.3.4.8.4</span> Combiner les tables résultantes (<code>UNION</code>, <code>INTERSECT</code>, <code>EXCEPT</code>)</a></li>
<li><a href="#exemples-dopérations-de-jointure"><span class="toc-section-number">6.3.4.8.5</span> Exemples d’opérations de jointure</a><ul>
<li><a href="#opération-de-jointure-simple"><span class="toc-section-number">6.3.4.8.5.1</span> Opération de jointure simple</a></li>
<li><a href="#trier-une-opération-de-jointure"><span class="toc-section-number">6.3.4.8.5.2</span> Trier une opération de jointure</a></li>
<li><a href="#opération-de-jointure-sur-trois-tables"><span class="toc-section-number">6.3.4.8.5.3</span> Opération de jointure sur trois tables</a></li>
<li><a href="#multiples-groupements-de-colonnes"><span class="toc-section-number">6.3.4.8.5.4</span> Multiples groupements de colonnes</a></li>
<li><a href="#jointure-externe-gauche"><span class="toc-section-number">6.3.4.8.5.5</span> Jointure externe gauche</a></li>
<li><a href="#jointure-externe-droite"><span class="toc-section-number">6.3.4.8.5.6</span> Jointure externe droite</a></li>
<li><a href="#jointure-externe-complète"><span class="toc-section-number">6.3.4.8.5.7</span> Jointure externe complète</a></li>
<li><a href="#requête-utilisant-exists"><span class="toc-section-number">6.3.4.8.5.8</span> Requête utilisant <code>EXISTS</code></a></li>
<li><a href="#utiliser-union"><span class="toc-section-number">6.3.4.8.5.9</span> Utiliser <code>UNION</code></a></li>
<li><a href="#utiliser-intersect"><span class="toc-section-number">6.3.4.8.5.10</span> Utiliser <code>INTERSECT</code></a></li>
<li><a href="#utiliser-except"><span class="toc-section-number">6.3.4.8.5.11</span> Utiliser <code>EXCEPT</code></a></li>
</ul></li>
</ul></li>
<li><a href="#mises-à-jour-de-la-base-de-données"><span class="toc-section-number">6.3.4.9</span> Mises à jour de la base de données</a><ul>
<li><a href="#insérer-des-données-dans-une-base-de-données-insert"><span class="toc-section-number">6.3.4.9.1</span> Insérer des données dans une base de données (<code>INSERT</code>)</a><ul>
<li><a href="#exemple-de-insert-...-values"><span class="toc-section-number">6.3.4.9.1.1</span> Exemple de <code>INSERT ... VALUES</code></a></li>
<li><a href="#exemple-de-insert-en-utilisant-des-valeurs-par-défaut"><span class="toc-section-number">6.3.4.9.1.2</span> Exemple de <code>INSERT</code> en utilisant des valeurs par défaut</a></li>
<li><a href="#exemple-de-insert-...-select"><span class="toc-section-number">6.3.4.9.1.3</span> Exemple de <code>INSERT ... SELECT</code></a></li>
</ul></li>
<li><a href="#modifier-les-données-dans-la-base-de-données-update"><span class="toc-section-number">6.3.4.9.2</span> Modifier les données dans la base de données (<code>UPDATE</code>)</a><ul>
<li><a href="#mise-à-jour-de-toutes-les-rangées"><span class="toc-section-number">6.3.4.9.2.1</span> Mise à jour de toutes les rangées</a></li>
<li><a href="#mettre-à-jour-des-rangées-spécifiques"><span class="toc-section-number">6.3.4.9.2.2</span> Mettre à jour des rangées spécifiques</a></li>
<li><a href="#mettre-à-jour-plusieurs-colonnes"><span class="toc-section-number">6.3.4.9.2.3</span> Mettre à jour plusieurs colonnes</a></li>
</ul></li>
<li><a href="#effacer-des-données-de-la-base-de-données-delete"><span class="toc-section-number">6.3.4.9.3</span> Effacer des données de la base de données (<code>DELETE</code>)</a><ul>
<li><a href="#effacer-des-rangées-spécifiques"><span class="toc-section-number">6.3.4.9.3.1</span> Effacer des rangées spécifiques</a></li>
<li><a href="#effacer-toutes-les-rangées"><span class="toc-section-number">6.3.4.9.3.2</span> Effacer toutes les rangées</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#sql-avancé"><span class="toc-section-number">7</span> SQL avancé</a><ul>
<li><a href="#déclaration"><span class="toc-section-number">7.1</span> Déclaration</a><ul>
<li><a href="#les-annotations-type-et-rowtype"><span class="toc-section-number">7.1.1</span> Les annotations <code>%TYPE</code> et <code>%ROWTYPE</code></a></li>
<li><a href="#exemples"><span class="toc-section-number">7.1.2</span> Exemples</a><ul>
<li><a href="#exemple-de-déclarations-normales"><span class="toc-section-number">7.1.2.1</span> Exemple de déclarations normales</a></li>
<li><a href="#exemple-dutilisations-de-lannotation-type"><span class="toc-section-number">7.1.2.2</span> Exemple d’utilisations de l’annotation <code>%TYPE</code></a></li>
<li><a href="#exemple-dutilisations-de-lannotation-rowtype"><span class="toc-section-number">7.1.2.3</span> Exemple d’utilisations de l’annotation <code>%ROWTYPE</code></a></li>
</ul></li>
</ul></li>
<li><a href="#assignation"><span class="toc-section-number">7.2</span> Assignation</a><ul>
<li><a href="#exemples-1"><span class="toc-section-number">7.2.1</span> Exemples</a><ul>
<li><a href="#exemple-dassignation-avec-un-select"><span class="toc-section-number">7.2.1.1</span> Exemple d’assignation avec un <code>SELECT</code></a></li>
<li><a href="#exemple-dassignations-avec-lopérateur"><span class="toc-section-number">7.2.1.2</span> Exemple d’assignations avec l’opérateur <code>:=</code></a></li>
</ul></li>
</ul></li>
<li><a href="#clauses-de-contrôle"><span class="toc-section-number">7.3</span> Clauses de contrôle</a><ul>
<li><a href="#lénoncé-conditionnel-if"><span class="toc-section-number">7.3.1</span> L’énoncé conditionnel <code>IF</code></a><ul>
<li><a href="#exemple-dutilisation-du-if"><span class="toc-section-number">7.3.1.1</span> Exemple d’utilisation du <code>IF</code></a></li>
</ul></li>
<li><a href="#lénoncé-conditionnel-case"><span class="toc-section-number">7.3.2</span> L’énoncé conditionnel <code>CASE</code></a><ul>
<li><a href="#exemple-dutilisation-du-case"><span class="toc-section-number">7.3.2.1</span> Exemple d’utilisation du <code>CASE</code></a></li>
</ul></li>
<li><a href="#énoncés-itératifs"><span class="toc-section-number">7.3.3</span> Énoncés itératifs</a><ul>
<li><a href="#énoncé-loop"><span class="toc-section-number">7.3.3.1</span> Énoncé <code>LOOP</code></a><ul>
<li><a href="#exemple"><span class="toc-section-number">7.3.3.1.1</span> Exemple</a></li>
</ul></li>
<li><a href="#énoncé-while-et-repeat"><span class="toc-section-number">7.3.3.2</span> Énoncé <code>WHILE</code> et <code>REPEAT</code></a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#annexe"><span class="toc-section-number">8</span> Annexe</a></li>
</ul>
</nav>
<p>Ce document regroupe l’ensemble de mes notes pour le cours <strong>Modèles et langages de bases de données</strong>.</p>
<section id="introduction" class="level1">
<h1><a href="#introduction"><span class="header-section-number">1</span> Introduction</a></h1>
<p>Ce chapitre est une introduction aux bases de données et aux système de gestion de bases de données. Il expliquera leur raison d’exister, les fonctions typiques, les composants majeurs, etc.</p>
<section id="lancêtre-des-bases-de-données" class="level2">
<h2><a href="#lancêtre-des-bases-de-données"><span class="header-section-number">1.1</span> L’ancêtre des bases de données</a></h2>
<p>Le prédécesseur des bases de données est l’approche par fichiers. Cette approche utilisait un système décentralisé où chaque système avait ses propres données.</p>
<section id="problèmes" class="level3">
<h3><a href="#problèmes"><span class="header-section-number">1.1.1</span> Problèmes</a></h3>
<p>L’approche par fichiers comprend cinq problèmes majeurs.</p>
<section id="séparation-et-isolation-des-données" class="level4">
<h4><a href="#séparation-et-isolation-des-données"><span class="header-section-number">1.1.1.1</span> Séparation et isolation des données</a></h4>
<p>Dans une approche par fichiers, les données sont séparées et isolées. Cela fait en sorte qu’il est plus difficile d’accéder aux données. Lorsqu’on veut accéder à des données, on doit synchroniser notre traitement des fichiers pour s’assurer que les bonnes données sont extraites.</p>
</section>
<section id="duplication-des-données" class="level4">
<h4><a href="#duplication-des-données"><span class="header-section-number">1.1.1.2</span> Duplication des données</a></h4>
<p>Un autre problème de cette approche est la duplication des données. Chaque département a sa propre version des données. Cela fait en sorte que les départements vont avoir des données identiques entre eux dans certains cas. C’est donc du gaspillage de temps et d’argent, car les données être entrées plusieurs fois par des personnes différentes. De plus, ça veut également dire qu’il y a plus d’espace de stockage qui est pris. Finalement, il y a plus de risques d’avoir des informations incorrectes, car il peut y arriver que la synchronisation entre les différents fichiers des départements ne s’est pas bien faite.</p>
</section>
<section id="dépendences-des-données" class="level4">
<h4><a href="#dépendences-des-données"><span class="header-section-number">1.1.1.3</span> Dépendences des données</a></h4>
<p>Les programmes dépendent d’un format de fichier particulier. Si le format change, toutes les applications connectées à ce fichier doivent changer aussi. Le format des données est donc assez rigide, car il n’y a pas d’abstraction quant à la disposition de celles-ci. De plus, changer une adresse de données va nécessiter la création d’un programme pour pouvoir changer tous les champs de manière à ce qu’ils soient conformes à la nouvelle structure.</p>
</section>
<section id="format-de-fichiers" class="level4">
<h4><a href="#format-de-fichiers"><span class="header-section-number">1.1.1.4</span> Format de fichiers</a></h4>
<p>Comme la structure des fichiers est dépendant du langage de programmation, il est plus difficile d’utiliser différents langages pour les différentes applications. En effet, un fichier généré dans un langage va être différent du même fichier généré à partir d’un autre langage.</p>
</section>
<section id="requêtes-fixes-et-prolifération-de-programmes" class="level4">
<h4><a href="#requêtes-fixes-et-prolifération-de-programmes"><span class="header-section-number">1.1.1.5</span> Requêtes fixes et prolifération de programmes</a></h4>
<p>Les besoins de nouvelles requêtes peuvent changer à tous moments. Étant donné que les requêtes sont écrites par les développeurs d’application, il était très difficile d’ajouter des nouvelles requêtes rapidement. Il n’y avait aucun moyen de créer des requêtes non planifiées pour aller voir les types de données disponibles. Le fait que ce soit les développeurs d’application qui devaient écrire toutes les requêtes faisait en sorte que leur charge de travail était énorme et, donc, dans certain cas, ils étaient obligés de couper dans certaines fonctionnalités. Par exemple, les fonctionnalités suivantes étaient souvent omises:</p>
<ul>
<li>Aucune mesure de sécurité ou de vérification de l’intégrité des données</li>
<li>La récupération des données dans le cas d’un disfonctionnement logiciel ou matériel était limité ou inexistant</li>
<li>Accès aux fichier était restreint à un utilisateur à la fois</li>
</ul>
</section>
<section id="résumé" class="level4">
<h4><a href="#résumé"><span class="header-section-number">1.1.1.6</span> Résumé</a></h4>
<p>Tous les facteurs limitants de l’approche par fichiers peuvent être attribués à deux facteurs:</p>
<ul>
<li>La définition des données est incrustée dans les applications au lieu d’être enregistré séparemment et indépendemment</li>
<li>Il n’y a aucun contrôle sur les accès et manipulations des données hormis celui imposé par les programmes</li>
</ul>
</section>
</section>
</section>
<section id="lapproche-par-base-de-données" class="level2">
<h2><a href="#lapproche-par-base-de-données"><span class="header-section-number">1.2</span> L’approche par base de données</a></h2>
<p>L’approche par fichiers ne répondant pas aux besoins des entreprises, une nouvelle solution fut inventée: l’approche par base de données.</p>
<section id="les-bases-de-données" class="level3">
<h3><a href="#les-bases-de-données"><span class="header-section-number">1.2.1</span> Les bases de données</a></h3>
<section id="définition" class="level4">
<h4><a href="#définition"><span class="header-section-number">1.2.1.1</span> Définition</a></h4>
<p>Une <strong>base de données</strong> est une collection de données liées logiquement et sa description, conçu dans le but de répondre aux besoins d’information d’une organisation.</p>
</section>
<section id="avantages" class="level4">
<h4><a href="#avantages"><span class="header-section-number">1.2.1.2</span> Avantages</a></h4>
<p>Les bases de données ont plusieurs avantages par rapport à l’approche par fichiers. Par exemple:</p>
<ul>
<li>Une base de données a le minimum de duplication possible.</li>
<li>Au lieu d’être liée à un seul département, elle est partagée à toute l’organisation complète.</li>
<li>Elle peut être accédée par plusieurs utilisateurs en même temps.</li>
<li>En plus de contenir les données, elle contient aussi une description de ces données.</li>
<li>La définition des données est cachée aux utilisateurs qui ne voient que leurs définitions externes ce qui permet de protéger les programmes des modifications à la base de données.</li>
</ul>
</section>
</section>
<section id="les-systèmes-de-gestion-de-bases-de-données-dbms-ou-sgbd" class="level3">
<h3><a href="#les-systèmes-de-gestion-de-bases-de-données-dbms-ou-sgbd"><span class="header-section-number">1.2.2</span> Les systèmes de gestion de bases de données (DBMS ou SGBD)</a></h3>
<section id="définition-1" class="level4">
<h4><a href="#définition-1"><span class="header-section-number">1.2.2.1</span> Définition</a></h4>
<p>Un <strong>système de gestion de base de données</strong> est un logiciel qui permet aux utilisateurs de définir, créer, maintenir et contrôler l’accès à la base de données.</p>
</section>
<section id="fonctionnalités-fournies" class="level4">
<h4><a href="#fonctionnalités-fournies"><span class="header-section-number">1.2.2.2</span> Fonctionnalités fournies</a></h4>
<p>Les systèmes de gestion de bases de données donnent accès à des fonctionnalités. Par exemple:</p>
<ul>
<li>Permet aux utilisateurs de définir la base de données avec un <strong>langage de définition de données (DDL)</strong>. Ce langage permet de spécifier les types, les structures et les contraintes à appliquer sur les données qui vont être entreposées dans la base de données.</li>
<li>Permet aux utilisateurs de d’insérer, de mettre à jour, d’effacer et d’aller chercher des données dans la base de données avec un <strong>langage de manipulation de données (DML)</strong>. Le langage de manipulation de données permet de faire ces opérations avec un <strong>langage de requête</strong> comme le <strong>langage structuré de requête (SQL)</strong>.</li>
<li>Permet un accès contrôlé à la base de données. Par exemple:
<ul>
<li>Système de sécurité qui empêche les accès non autorisés à la base de données</li>
<li>Système d’intégrité qui maintient la consistence des données</li>
<li>Système de contrôle d’accès multiple qui permet l’accès partagé à la base de données</li>
<li>Système de contrôle de récupération qui permet de remettre la base de données à un état antérieur après un problème matériel ou logiciel</li>
<li>Catalogue usager qui contient des descriptions des données dans la base de données</li>
</ul></li>
</ul>
</section>
<section id="avantages-1" class="level4">
<h4><a href="#avantages-1"><span class="header-section-number">1.2.2.3</span> Avantages</a></h4>
<p>Il y a plusieurs avantages aux systèmes de gestion de bases de données. Parmi ces avantages, on dénombre le contrôle de la redondance des données, la cohérence des données, plus d’informations avec le même nombre de données, le partage des données, une meilleure intégrité des données, une sécurité accrue, l’application des standards, des économies de taille, la balance de besoins contradictoires, l’amélioration de l’accessibilité et de la réactivité des données, une productivité accrue, maintenance améliorée grâce à l’indépendence des données, amélioration de l’accès simultané et de meilleurs services de restauration des données.</p>
<section id="contrôle-de-la-redondance-des-données" class="level5">
<h5><a href="#contrôle-de-la-redondance-des-données"><span class="header-section-number">1.2.2.3.1</span> Contrôle de la redondance des données</a></h5>
<p>L’approche par bases de données essaie d’éliminer les redondances en intégrant les fichiers de sorte que des copies des mêmes données ne sont pas enregistrées. Toutefois, l’approche par bases de données n’élimine pas toutes les redondances, elle ne fait que contrôler la quantité de redondance. Dans certains cas, il est nécessaire de dupliquer des données clés pour modéliser des relations. Dans d’autres cas, il est désirable de dupliquer quelques données pour améliorer les performances.</p>
</section>
<section id="cohérence-des-données" class="level5">
<h5><a href="#cohérence-des-données"><span class="header-section-number">1.2.2.3.2</span> Cohérence des données</a></h5>
<p>En éliminant ou en controllant les redondances, on réduit le risques d’incohérences. S’il n’y a qu’une copie d’une données dans la base de données, n’importe quelle mise à jour de sa valeur ne va devoir être fait qu’une fois. S’il y a plusieurs copies et que le système est au courant, il peut s’assurer que toutes les copies sont consistentes.</p>
</section>
<section id="plus-dinformations-avec-le-même-nombre-de-données" class="level5">
<h5><a href="#plus-dinformations-avec-le-même-nombre-de-données"><span class="header-section-number">1.2.2.3.3</span> Plus d’informations avec le même nombre de données</a></h5>
<p>Comme toutes les informations sont accessibles par tous les départements d’une organisation, il est possible d’avoir plus d’information avec les mêmes données.</p>
</section>
<section id="partage-des-données" class="level5">
<h5><a href="#partage-des-données"><span class="header-section-number">1.2.2.3.4</span> Partage des données</a></h5>
<p>Comme la base de données est commune à toute l’organisation, elle peut être accéder par tout le monde.</p>
</section>
<section id="meilleure-intégrité-des-données" class="level5">
<h5><a href="#meilleure-intégrité-des-données"><span class="header-section-number">1.2.2.3.5</span> Meilleure intégrité des données</a></h5>
<p>L’intégrité d’une base de données réfère à la validité et à la cohérence des données enregistrées. L’intégrité est exprimé en termes de contraintes que la base de données ne peut violer.</p>
</section>
<section id="sécurité-accrue" class="level5">
<h5><a href="#sécurité-accrue"><span class="header-section-number">1.2.2.3.6</span> Sécurité accrue</a></h5>
<p>La sécurité des bases de données est la protection de la base de données contre les utilisateurs non autorisés. L’intégraton permet à l’administrateur de la base de données de définir la sécurité de la base de données. Cette sécurité peut prendre la forme d’identifiants et de mots de passe.</p>
</section>
<section id="application-des-standards" class="level5">
<h5><a href="#application-des-standards"><span class="header-section-number">1.2.2.3.7</span> Application des standards</a></h5>
<p>L’intégraton permet à l’administrateur de la base de données d’appliquer les standards nécessaires. Ceux-ci peuvent prendre la forme de format de données, format de la documentation, les procédures de mise à jour et règles d’accès.</p>
</section>
<section id="économies-de-taille" class="level5">
<h5><a href="#économies-de-taille"><span class="header-section-number">1.2.2.3.8</span> Économies de taille</a></h5>
<p>Combiner toutes les données d’une organisations dans une base de données et créer un ensemble d’application qui marche avec cette seule source de données peut permettre d’économiser beaucoup d’argent. En effet, au lieu que chaque département ait leur propre budget pour la maintenant et le développement de leur système basé sur une approche fichier, les efforts peuvent être combinés pour être concentré vers la base de données uniques pouvant ainsi sauver de l’argent.</p>
</section>
<section id="balance-de-besoins-contradictoires" class="level5">
<h5><a href="#balance-de-besoins-contradictoires"><span class="header-section-number">1.2.2.3.9</span> Balance de besoins contradictoires</a></h5>
<p>Chaque utilisateur ou département a des besoins qui peuvent être en conflit avec ceux des autres utilisateurs. Comme la base de données est sous le contrôle de l’administrateur de bases de données, celui-ci peut prendre des décisions à propos de la conception et de l’utilisation de la base de données qui vont tirer le maximum des ressources disponibles de l’organisation.</p>
</section>
<section id="amélioration-de-laccessibilité-et-de-la-réactivité-des-données" class="level5">
<h5><a href="#amélioration-de-laccessibilité-et-de-la-réactivité-des-données"><span class="header-section-number">1.2.2.3.10</span> Amélioration de l’accessibilité et de la réactivité des données</a></h5>
<p>En raison de l’intégration, les données qui sont partagées à travers les frontières des différents départements sont directement accessibles aux utilisateurs. Cela donne un système qui a potentiellement beaucoup plus de fonctionnalités.</p>
</section>
<section id="productivité-accrue" class="level5">
<h5><a href="#productivité-accrue"><span class="header-section-number">1.2.2.3.11</span> Productivité accrue</a></h5>
<p>Un système de gestion de gestion de bases de données fourni par défaut la plupart des fonctionnalités d’une approche par fichiers. Ainsi, le programmeur n’a pas à se concentrer sur les aspects de base de la base de données et peut se concentrer sur les aspects plus spécifiques à sa propre application.</p>
</section>
<section id="maintenance-améliorée-grâce-à-lindépendence-des-données" class="level5">
<h5><a href="#maintenance-améliorée-grâce-à-lindépendence-des-données"><span class="header-section-number">1.2.2.3.12</span> Maintenance améliorée grâce à l’indépendence des données</a></h5>
<p>Un système de gestion de bases de données sépare la description des données des applications, rendant ainsi les applications immunisées contre les changements de descriptions des données.</p>
</section>
<section id="amélioration-de-laccès-simultané" class="level5">
<h5><a href="#amélioration-de-laccès-simultané"><span class="header-section-number">1.2.2.3.13</span> Amélioration de l’accès simultané</a></h5>
<p>La plupart des systèmes de gestion de bases de données contrôlent les accès simultanés à la base de données rendant ainsi les problèmes d’accès simultanés impossible.</p>
</section>
<section id="meilleurs-services-de-restauration-et-de-sauvegarde-des-données" class="level5">
<h5><a href="#meilleurs-services-de-restauration-et-de-sauvegarde-des-données"><span class="header-section-number">1.2.2.3.14</span> Meilleurs services de restauration et de sauvegarde des données</a></h5>
<p>Les systèmes de gestion de bases de données ont des mesures pour minimiser les dégats en cas de défaillance.</p>
</section>
</section>
<section id="désavantages" class="level4">
<h4><a href="#désavantages"><span class="header-section-number">1.2.2.4</span> Désavantages</a></h4>
<p>Il y a aussi quelques désavantages aux systèmes de gestion de bases de données tels que une plus grande complexité, une plus grande taille, le coût des systèmes de gestion de bases de données, les coûts additionnels de matériel, le coût de conversion, la performance et un plus gros impact en cas de défaillance.</p>
<section id="complexité" class="level5">
<h5><a href="#complexité"><span class="header-section-number">1.2.2.4.1</span> Complexité</a></h5>
<p>La plupart des fonctionnalités dont nous nous attendons d’un système de gestion de bases de données font en sorte que c’est un logiciel très complexe. Une incompréhension du système peut amener des mauvaises décisions de conception qui peuvent avoir des conséquences sérieuses pour l’organisation.</p>
</section>
<section id="taille" class="level5">
<h5><a href="#taille"><span class="header-section-number">1.2.2.4.2</span> Taille</a></h5>
<p>La complexité et toutes les fonctionnalités des systèmes de gestion de bases de données font en sorte que c’est un logiciel extrêmement lourd qui demande beaucoup d’espace disque et qui demande beaucoup de mémoire pour l’exécuter.</p>
</section>
<section id="coût-des-systèmes-de-gestion-de-bases-de-données" class="level5">
<h5><a href="#coût-des-systèmes-de-gestion-de-bases-de-données"><span class="header-section-number">1.2.2.4.3</span> Coût des systèmes de gestion de bases de données</a></h5>
<p>Le coût des systèmes de gestion de bases de données varie en fonction des fonctionnalités et de l’environnement fournis. Également, il y a des frais annuels de maintenance qui s’imposent.</p>
</section>
<section id="coûts-additionnels-de-matériel" class="level5">
<h5><a href="#coûts-additionnels-de-matériel"><span class="header-section-number">1.2.2.4.4</span> Coûts additionnels de matériel</a></h5>
<p>Les besoins en espace de disque pour la base de données et le système de gestion de bases de données peut demander à acheter du nouvel espace disque. De plus, pour atteindre les performances requises, il peut être nécessaire d’acheter une machine dédiée pour exécuter la base de données.</p>
</section>
<section id="coût-de-conversion" class="level5">
<h5><a href="#coût-de-conversion"><span class="header-section-number">1.2.2.4.5</span> Coût de conversion</a></h5>
<p>Dans certains cas, le coût de conversion des applications existants pour qu’elles roulent sur le nouveau système peut être très grand.</p>
</section>
<section id="performance" class="level5">
<h5><a href="#performance"><span class="header-section-number">1.2.2.4.6</span> Performance</a></h5>
<p>Une approche par fichiers permet de créer des applications et des formats de fichier qui ont un but spécifique. Cela fait en sorte que leur performance est souvent très bonne. Par contre, dans le cas d’un système de gestion de bases de données, on essaie d’être plus général dans le but de desservir plus d’applications. Cette généralité entraîne souvent un coût au niveau de la performance.</p>
</section>
<section id="plus-gros-impact-en-cas-de-défaillance." class="level5">
<h5><a href="#plus-gros-impact-en-cas-de-défaillance."><span class="header-section-number">1.2.2.4.7</span> Plus gros impact en cas de défaillance.</a></h5>
<p>La centralisation des données augmente la vulnérabilité du système. Comme tout le monde dépend de la base de données, sa défaillance peut amener plusieurs opérations à s’arrêter.</p>
</section>
</section>
<section id="mécanisme-de-vision" class="level4">
<h4><a href="#mécanisme-de-vision"><span class="header-section-number">1.2.2.5</span> Mécanisme de vision</a></h4>
<p>En plus d’offrir toutes les fonctionnalités précédentes, les système de gestion de base de données offrent un <strong>mécanisme de vue</strong> qui permet aux utilisateurs d’avoir leur propre vue de la base de données. Par exemple, une vue pourrait permettre de ne voir que certaines entités de la base de données</p>
<section id="bénéfices" class="level5">
<h5><a href="#bénéfices"><span class="header-section-number">1.2.2.5.1</span> Bénéfices</a></h5>
<p>Les vues offrent plusieurs bénéfices tels que:</p>
<ul>
<li>Un niveau de sécurité supplémentaire, car on peut exclure des données que certains utilisateurs ne devraient pas voir</li>
<li>Un mécanisme pour paramétrer l’apparence de la base de données</li>
<li>Permet de présenter une vision immutable de la structure de la base de données même si la base de données en dessous est changée, car la vue va seulement présentée les données qui intéressent l’utilisateur. Donc, même si les autres champs changent, tant que les champs qui intéressent l’utilisateur n’ont pas changé, la vue de l’utilisateur ne sera pas affectée.</li>
</ul>
</section>
</section>
<section id="composants-dun-système-de-gestion-de-bases-de-données" class="level4">
<h4><a href="#composants-dun-système-de-gestion-de-bases-de-données"><span class="header-section-number">1.2.2.6</span> Composants d’un système de gestion de bases de données</a></h4>
<p>Un système de gestion de bases de données est composées de plusieurs choses.</p>
<section id="matériel" class="level5">
<h5><a href="#matériel"><span class="header-section-number">1.2.2.6.1</span> Matériel</a></h5>
<p>Un système de gestion de bases de données a besoin de matériel pour fonctionner. Ce matériel peut aller d’un simple ordinateur personnel à un réseau d’ordinateurs. Quelques systèmes de gestion de bases de données nécessite un système d’exploitation particulier ou du matériel spécifique alors que d’autres, non. Les système de gestion de bases de données ont besoin d’un minimum de mémoire et d’espace disque pour fonctionner, mais ce minimum ne garantit pas une performance adéquate. Un exemple d’<strong>architecture client-serveur</strong> se retrouve à la figure suivante. Dans cette figure, on remarque le serveur central qui sert de <strong>backend</strong> au système de gestion de bases de données et les différents ordinateurs qui servent de <strong>frontend</strong> au système de gestion de bases de données.</p>
<figure>
<img src="images/exemple_materiel_SGBD.png" alt="Exemple d’architecture client-serveur" /><figcaption>Exemple d’architecture client-serveur</figcaption>
</figure>
</section>
<section id="logiciel" class="level5">
<h5><a href="#logiciel"><span class="header-section-number">1.2.2.6.2</span> Logiciel</a></h5>
<p>La composante logiciel comprend le logiciel de système de gestion de bases de données lui-même, les programmes d’application, le système d’exploitation et le logiciel de réseau si le système de gestion de bases de données est utilisé par un réseau.</p>
</section>
<section id="données" class="level5">
<h5><a href="#données"><span class="header-section-number">1.2.2.6.3</span> Données</a></h5>
<p>Les données sont la partie la plus importante d’un système de gestion de bases de données. Elles servent de pont entre les humains et les machines. La base de données contient les données opérationnelles et les metadatas. La structure de la base de données est appelée <strong>schéma</strong>. Les schémas contiennent des <strong>tables</strong>. Les champs dans ces tables sont appelés des <strong>attributs</strong>.</p>
</section>
<section id="procédures" class="level5">
<h5><a href="#procédures"><span class="header-section-number">1.2.2.6.4</span> Procédures</a></h5>
<p>Les procédures sont les instructions et les règles qui régissent la forme et l’utilisation de la base de données. Ces procédures sont destinées aux utilisateurs du système et au personnel qui est responsable de la base de données.</p>
</section>
<section id="humains" class="level5">
<h5><a href="#humains"><span class="header-section-number">1.2.2.6.5</span> Humains</a></h5>
<p>Les personnes impliquées avec le système.</p>
</section>
</section>
<section id="conception-de-bases-de-données" class="level4">
<h4><a href="#conception-de-bases-de-données"><span class="header-section-number">1.2.2.7</span> Conception de bases de données</a></h4>
<p>La structure d’une base de données est déterminée lors du <strong>design de la base de données</strong>.</p>
</section>
<section id="rôles-dans-un-environnement-de-bases-de-données" class="level4">
<h4><a href="#rôles-dans-un-environnement-de-bases-de-données"><span class="header-section-number">1.2.2.8</span> Rôles dans un environnement de bases de données</a></h4>
<p>Il y a quatre types de personnes dans un environnement de bases de données. Il y a les administrateurs des données et de la base de données, les concepteurs de bases de données, les développeurs d’application et les utilisateurs.</p>
<section id="administrateurs-des-données-et-de-la-base-de-données" class="level5">
<h5><a href="#administrateurs-des-données-et-de-la-base-de-données"><span class="header-section-number">1.2.2.8.1</span> Administrateurs des données et de la base de données</a></h5>
<p>Les administrateurs des données et de la base de données sont des rôles qui sont chargés du contrôle et de la gestion du système de gestion de la base de données et de ses données.</p>
<ul>
<li>L’<strong>administrateur des données (DA)</strong> est responsable de gérer les ressources de données, incluant la planification de la base de données, le développement et la maintenance des standards, politiques et procédures. Il doit aussi s’occuper du design conceptuel/logique de la base de données.</li>
<li>L’<strong>administrateur de la base de données (DBA)</strong> est responsable de la réalisation physique de la base de données, incluant le design physique de la base de données et l’implantation, la sécurité, le contrôle d’intégrité, la maintenance du système opérationnel et d’assurer une performance satisfaisante des applications des utilisateurs.</li>
</ul>
</section>
<section id="concepteurs-de-bases-de-données" class="level5">
<h5><a href="#concepteurs-de-bases-de-données"><span class="header-section-number">1.2.2.8.2</span> Concepteurs de bases de données</a></h5>
<p>Il y a deux types de concepteurs de bases de données. Il y a les <strong>concepteurs de bases de données logiques</strong> et les <strong>concepteurs de bases de données physiques</strong>.</p>
<ul>
<li><strong>Concepteurs de bases de données logiques</strong>: Responsables d’identifier les données (ou plutôt les entités et les attributs), les relations entre les données et les contraintes sur les données qui vont être enregistrées dans la base de données. Il doit avoir une bonne compréhension des données de l’organisation et des contraintes qui s’appliquent sur celles-ci.</li>
<li><strong>Concepteurs de bases de données physiques</strong>: Décident comment la conception logique de la base de données va être physiquement implantée. Cela consiste à:
<ul>
<li>Transformer le design logique de la base de données dans un ensemble de tables et de contraintes d’intégrité.</li>
<li>Sélectionner des structures d’entreposage et des méthodes d’accès aux données pour obtenir une bonne performance.</li>
<li>Établir les mesures de sécurité requises pour les données.</li>
</ul></li>
</ul>
</section>
<section id="développeurs-dapplication" class="level5">
<h5><a href="#développeurs-dapplication"><span class="header-section-number">1.2.2.8.3</span> Développeurs d’application</a></h5>
<p>Les développeurs d’application sont responsables de développer des programmes qui vont fournir les fonctionnalités requises aux usagers. Ces applications vont interagir avec la base de données.</p>
</section>
<section id="utilisateurs" class="level5">
<h5><a href="#utilisateurs"><span class="header-section-number">1.2.2.8.4</span> Utilisateurs</a></h5>
<p>Les utilisateurs sont ceux qui ont besoin des informations de la base de données. On distingue deux types d’utilisateurs, les <strong>utilisateurs naïfs</strong> et les <strong>utilisateurs sophistiqués</strong>.</p>
<ul>
<li><p><strong>Utilisateurs naïfs</strong>: Ignorent tout du système de gestion de bases de données. Ils accèdent à la base de données par des programmes spécifiques. Ils utilisent les opérations de bases de données en appuyant sur des boutons ou en entrant des commandes simples.</p></li>
<li><p><strong>Utilisateurs sophistiqués</strong>: Familiés avec la structure de la base de données et des installations fournies par le système de gestion de bases de données. Ils sont capable d’utiliser un langage de requêtes comme le <em>SQL</em> pour exécuter les opérations requises. Ils sont parfois même capables d’écrire des applications pour leur propre usage.</p></li>
</ul>
</section>
</section>
</section>
</section>
</section>
<section id="modèle-relationnel" class="level1">
<h1><a href="#modèle-relationnel"><span class="header-section-number">2</span> Modèle relationnel</a></h1>
<p>Dans ce chapitre, nous aborderons le modèle relationnel et ses différents éléments.</p>
<section id="structure-des-données-relationnelles" class="level2">
<h2><a href="#structure-des-données-relationnelles"><span class="header-section-number">2.1</span> Structure des données relationnelles</a></h2>
<p>La structure des données relationnelles peut être décomposée dans les éléments suivants:</p>
<dl>
<dt><strong>Relation (table ou fichier)</strong></dt>
<dd><p>Table avec des lignes et des colonnes.</p>
</dd>
<dt><strong>Attribut (colonne ou champ)</strong></dt>
<dd><p>Colonne nommée d’une relation.</p>
</dd>
<dt><strong>Domaine</strong></dt>
<dd><p>L’ensemble des valeurs allouées pour un ou plusieurs attributs.</p>
</dd>
<dt><strong>Tuple (ligne ou archive)</strong></dt>
<dd><p>Nom donné à une ligne dans une relation (ou table).</p>
</dd>
<dt><strong>Degré</strong></dt>
<dd><p>Le nombre d’attributs que la relation contient.</p>
</dd>
</dl>
<p>Une relation de degré un est appelée une relation unaire. Une relation de degré deux est appelée une relation binaire, une de degré trois est appelée une relation tertiaire et, après ça, le terme n-tiaire est utilisé.</p>
<dl>
<dt><strong>Cardinalité</strong></dt>
<dd><p>Le nombre de tuples que la relation contient.</p>
</dd>
<dt><strong>Base de données relationnel</strong></dt>
<dd><p>Une collection de relations normalisées avec des noms distincts de relations.</p>
</dd>
</dl>
</section>
<section id="relations-mathématiques" class="level2">
<h2><a href="#relations-mathématiques"><span class="header-section-number">2.2</span> Relations mathématiques</a></h2>
<p>Une relation mathématique est définie comme étant le <strong>produit cartésien</strong> de plusieurs ensembles. Le <strong>produit cartésien</strong> est défini comme suit:</p>
<p>Soit <span class="math">\(D_1, D_2, \dots D_n\)</span>, <span class="math">\(n\)</span> ensembles. Leur produit cartésien est défini comme:</p>
<p><span class="math">\[D_1 \times D_2 \times \dots \times D_n = \{ (d_1, d_2, \dots, d_n) 
\mid d_1 \in D_1, d_2 \in D_2, \dots d_n \in D_n\}\]</span></p>
<p>qui peut être réécrit comme</p>
<p><span class="math">\[\prod_{i = 1}^n D_i\]</span></p>
</section>
<section id="relations-des-bases-de-données" class="level2">
<h2><a href="#relations-des-bases-de-données"><span class="header-section-number">2.3</span> Relations des bases de données</a></h2>
<p>En applicant les notions vues à la section précédente, nous pouvons désormais définir un schéma de relation. Soit <span class="math">\(A_1, A_2, \dots, A_n\)</span> des attributs avec comme domaines <span class="math">\(D_1, D_2, \dots, D_n\)</span>. Alors, l’ensemble <span class="math">\(\{A_1: D_1, A_2: D_2, \dots, A_n: D_n\}\)</span> est un schéma de relation. Une relation <span class="math">\(R\)</span> définie par le schéma de relation <span class="math">\(S\)</span> est un ensemble qui met en relation les noms des attributs avec leurs domaines respectifs. Ainsi, la relation <span class="math">\(R\)</span> est un ensemble de <span class="math">\(n\)</span>-tuples:</p>
<p><span class="math">\[(A_1: d_1, A_2: d_2, \dots, A_n: d_n)~\textrm{tel que}~d_1 \in D_1, d_2 \in D_2, \dots, d_n \in D_n\]</span></p>
<p>Chaque élément du n-tuple consiste d’un attribut et d’une valeur pour cet attribut. Finalement, nous pouvons définir le <strong>schéma relationnel de bases de données</strong>. Soit <span class="math">\(R_1, R_2, \dots, R_n\)</span> des ensembles de schémas de relation, alors nous pouvons écrire le schéma relationnel de bases de données comme:</p>
<p><span class="math">\[R = \{R_1, R_2, \dots, R_n\}\]</span></p>
</section>
<section id="propriétés-des-relations" class="level2">
<h2><a href="#propriétés-des-relations"><span class="header-section-number">2.4</span> Propriétés des relations</a></h2>
<p>Une relation a les propriétés suivantes:</p>
<ul>
<li>elle a un nom qui est distinct de tous les autres noms dans le schéma relationnel;</li>
<li>chaque cellule contient exactement une valeur atomique;</li>
<li>chaque attribut a un nom distinct;</li>
<li>les valeurs d’un attribut proviennent tous d’un même domaine;</li>
<li>chaque tuple est distinct; il n’y a pas de doublons;</li>
<li>l’ordre des attributs n’a pas d’importance;</li>
<li>l’ordre des tuples n’a pas d’importance, en théorie.</li>
</ul>
</section>
<section id="clés-relationnelles" class="level2">
<h2><a href="#clés-relationnelles"><span class="header-section-number">2.5</span> Clés relationnelles</a></h2>
<p>Comme il n’y a pas de tuples identiques dans une relation, nous devons être capables d’identifier un ou plusieurs attributs qui identifient chaque tuple dans la relation. Ces attributs sont appelés des <strong>clés relationnelles</strong>.</p>
<section id="superclé" class="level3">
<h3><a href="#superclé"><span class="header-section-number">2.5.1</span> Superclé</a></h3>
<p>Une <strong>superclé</strong> est un attribut, ou un ensemble d’attributs, qui identifient de manière unique un tuple dans une relation.</p>
</section>
<section id="clé-candidate" class="level3">
<h3><a href="#clé-candidate"><span class="header-section-number">2.5.2</span> Clé candidate</a></h3>
<p>Une <strong>clé candidate</strong> est une superclé tel qu’aucun sous-ensemble propre est une superclé dans la relation. Une clé candidate <span class="math">\(K\)</span> d’une relation <span class="math">\(R\)</span> possède deux propriétés:</p>
<ul>
<li><em>Unicité</em>: Pour chaque tuple de <span class="math">\(R\)</span>, les valeurs de <span class="math">\(K\)</span> identifient de manière unique ce tuple.</li>
<li><em>Irréductibilité</em>: Aucun sous-ensemble de <span class="math">\(K\)</span> a la propriété d’unicité.</li>
</ul>
</section>
<section id="clé-composée" class="level3">
<h3><a href="#clé-composée"><span class="header-section-number">2.5.3</span> Clé composée</a></h3>
<p>Une <strong>clé composée</strong> est une clé candidate qui possède plus qu’un attribut.</p>
</section>
<section id="clé-primaire" class="level3">
<h3><a href="#clé-primaire"><span class="header-section-number">2.5.4</span> Clé primaire</a></h3>
<p>Une <strong>clé primaire</strong> est la clé candidate choisie pour identifier chaque tuple de manière unique dans la relation.</p>
</section>
<section id="clé-alternative" class="level3">
<h3><a href="#clé-alternative"><span class="header-section-number">2.5.5</span> Clé alternative</a></h3>
<p>Les clés candidates qui ne sont pas choisies pour être la clé primaire sont dites <strong>clés alternatives</strong>.</p>
</section>
<section id="clé-étrangère" class="level3">
<h3><a href="#clé-étrangère"><span class="header-section-number">2.5.6</span> Clé étrangère</a></h3>
<p>Une <strong>clé étrangère</strong> est un attribut, ou un ensemble d’attributs, à l’intérieur d’une relation qui correspond à la clé candidate d’une relation (possiblement la même).</p>
</section>
</section>
<section id="contraintes-dintégrité" class="level2">
<h2><a href="#contraintes-dintégrité"><span class="header-section-number">2.6</span> Contraintes d’intégrité</a></h2>
<p>Comme chaque attribut à un domaine associé, il y a des contraintes (appelées <strong>contraintes de domaine</strong>) qui forment des restrictions sur l’ensemble des valeurs permises pour les attributs des relations. Il y a aussi des <strong>règles d’intégrité</strong> qui sont des contraintes qui s’appliquent sur toutes les instances de la base de données. Il y a deux règles d’intégrité importantes: l’<strong>intégrité d’entité</strong> et l’<strong>intégrité référentielle</strong>. Il existe également d’autres contraintes d’intégrité telles que la <strong>multiplicité</strong> et les <strong>contraintes générales</strong>.</p>
<section id="null" class="level3">
<h3><a href="#null"><span class="header-section-number">2.6.1</span> Null</a></h3>
<p>Les nulls représentent une valeur pour un attribut qui est présentement inconnu ou pas applicable pour ce tuple. Les nulls peuvent poser des problèmes d’implantation, car le modèle relationnel est basé le calcul de prédicat de premier ordre, qui permet seulement deux valeur: vrai ou faux.</p>
</section>
<section id="intégrité-dentité" class="level3">
<h3><a href="#intégrité-dentité"><span class="header-section-number">2.6.2</span> Intégrité d’entité</a></h3>
<p>Cette règle s’applique aux clé primaires des <strong>relations de base</strong>. Une relation de base est une relation qui correspond à une entité dans le schéma conceptuel. Cette règle stipule que, dans une relation de base, aucun attribut de la clé primaire ne peut être nul. En effet, une clé primaire est l’identifiant minimal qui est utilisé pour identifier les tuples de manière unique. Si on inclut les nulls, nous disons que tous les attributs ne sont pas nécessaires pour identifier de manière unique les tuples. Il y a donc une contradiction.</p>
</section>
<section id="intégrité-référentielle" class="level3">
<h3><a href="#intégrité-référentielle"><span class="header-section-number">2.6.3</span> Intégrité référentielle</a></h3>
<p>Cette règle s’applique seulement aux clés étrangères. Elle stipule que, si une clé étrangère existe dans une relation, soit la valeur de la clé étrangère correspond à la valeur d’une clé candidate d’un tuple dans sa relation maison ou la valeur de la clé étrangère doit être complètement nulle.</p>
</section>
<section id="contraintes-générales" class="level3">
<h3><a href="#contraintes-générales"><span class="header-section-number">2.6.4</span> Contraintes générales</a></h3>
<p>Les contraintes générales sont des règles additionnelles spécifiées par les utilisateurs ou les administrateurs de bases de données de la base de données qui définissent ou contraignent des aspects de l’entreprise.</p>
</section>
</section>
<section id="vues" class="level2">
<h2><a href="#vues"><span class="header-section-number">2.7</span> Vues</a></h2>
<p>Dans le modèle relationnel, une vue n’est pas la structure de la base de données telle que l’aperçoit un utilisateur particulier. Une vue est plutôt une <strong>relation virtuelle</strong> ou une <strong>relation dérivée</strong>, c’est-à-dire une relation qui n’existe pas par elle-même, mais qui peut être dérivée dynamiquement d’une ou plusieurs relations de base.</p>
<section id="définition-2" class="level3">
<h3><a href="#définition-2"><span class="header-section-number">2.7.1</span> Définition</a></h3>
<p>Une vue est le résultat dynamique d’une ou plusieurs opérations opérant sur les relations de base afin de produire une autre relation. Une vue est une <em>relation virtuelle</em> qui n’existe pas nécessairement dans la base de données mais qui peut être produite sur demande par un utilisateur donné au moment de la requête. Les vues semblent exister pour l’utilisateur et peuvent être manipulées, mais elles ne sont pas nécessairement enregistrées dans la base de données comme une relation de base. Toutes les opérations sur les vues sont automatiquement traduites en opération sur les relations de base duquelles celles-ci sont dérivées. De plus, les vues sont <strong>dynamiques</strong> ce qui impliquent que les changements aux relations de base influeront immédiatement les vues.</p>
</section>
<section id="utilités" class="level3">
<h3><a href="#utilités"><span class="header-section-number">2.7.2</span> Utilités</a></h3>
<p>Le mécanisme de vues est désirable pour plusieurs raisons:</p>
<ul>
<li>Fourni un mécanisme puissant et flexible pour cacher des parties de la base de données à certains utilisateurs. Les utilisateurs ne sont pas au courant des attributs cachés par la vue.</li>
<li>Permet aux utilisateurs d’accéder aux données d’une façon adaptée à leurs besoins. De cette façon, les même données peuvent être vues par différentes personnes de différentes façons.</li>
<li>Peut simplifier des opérations complexes sur les relations de base.</li>
</ul>
<p>Une vue devrait être développée de sorte qu’elle supporte le modèle externe que l’utilisateur trouve familier. Les vues fournissent une indépendence des données logiques.</p>
</section>
<section id="mise-à-jour-des-vues" class="level3">
<h3><a href="#mise-à-jour-des-vues"><span class="header-section-number">2.7.3</span> Mise à jour des vues</a></h3>
<p>Toutes les mises à jour à une relation de base devraient immédiatement être reflétées dans les vues qui font références à cette relation de base. De façon similaire, si une vue est mise à jour, la relation de base sur laquelle elle est basée devrait être mise à jour aussi. Toutefois, il y a des restrictions sur les types de modification qui peuvent être faits sur les vues. Les conditions sous lesquelles la mise à jour à partir de la vue est possible sont les suivantes:</p>
<ul>
<li>Les mises à jour sont permises sur une vue définie en utilisant une requête simple qui implique une seule relation de base et qui contient ou bien la clé primaire ou une clé candidate de la relation de base.</li>
<li>Les mises à jour ne sont pas permises par des vues impliquant de multiples relations de base.</li>
<li>Les mises à jour ne sont pas permises par des vues impliquant l’aggrégation ou le groupement d’opérations.</li>
</ul>
</section>
</section>
</section>
<section id="normalisation" class="level1">
<h1><a href="#normalisation"><span class="header-section-number">3</span> Normalisation</a></h1>
<p>Dans ce chapitre, nous allons parler de la normalisation et de ses buts. Nous allons aussi aborder le concept de dépendances fonctionnelles.</p>
<section id="redondance-de-données-et-anomalies-de-mises-à-jour" class="level2">
<h2><a href="#redondance-de-données-et-anomalies-de-mises-à-jour"><span class="header-section-number">3.1</span> Redondance de données et anomalies de mises à jour</a></h2>
<p>En éliminant la redondance dans les bases de données, on en retire les bénéfices suivants:</p>
<ul>
<li>les mises à jour des données sont faites avec un nombre minimal d’opérations réduisant ainsi les risques d’incohérences dans la base de données;</li>
<li>le nombre d’espace de stockage requis pour les relation est diminué réduisant ainsi les coûts.</li>
</ul>
<p>Les relations qui ont des données redondantes peuvent avoir des problèmes appelés des <strong>anomalies de mise à jour</strong>. Il y a trois types d’anomalies de mise à jour: les <strong>anomalies d’insertion</strong>, les <strong>anomalies de suppression</strong> et les <strong>anomalies de modification</strong>.</p>
<section id="anomalies-dinsertion" class="level3">
<h3><a href="#anomalies-dinsertion"><span class="header-section-number">3.1.1</span> Anomalies d’insertion</a></h3>
<p>Si on ajoute des nouvelles données à la base de données, il peut y avoir des incohérences avec les champs déjà existants. De plus, si la table est mal faite, on peut être forcé d’ajouter des <em>nulls</em> pour pouvoir ajouter de nouveaux tuples.</p>
</section>
<section id="anomalies-de-suppression" class="level3">
<h3><a href="#anomalies-de-suppression"><span class="header-section-number">3.1.2</span> Anomalies de suppression</a></h3>
<p>Si on efface un attribut d’un tuple qui contient la dernière information sur un des attributs, cette information sera perdu lorsque l’attribut sera enlevé.</p>
</section>
<section id="anomalies-de-modification" class="level3">
<h3><a href="#anomalies-de-modification"><span class="header-section-number">3.1.3</span> Anomalies de modification</a></h3>
<p>Si on modifie la valeur d’un attribut, il faut s’assurer que dans la table, toutes les tuples qui contiennent cet attribut sont modifier. Sinon, on risque d’avoir une anomalie de modification. On peut éviter ces anomalies en décomposant les relations en plus petites relations. Cette façon de faire possède deux propriétés intéressantes:</p>
<ul>
<li>la propriété du <strong>raccord sans pertes</strong> qui assure que toutes les instances de la relation originale peuvent être identifiées avec les relations plus petites.</li>
<li>la propriété de <strong>préservation des dépendances</strong> qui assure qu’une contrainte de la relation originale sera maintenue en maintenant la contraintes sur les relations plus petites.</li>
</ul>
</section>
</section>
<section id="dépendances-fonctionnelles" class="level2">
<h2><a href="#dépendances-fonctionnelles"><span class="header-section-number">3.2</span> Dépendances fonctionnelles</a></h2>
<p>Les <strong>dépendances fonctionnelles</strong> jouent un rôle important dans la normalisation des bases de données.</p>
<section id="définition-3" class="level3">
<h3><a href="#définition-3"><span class="header-section-number">3.2.1</span> Définition</a></h3>
<p>Assumons un schéma relationnel possédant les attributs <span class="math">\((A, B, C, \dots, Z)\)</span> et une base de données décrite par une <strong>relation universelle</strong> <span class="math">\(R = (A, B, C, \dots, Z)\)</span>. Cela veut dire que tous les attributs dans la base de données ont un nom unique. Une <strong>dépendance fonctionnelle</strong> décrit le lien entre les attributs d’une relation. Par exemple, si <span class="math">\(A\)</span> et <span class="math">\(B\)</span> sont des attributs de la relation <span class="math">\(R\)</span>, <span class="math">\(B\)</span> est fonctionnellement dépendant de <span class="math">\(A\)</span> (dénoté <span class="math">\(A \mapsto B\)</span>), si chaque valeur de <span class="math">\(A\)</span> est associée à seulement une valeur de <span class="math">\(B\)</span> (<span class="math">\(A\)</span> et <span class="math">\(B\)</span> peuvent consister de plus d’un attributs).</p>
</section>
<section id="déterminant" class="level3">
<h3><a href="#déterminant"><span class="header-section-number">3.2.2</span> Déterminant</a></h3>
<p>Le terme <strong>déterminant</strong> réfère à l’attribut, ou le groupe d’attributs, du côté gauche de la flèche d’une dépendance fonctionnelle.</p>
</section>
<section id="dépendance-fonctionnelle-complète" class="level3">
<h3><a href="#dépendance-fonctionnelle-complète"><span class="header-section-number">3.2.3</span> Dépendance fonctionnelle complète</a></h3>
<p>Une <strong>dépendance fonctionnelle complète</strong> est une dépendance fonctionnelle dans laquelle le déterminant à le nombre minimal d’attribut pour avoir une dépendance fonctionnelle avec les attributs à droite de la flèche.</p>
</section>
<section id="dépendance-fonctionnelle-partielle" class="level3">
<h3><a href="#dépendance-fonctionnelle-partielle"><span class="header-section-number">3.2.4</span> Dépendance fonctionnelle partielle</a></h3>
<p>Une dépendance fonctionnelle est dite dépendance fonctionnelle partielle dans laquelle un des attributs peut être enlevé du déterminant et la dépendance fonctionnelle est encore valide.</p>
</section>
<section id="dépendance-transitive" class="level3">
<h3><a href="#dépendance-transitive"><span class="header-section-number">3.2.5</span> Dépendance transitive</a></h3>
<p>Si <span class="math">\(A\)</span>, <span class="math">\(B\)</span> et <span class="math">\(C\)</span> sont des attributs d’une relation tel que si <span class="math">\(A \mapsto B\)</span> et <span class="math">\(B \mapsto C\)</span>, alors <span class="math">\(C\)</span> est dépendant transitif de <span class="math">\(A\)</span> via <span class="math">\(B\)</span> (si <span class="math">\(A\)</span> n’est pas fonctionnellement dépendant de <span class="math">\(B\)</span> ou <span class="math">\(C\)</span>).</p>
</section>
<section id="résumé-1" class="level3">
<h3><a href="#résumé-1"><span class="header-section-number">3.2.6</span> Résumé</a></h3>
<p>Les dépendances fonctionnelles qui nous intéressent pour la normalisation possèdent les propriétés suivantes:</p>
<ul>
<li>Il y a une relation <em>un à un</em> entre les attributs du déterminant et ceux du côté droit d’une dépendance fonctionnelle.</li>
<li>Elles sont toujours valides</li>
<li>Le déterminant a le minimum d’attributs nécessaires pour maintenir une dépendance fonctionnelle avec le côté droit. Il doit donc y avoir une dépendance fonctionnelle complète entre les attributs du côté gauche avec ceux du côté droit.</li>
</ul>
</section>
</section>
<section id="normalisation-et-formes-normales" class="level2">
<h2><a href="#normalisation-et-formes-normales"><span class="header-section-number">3.3</span> Normalisation et formes normales</a></h2>
<p>Dans cette section, nous verrons la normalisation ainsi que les différentes formes normales ainsi que les techniques pour les obtenir.</p>
<section id="définition-de-la-normalisation" class="level3">
<h3><a href="#définition-de-la-normalisation"><span class="header-section-number">3.3.1</span> Définition de la normalisation</a></h3>
<p>La <strong>normalisation</strong> est une technique pour produire un ensemble de relations avec des propriétés désirables selon les besoins de données de l’entreprise. Les caractéristiques d’un bon ensemble de relations sont les suivantes:</p>
<ul>
<li>le <em>nombre minimal d’attributs</em> pour supporter les besoins en données de l’entreprise;</li>
<li>les attributs avec des relations logiques (décrites comme des <strong>dépendances fonctionnelles</strong>) sont dans les mêmes relations;</li>
<li>il y a un <em>minimum de redondance</em>, avec chaque attribut qui se retrouve seulement une fois dans la base de données excepté les attributs qui sont ou qui font parties de clés étrangères qui sont essentielles pour lier des relations.</li>
</ul>
</section>
<section id="forme-non-normalisée-unf-à-première-forme-normale" class="level3">
<h3><a href="#forme-non-normalisée-unf-à-première-forme-normale"><span class="header-section-number">3.3.2</span> Forme non normalisée (UNF) à première forme normale</a></h3>
<p>Dans cette section, nous verrons comment passer de la forme non normalisée à la première forme normale.</p>
<section id="définition-de-la-forme-non-normalisée-unf" class="level4">
<h4><a href="#définition-de-la-forme-non-normalisée-unf"><span class="header-section-number">3.3.2.1</span> Définition de la forme non normalisée (UNF)</a></h4>
<p>Une table qui contient une ou plusieurs répétitions de groupe.</p>
</section>
<section id="définition-de-la-première-forme-normale-1nf" class="level4">
<h4><a href="#définition-de-la-première-forme-normale-1nf"><span class="header-section-number">3.3.2.2</span> Définition de la première forme normale (1NF)</a></h4>
<p>Une relation dans laquelle l’intersection de chaque ligne et colonne contient seulement une valeur.</p>
</section>
<section id="technique-de-normalisation" class="level4">
<h4><a href="#technique-de-normalisation"><span class="header-section-number">3.3.2.3</span> Technique de normalisation</a></h4>
<p>Il y a deux approches pour passer de la forme non normalisée à la première forme normale.</p>
<section id="mise-à-plat" class="level5">
<h5><a href="#mise-à-plat"><span class="header-section-number">3.3.2.3.1</span> Mise à plat</a></h5>
<p>Remplir les colonnes de lignes vides avec les données non dupliquées.</p>
</section>
<section id="séparer-les-données-dupliquées" class="level5">
<h5><a href="#séparer-les-données-dupliquées"><span class="header-section-number">3.3.2.3.2</span> Séparer les données dupliquées</a></h5>
<p>Placer les données dupliquées avec une copie de l’attribut clé dans une relation différente.</p>
</section>
</section>
</section>
<section id="première-forme-normale-à-la-deuxième-forme-normale" class="level3">
<h3><a href="#première-forme-normale-à-la-deuxième-forme-normale"><span class="header-section-number">3.3.3</span> Première forme normale à la deuxième forme normale</a></h3>
<p>Dans cette section, nous verrons comment passer de la première forme normale à la deuxième forme normale.</p>
<section id="définition-de-la-deuxième-forme-normale-2nf" class="level4">
<h4><a href="#définition-de-la-deuxième-forme-normale-2nf"><span class="header-section-number">3.3.3.1</span> Définition de la deuxième forme normale (2NF)</a></h4>
<p>Une relation qui est dans la deuxième forme normale est une relation qui est dans la première forme normale et dont chaque attribut qui n’est pas une clé primaire est <em>complètement dépendant</em> de la clé primaire. En d’autres mots, il ne faut pas qu’un attribut qui n’est pas une clé primaire soit dépendant d’un sous-ensemble de la clé primaire.</p>
</section>
<section id="technique-de-normalisation-1" class="level4">
<h4><a href="#technique-de-normalisation-1"><span class="header-section-number">3.3.3.2</span> Technique de normalisation</a></h4>
<p>Pour passer de la première forme normale à la deuxième, il faut enlever les dépendances partielles. Si une dépendance fonctionnelle existe, il faut enlever les attributs qui sont partiellement dépendants de la relation en les plaçant dans une nouvelle relation avec une copie de leur déterminant.</p>
<p>Voici un exemple:</p>
<p>Nous avons une table avec les attributs <em>teacher_id</em>, <em>subject</em> et <em>teacher_age</em>. La clé primaire est donnée par les attributs <em>teacher_id</em> et <em>subject</em>.</p>
<figure>
<img src="images/1NF_to_2NF.png" alt="Exemple de la normalisation d’une table en 1NF - Première photo" /><figcaption>Exemple de la normalisation d’une table en 1NF - Première photo</figcaption>
</figure>
<p>Comme <em>teacher_age</em> dépend de <em>teacher_id</em> seulement, il n’est pas complètement dépendant de la clé primaire. Nous devons donc séparer la table comme suit:</p>
<figure>
<img src="images/1NF_to_2NF_2nd_image.png" alt="Exemple de la normalisation d’une table en 1NF - Deuxième photo" /><figcaption>Exemple de la normalisation d’une table en 1NF - Deuxième photo</figcaption>
</figure>
</section>
</section>
<section id="deuxième-forme-normale-à-la-troisième-forme-normale" class="level3">
<h3><a href="#deuxième-forme-normale-à-la-troisième-forme-normale"><span class="header-section-number">3.3.4</span> Deuxième forme normale à la troisième forme normale</a></h3>
<p>Dans cette section, nous verrons comment passer de la deuxième forme normale à la troisième forme normale.</p>
<section id="définition-de-la-troisième-forme-normale-3nf" class="level4">
<h4><a href="#définition-de-la-troisième-forme-normale-3nf"><span class="header-section-number">3.3.4.1</span> Définition de la troisième forme normale (3NF)</a></h4>
<p>Une relation qui est dans la première et deuxième forme normale et dans laquelle aucun attribut qui ne fait pas partie de la clé primaire est <em>transitivement dépendant</em> de la clé primaire.</p>
</section>
<section id="technique-de-normalisation-2" class="level4">
<h4><a href="#technique-de-normalisation-2"><span class="header-section-number">3.3.4.2</span> Technique de normalisation</a></h4>
<p>Pour passer de la deuxième forme normale à la troisième, il faut enlever les dépendances transitives. Si une dépendance transitive existe, il faut l’enlever de la relation en mettant l’attribut dans une nouvelle relation avec une copie du déterminant.</p>
<p>Voici un exemple:</p>
<p>Nous avons les attributs <em>emp_id</em>, <em>emp_name</em>, <em>emp_zip</em>, <em>emp_state</em>, <em>emp_city</em> et <em>emp_district</em>. L’attribut <em>emp_id</em> est la clé primaire.</p>
<figure>
<img src="images/2NF_to_3NF.png" alt="Exemple de la normalisation d’une table en 2NF - Première photo" /><figcaption>Exemple de la normalisation d’une table en 2NF - Première photo</figcaption>
</figure>
<p>On remarque que <em>emp_state</em>, <em>emp_city</em> et <em>emp_district</em> sont dépendants de l’attribut <em>emp_zip</em> qui lui-même est dépendant de l’attribut <em>emp_id</em>. Nous avons donc une dépendance transitive. Pour s’en débarrasser, on sépare la table de la façon suivante:</p>
<figure>
<img src="images/2NF_to_3NF_2nd_image.png" alt="Exemple de la normalisation d’une table en 2NF - Deuxième photo" /><figcaption>Exemple de la normalisation d’une table en 2NF - Deuxième photo</figcaption>
</figure>
</section>
</section>
</section>
</section>
<section id="normalisation-avancée" class="level1">
<h1><a href="#normalisation-avancée"><span class="header-section-number">4</span> Normalisation avancée</a></h1>
<p>Ce chapitre traitera de notions de normalisations avancées telles que la <strong>forme normale Boyce-Codd</strong>.</p>
<section id="règles-dinférence-des-dépendances-fonctionnelles" class="level2">
<h2><a href="#règles-dinférence-des-dépendances-fonctionnelles"><span class="header-section-number">4.1</span> Règles d’inférence des dépendances fonctionnelles</a></h2>
<p>Comme il peut y avoir beaucoup de dépendances fonctionnelles, il faut trouver des règles pour nous permettre d’identifier les plus importantes plus facilement. L’ensemble des dépendances fonctionnelles qui sont sous-entendues pour un ensemble de dépendances fonctionnelles <span class="math">\(X\)</span> est appelé la <strong>fermeture</strong> de <span class="math">\(X\)</span>, écrit <span class="math">\(X^+\)</span></p>
<section id="axiomes-darmstrong" class="level3">
<h3><a href="#axiomes-darmstrong"><span class="header-section-number">4.1.1</span> Axiomes d’Armstrong</a></h3>
<p>Les <strong>axiomes d’Armstrong</strong> indiquent comment des dépendances fonctionnelles peuvent être déduites de dépendences données. Soit <span class="math">\(A\)</span>, <span class="math">\(B\)</span>, <span class="math">\(C\)</span>, des sous-ensembles des attributs de la relation <span class="math">\(R\)</span>. Nous avons alors:</p>
<ol type="1">
<li><strong>Réflexivité</strong>: <span class="math">\((B \subset A) \Rightarrow (A \mapsto B)\)</span></li>
<li><strong>Augmentation</strong>: <span class="math">\((A \mapsto B) \Rightarrow (A, C \mapsto B, C)\)</span></li>
<li><strong>Transitivité</strong>: <span class="math">\((A \mapsto B) \land (B \mapsto C) \Rightarrow (A \mapsto C)\)</span></li>
</ol>
<p>Ces règles peuvent être utilisées pour trouver <span class="math">\(X^+\)</span>. D’autres règles peuvent être dérivées des règles précédentes. Soit <span class="math">\(D\)</span>, un autre sous-ensemble des attributs de <span class="math">\(R\)</span>. Nous avons alors:</p>
<ol start="4" type="1">
<li><strong>Autodétermination</strong>: <span class="math">\(A \mapsto A\)</span></li>
<li><strong>Décomposition</strong>: <span class="math">\((A \mapsto B, C) \Rightarrow (A \mapsto B) \land (A \mapsto C)\)</span></li>
<li><strong>Union</strong>: <span class="math">\((A \mapsto B) \land (A \mapsto C) \Rightarrow (A \mapsto B, C)\)</span></li>
<li><strong>Composition</strong>: <span class="math">\((A \mapsto B) \land (C \mapsto D) \Rightarrow (A, C \mapsto B, D)\)</span></li>
</ol>
</section>
<section id="ensembles-minimaux-de-dépendances-fonctionnelles" class="level3">
<h3><a href="#ensembles-minimaux-de-dépendances-fonctionnelles"><span class="header-section-number">4.1.2</span> Ensembles minimaux de dépendances fonctionnelles</a></h3>
<p>Un ensemble de dépendances fonctionnelles <span class="math">\(X\)</span> est minimal s’il satisfait les exigences suivantes:</p>
<ul>
<li>Chaque dépendance de <span class="math">\(X\)</span> a un seul attribut du côté droit.</li>
<li>On ne peut pas remplacer une dépendance <span class="math">\(A \mapsto B\)</span> dans <span class="math">\(X\)</span> avec une dépendance <span class="math">\(C \mapsto B\)</span>, où <span class="math">\(C\)</span> est un sous-ensemble de <span class="math">\(A\)</span>, et avoir un ensemble de dépendences équivalentes à <span class="math">\(X\)</span>.</li>
<li>On ne peut pas pas enlever une dépendance de <span class="math">\(X\)</span> et toujours avoir un ensemble de dépendances équivalent à <span class="math">\(X\)</span>.</li>
</ul>
</section>
</section>
<section id="forme-normale-de-boyce-codd-bcnf" class="level2">
<h2><a href="#forme-normale-de-boyce-codd-bcnf"><span class="header-section-number">4.2</span> Forme normale de Boyce-Codd (BCNF)</a></h2>
<p>Comme la troisième forme normale souffre encore de redondances, il existe une forme normale plus forte appelée la <strong>forme normale de Boyce-Codd</strong>.</p>
<section id="définition-4" class="level3">
<h3><a href="#définition-4"><span class="header-section-number">4.2.1</span> Définition</a></h3>
<p>Une relation est en <strong>forme normale de Boyce-Codd</strong> si et seulement si <em>tous les déterminants</em> sont des <em>clés candidates</em>. Il y a un potentiel de briser la forme normale de Boyce-Codd si une des deux conditions suivantes est respectée:</p>
<ul>
<li>La relation contient deux (ou plus) clés candidates;</li>
<li>Les clés candidates se recoupent, soit qu’elles ont au moins un attribut en commun.</li>
</ul>
</section>
<section id="technique-de-normalisation-3" class="level3">
<h3><a href="#technique-de-normalisation-3"><span class="header-section-number">4.2.2</span> Technique de normalisation</a></h3>
<p>Lorsqu’une dépendance fonctionnelle enfreint les contraintes pour que la relation soit en <em>BCNF</em>, il faut mettre cette dépendance dans une autre table.</p>
</section>
</section>
<section id="dépendance-multi-valuée" class="level2">
<h2><a href="#dépendance-multi-valuée"><span class="header-section-number">4.3</span> Dépendance multi-valuée</a></h2>
<p>L’existence d’une dépendance multi-valuée est dû à la première forme normale qui empêche un attribut dans un tuple d’avoir un ensemble de valeurs.</p>
<section id="définition-5" class="level3">
<h3><a href="#définition-5"><span class="header-section-number">4.3.1</span> Définition</a></h3>
<p>Représente une dépendence entre des attributs (par exemple, <span class="math">\(A\)</span>, <span class="math">\(B\)</span> et <span class="math">\(C\)</span>) dans une relation, tel que pour chaque valeur de <span class="math">\(A\)</span>, il y un ensemble de valeurs <span class="math">\(B\)</span> et un ensemble de valeurs pour <span class="math">\(C\)</span>. Par contre, l’ensemble de valeurs de <span class="math">\(B\)</span> et <span class="math">\(C\)</span> sont indépendants chacun des autres. On dénote une dépendance multi-valuée entre les attributs <span class="math">\(A\)</span>, <span class="math">\(B\)</span> et <span class="math">\(C\)</span> en utilisant la notation suivante:</p>
<p><span class="math">\[A \twoheadrightarrow B\]</span> <span class="math">\[A \twoheadrightarrow C\]</span></p>
</section>
<section id="types-de-dépendances-multi-valuées" class="level3">
<h3><a href="#types-de-dépendances-multi-valuées"><span class="header-section-number">4.3.2</span> Types de dépendances multi-valuées</a></h3>
<p>Une dépendance multi-valuée peut être définie comme <strong>triviale</strong> ou <strong>non-triviale</strong>.</p>
<ul>
<li><strong>Triviale</strong>: Une dépendance multi-valuée est définie comme <strong>triviale</strong> si <span class="math">\((B \subset A) \lor (A \cup B = R)\)</span>.</li>
<li><strong>Non-triviale</strong>: Une dépendance multi-valuée est définie comme <strong>non-triviale</strong> si <span class="math">\(\neg ((B \subset A) \lor (A \cup B = R))\)</span></li>
</ul>
</section>
</section>
<section id="quatrième-forme-normale" class="level2">
<h2><a href="#quatrième-forme-normale"><span class="header-section-number">4.4</span> Quatrième forme normale</a></h2>
<p>La <strong>quatrième forme normale</strong> vient corriger les problèmes que les dépendances multi-valuées apportent.</p>
<section id="définition-6" class="level3">
<h3><a href="#définition-6"><span class="header-section-number">4.4.1</span> Définition</a></h3>
<p>Une relation est dans la <strong>quatrième forme normale</strong> si et seulement si pour toutes les dépendences multi-valuées non-triviales <span class="math">\(A \twoheadrightarrow B\)</span>, <span class="math">\(A\)</span> est une clé candidate de la relation.</p>
</section>
<section id="technique-de-normalisation-4" class="level3">
<h3><a href="#technique-de-normalisation-4"><span class="header-section-number">4.4.2</span> Technique de normalisation</a></h3>
<p>Il faut enlever la dépendance multi-valuée de la relation en plaçant les attributs multi-valués dans une nouvelle relation avec une copie du déterminant.</p>
</section>
</section>
</section>
<section id="algèbre-relationnelle" class="level1">
<h1><a href="#algèbre-relationnelle"><span class="header-section-number">5</span> Algèbre relationnelle</a></h1>
<p>Dans ce chapitre, nous verrons l’algèbre relationnelle et son utilité.</p>
<section id="définition-7" class="level2">
<h2><a href="#définition-7"><span class="header-section-number">5.1</span> Définition</a></h2>
<p>L’<strong>algèbre relationnelle</strong> est un langage théorique avec des opérations qui marchent sur une ou plusieurs relations pour définir une autre relation sans changer la relation originale.</p>
<p>Comme à la fois les opérandes et les résultats sont des relations, le résultat d’une opération peut être passer en paramètre à une autre opération. Cela permet aux expressions d’être imbriquées. Cette propriété s’appelle <strong>fermeture</strong>.</p>
</section>
<section id="opérations" class="level2">
<h2><a href="#opérations"><span class="header-section-number">5.2</span> Opérations</a></h2>
<p>L’algèbre relationnelle supporte plusieurs opérations. Dans cette section, nous allons définir différents types d’opérations. Dans ces définitions, nous avons <span class="math">\(R\)</span> et <span class="math">\(S\)</span>, deux relations définies par les attributs <span class="math">\(A = (a_1, a_2, \dots, a_N)\)</span> et <span class="math">\(B = (b_1, b_2, \dots, b_M)\)</span> respectivement.</p>
<section id="opérations-unaires" class="level3">
<h3><a href="#opérations-unaires"><span class="header-section-number">5.2.1</span> Opérations unaires</a></h3>
<p>L’algèbre relationnelle possède deux opérations unaires: la <strong>sélection</strong> et la <strong>projection</strong>.</p>
<section id="sélection-ou-restriction" class="level4">
<h4><a href="#sélection-ou-restriction"><span class="header-section-number">5.2.1.1</span> Sélection (ou restriction)</a></h4>
<p>La <strong>sélection</strong> s’applique sur une seule relation <span class="math">\(R\)</span> et définit une relation qui contient seulement les tuples de <span class="math">\(R\)</span> qui satisfont la condition spécifée (le <em>prédicat</em>).</p>
<p>On l’écrit</p>
<p><span class="math">\[
  \sigma_{prédicat}(R)
\]</span></p>
<p>où <span class="math">\(\sigma\)</span> est le nom de l’opération, <span class="math">\(prédicat\)</span> est le prédicat à respecter et <span class="math">\(R\)</span> est la relation sur laquelle l’opération est appliquée.</p>
<p>La sélection s’applique à l’horizontal dans une table.</p>
</section>
<section id="projection" class="level4">
<h4><a href="#projection"><span class="header-section-number">5.2.1.2</span> Projection</a></h4>
<p>La <strong>projection</strong> s’applique sur une seule relation <span class="math">\(R\)</span> et définie une relation qui contient un sous-ensemble vertical de <span class="math">\(R\)</span>. Elle extrait les valeurs des attributs spécifiés et élimine les duplicats.</p>
<p>On l’écrit</p>
<p><span class="math">\[
  \Pi_{a_1, \dots, a_n}(R)
\]</span></p>
<p>où <span class="math">\(\Pi\)</span> dénote le nom de l’opération, <span class="math">\(a_1, \dots, a_n\)</span> est le nom de chacun des attributs spécifiés et <span class="math">\(R\)</span> est la relation sur laquelle l’opération est appliquée.</p>
<p>La sélection s’applique à la vertical dans une table.</p>
</section>
</section>
<section id="opérations-binaires" class="level3">
<h3><a href="#opérations-binaires"><span class="header-section-number">5.2.2</span> Opérations binaires</a></h3>
<p>Il y a des cas où nous voulons extraire les informations de plusieurs relations à la fois. Les opérations binaires permettent de combiner les informations de deux relations à la fois.</p>
<section id="union" class="level4">
<h4><a href="#union"><span class="header-section-number">5.2.2.1</span> Union</a></h4>
<p>L’<strong>union</strong> de deux relations <span class="math">\(R\)</span> et <span class="math">\(S\)</span> définit une relation qui contient tous les tuples de <span class="math">\(R\)</span> ou de <span class="math">\(S\)</span> ou bien des deux relations. Les tuples copies sont éliminés. <span class="math">\(R\)</span> et <span class="math">\(S\)</span> doivent être compatibles à l’union.</p>
<p>On l’écrit</p>
<p><span class="math">\[
  R \cup S
\]</span></p>
<p>où <span class="math">\(R\)</span> et <span class="math">\(S\)</span> sont deux relations.</p>
</section>
<section id="différence" class="level4">
<h4><a href="#différence"><span class="header-section-number">5.2.2.2</span> Différence</a></h4>
<p>La <strong>différence</strong> définit une relation qui consiste des tuples qui sont dans la relation <span class="math">\(R\)</span>, mais pas dans la relation <span class="math">\(S\)</span>. <span class="math">\(R\)</span> et <span class="math">\(S\)</span> doivent être compatibles à l’union.</p>
<p>On l’écrit</p>
<p><span class="math">\[
  R - S
\]</span></p>
<p>où <span class="math">\(R\)</span> et <span class="math">\(S\)</span> sont deux ensembles.</p>
</section>
<section id="intersection" class="level4">
<h4><a href="#intersection"><span class="header-section-number">5.2.2.3</span> Intersection</a></h4>
<p><strong>L’intersection</strong> définit une relation consistant de l’ensemble de tous les tuples qui sont à la fois dans <span class="math">\(R\)</span> et <span class="math">\(S\)</span>. <span class="math">\(R\)</span> et <span class="math">\(S\)</span> doivent être compatibles à l’union.</p>
<p>On l’écrit</p>
<p><span class="math">\[
  R \cap S \iff R - (R - S)
\]</span></p>
<p>où <span class="math">\(R\)</span> et <span class="math">\(S\)</span> sont des relations.</p>
</section>
<section id="produit-cartésien" class="level4">
<h4><a href="#produit-cartésien"><span class="header-section-number">5.2.2.4</span> Produit cartésien</a></h4>
<p>Le <strong>produit cartésien</strong> définit une relation qui est la concaténation de tous les tuples de la relation <span class="math">\(R\)</span> avec tous les tuples de la relation <span class="math">\(S\)</span>.</p>
<p>On l’écrit</p>
<p><span class="math">\[
  R \times S
\]</span></p>
<p>où <span class="math">\(R\)</span> et <span class="math">\(S\)</span> sont des relations.</p>
</section>
<section id="décomposition-dopérations-complexes" class="level4">
<h4><a href="#décomposition-dopérations-complexes"><span class="header-section-number">5.2.2.5</span> Décomposition d’opérations complexes</a></h4>
<p>La <strong>décomposition d’opérations complexes</strong> donne un nouveau nom à <span class="math">\(S\)</span> pour l’expression <span class="math">\(E\)</span>, et nomme optionnellement les attributs en <span class="math">\(a_1, a_2, \dots, a_n\)</span>.</p>
<p>On l’écrit</p>
<p><span class="math">\[
  \rho_{s}(E) \text{ ou } \rho_{s_{(a_1, a_2, \dots, a_n)}}(E)
\]</span></p>
</section>
</section>
<section id="opérations-de-jointure" class="level3">
<h3><a href="#opérations-de-jointure"><span class="header-section-number">5.2.3</span> Opérations de jointure</a></h3>
<p>Les <strong>opérations de jointure</strong> sont parmies les opérations les plus utiles de l’algèbre relationnelle. Les opérations de jointure sont équivalents à appliquer l’opération de sélection avec le prédicat de jointure au résultat du produit cartésien des deux relations d’entrée. De manière plus symbolique, si on a <span class="math">\(F\)</span> comme prédicat de jointure et <span class="math">\(R\)</span> ainsi que <span class="math">\(S\)</span>, deux relations, nous avons que l’opération de jointure peut être définie comme:</p>
<p><span class="math">\[
  \sigma_{F}(R \times S)
\]</span></p>
<p>Les types d’opérations de jointure sont les suivants:</p>
<ul>
<li><strong>Jointure <em>theta</em></strong> ou <strong>(<span class="math">\(\theta\)</span>-join)</strong></li>
<li><strong>Equijointure</strong></li>
<li><strong>Jointure naturelle</strong></li>
<li><strong>Jointure externe</strong></li>
<li><strong>Semi-jointure</strong></li>
</ul>
<section id="jointure-theta-theta-join" class="level4">
<h4><a href="#jointure-theta-theta-join"><span class="header-section-number">5.2.3.1</span> Jointure theta (<span class="math">\(\theta\)</span>-join)</a></h4>
<p>L’opération de <strong>jointure theta</strong> définit une relation qui contient les tuples satisfants le prédicat <span class="math">\(F\)</span> à partir du résultat du produit cartésien de <span class="math">\(R\)</span> et <span class="math">\(S\)</span>. Le prédicat <span class="math">\(F\)</span> est de la forme <span class="math">\(R.a_i~\theta~S.b_i\)</span> où <span class="math">\(\theta\)</span> peut être un des opérateur de comparaison (<span class="math">\(&lt; \)</span>, <span class="math">\(\leq\)</span>, <span class="math">\(&gt;\)</span>, <span class="math">\(\geq\)</span>, <span class="math">\(=\)</span>, <span class="math">\(\neq\)</span>).</p>
<p>On l’écrit</p>
<p><span class="math">\[
  R \bowtie_{F} S \iff \sigma_{F}(R \times S)
\]</span></p>
<p>où <span class="math">\(F\)</span> est le prédicat et <span class="math">\(R\)</span> ainsi que <span class="math">\(S\)</span> sont des relations.</p>
</section>
<section id="equijointure" class="level4">
<h4><a href="#equijointure"><span class="header-section-number">5.2.3.2</span> Equijointure</a></h4>
<p>L’<strong>equijointure</strong> est un cas particulier de <span class="math">\(\theta\)</span>-join. C’est le cas où le prédicat <span class="math">\(F\)</span> contient seulement l’égalité (<span class="math">\(=\)</span>).</p>
<section id="exemple-dequijointure" class="level5">
<h5><a href="#exemple-dequijointure"><span class="header-section-number">5.2.3.2.1</span> Exemple d’equijointure</a></h5>
<p>Nous souhaitons lister les noms et les commentaires de tous les clients qui ont vus une propriété à louer:</p>
<p><span class="math">\[
    (\Pi_{\mathrm{numClient},~\mathrm{prenom},~\mathrm{nom}}(\mathrm{Client})) \bowtie_{\mathrm{Client}.\mathrm{numClient}~=~\mathrm{Visite}.\mathrm{numClient}} (\Pi_{\mathrm{numClient},~\mathrm{numPropriete},~\mathrm{commentaire}}(\mathrm{Visite}))
\]</span></p>
</section>
</section>
<section id="jointure-naturelle" class="level4">
<h4><a href="#jointure-naturelle"><span class="header-section-number">5.2.3.3</span> Jointure naturelle</a></h4>
<p>La <strong>jointure naturelle</strong> est une equijointure des deux relations <span class="math">\(R\)</span> et <span class="math">\(S\)</span> sur tous leurs attributs communs <span class="math">\(x\)</span>. Une occurence de chacun des attributs communs est enlevée des résultats.</p>
<p>On l’écrit</p>
<p><span class="math">\[
  R \bowtie S
\]</span></p>
<p>où <span class="math">\(R\)</span> et <span class="math">\(S\)</span> sont des relations.</p>
<section id="exemple-de-jointure-naturelle" class="level5">
<h5><a href="#exemple-de-jointure-naturelle"><span class="header-section-number">5.2.3.3.1</span> Exemple de jointure naturelle</a></h5>
<p>Nous souhaitons énumérer les noms et les commentaires de tous les clients qui ont visité une propriété à louer:</p>
<p><span class="math">\[
    (\Pi_{\mathrm{numClient},~\mathrm{prenom},~\mathrm{nom}}(\mathrm{Client})) \bowtie (\Pi_{\mathrm{numClient},~\mathrm{numPropriete},~\mathrm{commentaire}}(\mathrm{Visite}))
\]</span></p>
</section>
</section>
<section id="jointure-externe" class="level4">
<h4><a href="#jointure-externe"><span class="header-section-number">5.2.3.4</span> Jointure externe</a></h4>
<p>La <strong>jointure externe</strong> (gauche) est une jointure dans laquelle les tuples de <span class="math">\(R\)</span> qui n’ont pas de valeurs correspondantes avec les attributs en commun avec <span class="math">\(S\)</span> ne sont pas inclus dans la relation résultante. Les valeurs manquantes dans la deuxième relation sont mises à <em>null</em>.</p>
<p>On l’écrit</p>
<p><span class="math">\[
\begin{align*}
  &amp;R \rtimes S \text{ (Jointure externe gauche) }
  \\
  &amp;R \ltimes S \text{ (Jointure externe droite) }
\end{align*}
\]</span></p>
<section id="exemple-de-jointure-externe" class="level5">
<h5><a href="#exemple-de-jointure-externe"><span class="header-section-number">5.2.3.4.1</span> Exemple de jointure externe</a></h5>
<p>Nous souhaitons produire un rapport d’état des visites de propriétés à louer:</p>
<p><span class="math">\[
    (\Pi_{\mathrm{numPropriete},~\mathrm{rue},~\mathrm{ville}}(\mathrm{ProprieteALouer})) \rtimes~\mathrm{Visite}
\]</span></p>
</section>
</section>
<section id="semi-jointure" class="level4">
<h4><a href="#semi-jointure"><span class="header-section-number">5.2.3.5</span> Semi-jointure</a></h4>
<p>La <strong>semi-jointure</strong> définit une relation qui contient les tuples de <span class="math">\(R\)</span> qui participent dans la jointure de <span class="math">\(R\)</span> avec <span class="math">\(S\)</span> satisfaisant le prédicat <span class="math">\(F\)</span>.</p>
<p>On l’écrit</p>
<p><span class="math">\[
  R \triangleright_{F} S \iff \Pi_{A}(R \bowtie_{F} S)
\]</span></p>
<p>où <span class="math">\(A\)</span> est l’ensemble de tous les attributs de <span class="math">\(R\)</span>.</p>
<section id="exemple-de-semi-jointure" class="level5">
<h5><a href="#exemple-de-semi-jointure"><span class="header-section-number">5.2.3.5.1</span> Exemple de semi-jointure</a></h5>
<p>On souhaite énumérer les détails complets de tous les membres du personnel qui travaillent à la filiale de Montréal:</p>
<p><span class="math">\[
    \mathrm{Personnel}~\triangleright_{\mathrm{Personnel}.\mathrm{numFiliale}~=~\mathrm{Filiale}.\mathrm{numFiliale}}~(\sigma_{\mathrm{Filiale}.\mathrm{ville}~=~&#39;\mathrm{Montreal}&#39;}(\mathrm{Filiale}))
\]</span></p>
</section>
</section>
</section>
<section id="division" class="level3">
<h3><a href="#division"><span class="header-section-number">5.2.4</span> Division</a></h3>
<p>Assumons que la relation <span class="math">\(R\)</span> est définie à partir de l’ensemble d’attributs <span class="math">\(A\)</span> et que la relation <span class="math">\(S\)</span> est définie à partir de l’ensemble d’attributs <span class="math">\(B\)</span> tel que <span class="math">\(B \subseteq A\)</span>. Soit <span class="math">\(C = A - B\)</span>, c’est-à-dire <span class="math">\(C\)</span> est l’ensemble des attributs de <span class="math">\(R\)</span> qui ne sont pas des attributs de <span class="math">\(S\)</span>. Alors, l’opération de division définit une relation à partir des attributs <span class="math">\(C\)</span> qui consiste à l’ensemble des tuples de <span class="math">\(R\)</span> qui concordent avec <em>tous</em> les tuples de <span class="math">\(S\)</span>.</p>
<p>On l’écrit</p>
<p><span class="math">\[
  R \div S
\]</span></p>
<p>que l’on peut aussi réécrire comme</p>
<p><span class="math">\[
\begin{align*}
  T_1~ &amp;\gets ~\Pi_{C}(R)
  \\
  T_2~ &amp;\gets ~\Pi_{C}((T_1 \times S) - R)
  \\
  T~ &amp;\gets ~T_{1} - T_{2}
\end{align*}
\]</span></p>
<section id="exemple-de-division" class="level4">
<h4><a href="#exemple-de-division"><span class="header-section-number">5.2.4.1</span> Exemple de division</a></h4>
<p>On souhaite identifier tous les clients qui ont visité toutes les propriétés de trois pièces:</p>
<p><span class="math">\[
    (\Pi_{\mathrm{numClient},~\mathrm{numPropriete}}(\mathrm{Visite})) \div (\Pi_{\mathrm{numPropriete}}(\sigma_{\mathrm{piece}~=~3}(\mathrm{ProprieteALouer})))
\]</span></p>
</section>
</section>
<section id="agrégation" class="level3">
<h3><a href="#agrégation"><span class="header-section-number">5.2.5</span> Agrégation</a></h3>
<p>Applique la liste des fonctions agrégates, <span class="math">\(AL\)</span>, à la relation <span class="math">\(R\)</span> pour définir une relation à partir de la liste agrégate. <span class="math">\(AL\)</span> contient une paire (<span class="math">\(\langle \text{ fonction_agrégate } \rangle , \langle \text{ attribut } \rangle\)</span> ou plus.</p>
<p>On l’écrit</p>
<p><span class="math">\[
  \Im_{AL} (R)
\]</span></p>
<p>Les principales fonctions agrégates sont les suivantes:</p>
<ul>
<li><em>COUNT</em>: Retourne le nombre de valeurs de l’attribut associé.</li>
<li><em>SUM</em>: Retourne la somme des valeurs de l’attribut associé.</li>
<li><em>AVG</em>: Retourne la moyenne des valeurs de l’attribut associé.</li>
<li><em>MIN</em>: Retourne la plus petite valeur de l’attribut associé.</li>
<li><em>MAX</em>: Retourne la plus grande valeur de l’attribut associé.</li>
</ul>
<section id="exemple-dagrégation" class="level4">
<h4><a href="#exemple-dagrégation"><span class="header-section-number">5.2.5.1</span> Exemple d’agrégation</a></h4>
<p>On souhaite trouver le salaire minimum, maximum et moyen des employés:</p>
<p><span class="math">\[
    \rho_{R}(\mathrm{monMin},~\mathrm{monMax},~\mathrm{maMoyenne})~\Im_{\mathrm{MIN}~\mathrm{salaire},~\mathrm{MAX}~\mathrm{salaire},~\mathrm{AVG}~\mathrm{salaire}}(\mathrm{Personnel})
\]</span></p>
</section>
</section>
<section id="regroupement" class="level3">
<h3><a href="#regroupement"><span class="header-section-number">5.2.6</span> Regroupement</a></h3>
<p>Groupe les tuples de la relation <span class="math">\(R\)</span> par les attributs de groupement, <span class="math">\(GA\)</span>, et applique ensuite la liste de fonctions agrégates <span class="math">\(AL\)</span> pour définir une nouvelle relation. <span class="math">\(AL\)</span> contient une paire (<span class="math">\(\langle \text{ fonction_agrégate } \rangle , \langle \text{ attribut } \rangle\)</span> ou plus. La relation résultante contient les attributs de groupement <span class="math">\(GA\)</span> avec le résultat de chacune des fonctions agrégates.</p>
<p>On l’écrit</p>
<p><span class="math">\[
 {}_{GA}\Im_{AL}(R)
\]</span></p>
<p>La forme générale de l’opération de regroupement est la suivante:</p>
<p><span class="math">\[
  {}_{a_1, a_2, \dots, a_n}\Im_{\langle A_p a_p \rangle, \langle A_q a_q \rangle, \dots, \langle A_z a_z \rangle}(R)
\]</span></p>
<p>où <span class="math">\(R\)</span> est une relation quelconque, <span class="math">\(a_1, a_2, \dots, a_n\)</span> sont des attributs de <span class="math">\(R\)</span>, <span class="math">\(a_p, a_q, \dots, a_z\)</span> sont d’autres attributs de <span class="math">\(R\)</span> et <span class="math">\(A_p, A_q, \dots, A_z\)</span> sont des fonctions agrégates. Les tuples de <span class="math">\(R\)</span> sont partitionnés de sorte que:</p>
<ul>
<li>tous les tuples dans un groupe on la même valeur pour <span class="math">\(a_1, a_2, \dots, a_n\)</span>;</li>
<li>les tuples dans différents groupes ont des valeurs différentes pour <span class="math">\(a_1, a_2, \dots, a_n\)</span>.</li>
</ul>
<section id="exemple-de-regroupement" class="level4">
<h4><a href="#exemple-de-regroupement"><span class="header-section-number">5.2.6.1</span> Exemple de regroupement</a></h4>
<p>Nous souhaitons trouver le nombre d’employés qui travaillent dans chaque filiale et calculer la somme de leurs salaires:</p>
<p><span class="math">\[
    \rho_{R}(\mathrm{numFiliale},~\mathrm{monCompte},~\mathrm{maSomme}) {}_{\mathrm{numFiliale}}\Im_{\mathrm{COUNT}~\mathrm{numPersonnel},~\mathrm{SUM}~\mathrm{salaire}}(\mathrm{Personnel})
\]</span></p>
</section>
</section>
</section>
</section>
<section id="structured-query-language-sql-manipulation-des-données" class="level1">
<h1><a href="#structured-query-language-sql-manipulation-des-données"><span class="header-section-number">6</span> Structured Query Language (SQL) : Manipulation des données</a></h1>
<p>Dans ce chapitre, nous aborderons des notions sur le <strong>Structured Query Language</strong> ou <strong>SQL</strong>.</p>
<section id="objectifs-du-sql" class="level2">
<h2><a href="#objectifs-du-sql"><span class="header-section-number">6.1</span> Objectifs du SQL</a></h2>
<p>Idéalement, un langage de bases de données devrait permettre de</p>
<ul>
<li>créer la base de données et les structures des relations</li>
<li>faire des opérations de gestion de données telles que l’insertion, la modification and la supression de données des relations</li>
<li>faire des requêtes à la fois simples et complexes</li>
</ul>
<p>Le langage doit être simple; sa syntaxe et sa structure de commandes doivent être simples à apprendre. Le langage doit aussi être portable, c’est-à-dire qu’il doit être conforme à des standards pour que nous puissions utiliser les mêmes commandes d’un système de gestion de bases de données à un autre.</p>
</section>
<section id="informations-sur-le-sql" class="level2">
<h2><a href="#informations-sur-le-sql"><span class="header-section-number">6.2</span> Informations sur le SQL</a></h2>
<p>Le SQL est un <strong>langage orienté transformation</strong> ce qui veut dire que c’est un langage qui a été développé pour utiliser des relations pour transformer des entrées en des sorties demandées. Le SQL possède deux parties majeurs:</p>
<ul>
<li>Un <strong>langage de définition des données (DDL)</strong> pour définir la structure de la base de données et contrôler l’accès aux données.</li>
<li>Un <strong>langage de manipulation des données (DML)</strong> pour aller chercher et mettre à jour les données.</li>
</ul>
<p>Le SQL est un langage qui n’est pas procédural. Nous spécifions les données dont nous avons besoin plutôt que comment aller les chercher. Autrement dit, nous n’avons pas à nous occuper des méthodes d’accès aux données: SQL le fait pour nous.</p>
<section id="terminalogie" class="level3">
<h3><a href="#terminalogie"><span class="header-section-number">6.2.1</span> Terminalogie</a></h3>
<p>Les standards ISO du SQL n’utilisent pas les termes formels <em>relations</em>, <em>attributs</em> et <em>tuples</em>. Ils utilisent plutôt les mots <em>tables</em>, <em>colonnes</em> et <em>rangées</em>.</p>
</section>
</section>
<section id="écrire-des-commandes-sql" class="level2">
<h2><a href="#écrire-des-commandes-sql"><span class="header-section-number">6.3</span> Écrire des commandes SQL</a></h2>
<p>Une déclaration SQL consiste de <strong>mots réservés</strong> et <strong>de mots définis par l’utilisateur</strong>. Les mots réservés font partis du langage et ont un sens fixes alors que les mots définis par l’utilisateur font références à des objets de la base de données comme les tables, colonnes, vues, indexes, etc. Les déclarations SQL ne sont pas sensibles à la casse. La seule exception est que les caractères litéraux doivent être écrits comme ils apparaissent dans la base de données.</p>
<section id="convention-de-code" class="level3">
<h3><a href="#convention-de-code"><span class="header-section-number">6.3.1</span> Convention de code</a></h3>
<p>La convention du cours utilise en partie la <strong>forme de Backus Naur (BNF)</strong>. La convention que nous allons utiliser est donc la suivante:</p>
<ul>
<li>les mots réservés sont écrits en minuscules;</li>
<li>les mots définis par l’utilisateur sont en majuscules;</li>
<li>la bar vertical (<span class="math">\(|\)</span>) indique un choix parmi des alternatives;</li>
<li>les accolades indiquent un élément requis;</li>
<li>les crochets indiquent un élément optionnel;</li>
<li>les points de suspension indique une répétition optionnelle d’un objet zéro ou plusieurs fois.</li>
</ul>
</section>
<section id="manipulation-des-données" class="level3">
<h3><a href="#manipulation-des-données"><span class="header-section-number">6.3.2</span> Manipulation des données</a></h3>
<p>Cette section traite des différentes expressions du DML du SQL:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> <span class="co">-- pour aller chercher des données dans la base de données</span>
    <span class="kw">insert</span> <span class="co">-- pour insérer des données dans une table</span>
    <span class="kw">update</span> <span class="co">-- pour mettre à jour des données dans une table</span>
    <span class="kw">delete</span> <span class="co">-- pour effacer des données d&#39;une table</span></code></pre>
<p>Pour les explications des expressions, nous allons utiliser les tables suivantes:</p>
<table>
<caption>Cas d’étude <em>DreamHome</em></caption>
<tbody>
<tr class="odd">
<td style="text-align: left;">Branch</td>
<td style="text-align: left;">(<strong>Branch</strong>, street, city, postcode)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Staff</td>
<td style="text-align: left;">(<strong>staffNo</strong>, fName, lName, position, sex, DOB, salary, branchNo)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">PropertyForRent</td>
<td style="text-align: left;">(<strong>propertyNo</strong>, street, city, postcode, type, rooms, rent,</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">ownerNo, staffNo, branchNo)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Client</td>
<td style="text-align: left;">(<strong>clientNo</strong>, fName, lName, telNo, prefType, maxRent, eMail)</td>
</tr>
<tr class="even">
<td style="text-align: left;">PrivateOwner</td>
<td style="text-align: left;">(<strong>ownerNo</strong>, fName, lName, address, telNo, eMail, password)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Viewing</td>
<td style="text-align: left;">(<strong>clientNo</strong>, propertyNo, viewDate, comment)</td>
</tr>
</tbody>
</table>
</section>
<section id="litéraux" class="level3">
<h3><a href="#litéraux"><span class="header-section-number">6.3.3</span> Litéraux</a></h3>
<p>Les litéraux sont des constantes qui sont utilisées dans des expressions SQL. Les chaines de caractères litérales doivent être entourées de guillemets simples et les litéraux numériques ne doivent pas avoir de guillemets.</p>
<p>Un exemple d’insertion de litéraux dans une table pourrait ressembler à</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">insert</span> <span class="kw">into</span> PropertyForRent(propertyNo, street, city, postcode, <span class="kw">type</span>, 
                                rooms, rent, ownerNo, staffNo, branchNo)
    <span class="kw">values</span> (<span class="st">&#39;PA14&#39;</span>, <span class="st">&#39;16 Holhead&#39;</span>, <span class="st">&#39;Aberdeen&#39;</span>, <span class="st">&#39;AB7 5SU&#39;</span>, <span class="st">&#39;House&#39;</span>, <span class="dv">6</span>, <span class="fl">650.00</span>,
            <span class="st">&#39;CO46&#39;</span>, <span class="st">&#39;SA9&#39;</span>, <span class="st">&#39;B007&#39;</span>);</code></pre>
</section>
<section id="select" class="level3">
<h3><a href="#select"><span class="header-section-number">6.3.4</span> SELECT</a></h3>
<p>L’expression <code>select</code> est utilisé pour aller chercher et afficher des données d’une ou plusieurs tables de bases de données. Elle permet de faire l’équivalent des opérations de <em>sélection</em>, <em>projecture</em> et de <em>jointure</em> de l’algèbre relationnelle.</p>
<p>L’expression <code>select</code> a la forme suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span>      [<span class="kw">distinct</span> | <span class="kw">all</span>] {* | [columnExpression [<span class="kw">as</span> newName]] [,...]}
    <span class="kw">from</span>        TableName [alias] [,...]
    [<span class="kw">where</span>      condition]
    [<span class="kw">group</span> <span class="kw">by</span>   columnList] [<span class="kw">having</span> condition]
    [<span class="kw">order</span> <span class="kw">by</span>   columnList]</code></pre>
<p>où chacune des expressions a la signification suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">from</span>        <span class="co">-- Table(s) à utiliser</span>
    <span class="kw">where</span>       <span class="co">-- Filtre rangées selon une condition</span>
    <span class="kw">group</span> <span class="kw">by</span>    <span class="co">-- Forme des groupes de rangées avec des mêmes valeurs de colonnes</span>
    <span class="kw">having</span>      <span class="co">-- Filtre les groupes selon une condition</span>
    <span class="kw">select</span>      <span class="co">-- Spécifie les colonnes qui vont apparaître dans la sortie</span>
    <span class="kw">order</span> <span class="kw">by</span>    <span class="co">-- Spécifie l&#39;ordre d&#39;affichage</span></code></pre>
<p>Il est important de retenir que l’ordre des clauses de l’expression <code>select</code> ne peut être changé et que les deux seules clauses obligatoires sont les deux premières: <code>select</code> et <code>from</code>. Les autres clauses sont optionnelles. Le résultat d’une expression <code>select</code> est une autre table.</p>
<p>L’expression <code>select</code> ne peut seulement contenir que:</p>
<ul>
<li>des noms de colonnes;</li>
<li>des fonctions agrégates;</li>
<li>des constantes;</li>
<li>une expression combinant les points précédents.</li>
</ul>
<section id="exemples-dutilisation-du-select" class="level4">
<h4><a href="#exemples-dutilisation-du-select"><span class="header-section-number">6.3.4.1</span> Exemples d’utilisation du SELECT</a></h4>
<p>Dans tous les exemples suivants, nous allons nous servir de la table <em>DreamHome</em>.</p>
<section id="aller-chercher-toutes-les-colonnes-et-rangées" class="level5">
<h5><a href="#aller-chercher-toutes-les-colonnes-et-rangées"><span class="header-section-number">6.3.4.1.1</span> Aller chercher toutes les colonnes et rangées</a></h5>
<p>Nous voulons aller chercher toutes les informations sur le personnel.</p>
<p>Comme il n’y a pas de conditions, nous n’avons pas besoin d’un <code>where</code>. Nous pouvons donc écrire cette requête comme</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, position, sex, DOB, salary, branchNo
    <span class="kw">from</span> Staff;</code></pre>
<p>Comme nous sélectionnons toutes les colonnes, nous pourrions réécrire cette requête comme</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> *
    <span class="kw">from</span> Staff;</code></pre>
<p>Nous obtiendrons la table suivante:</p>
<table>
<caption>Résultat de la requête</caption>
<thead>
<tr class="header">
<th style="text-align: left;">staffNo</th>
<th style="text-align: left;">fName</th>
<th style="text-align: left;">lName</th>
<th style="text-align: left;">position</th>
<th style="text-align: left;">sex</th>
<th style="text-align: left;">DOB</th>
<th style="text-align: left;">salary</th>
<th style="text-align: left;">branchNo</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">SL21</td>
<td style="text-align: left;">John</td>
<td style="text-align: left;">White</td>
<td style="text-align: left;">Manager</td>
<td style="text-align: left;">M</td>
<td style="text-align: left;">1-Oct-45</td>
<td style="text-align: left;">30000.00</td>
<td style="text-align: left;">B005</td>
</tr>
<tr class="even">
<td style="text-align: left;">SG37</td>
<td style="text-align: left;">Ann</td>
<td style="text-align: left;">Beech</td>
<td style="text-align: left;">Assistant</td>
<td style="text-align: left;">F</td>
<td style="text-align: left;">10-Nov-60</td>
<td style="text-align: left;">12000.00</td>
<td style="text-align: left;">B003</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SG14</td>
<td style="text-align: left;">David</td>
<td style="text-align: left;">Ford</td>
<td style="text-align: left;">Supervisor</td>
<td style="text-align: left;">M</td>
<td style="text-align: left;">24-Mar-58</td>
<td style="text-align: left;">18000.00</td>
<td style="text-align: left;">B003</td>
</tr>
<tr class="even">
<td style="text-align: left;">SA9</td>
<td style="text-align: left;">Mary</td>
<td style="text-align: left;">Howe</td>
<td style="text-align: left;">Assistant</td>
<td style="text-align: left;">F</td>
<td style="text-align: left;">19-Feb-70</td>
<td style="text-align: left;">9000.00</td>
<td style="text-align: left;">B007</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SG5</td>
<td style="text-align: left;">Susan</td>
<td style="text-align: left;">Brand</td>
<td style="text-align: left;">Manager</td>
<td style="text-align: left;">F</td>
<td style="text-align: left;">3-Jun-40</td>
<td style="text-align: left;">24000.00</td>
<td style="text-align: left;">B003</td>
</tr>
<tr class="even">
<td style="text-align: left;">SL41</td>
<td style="text-align: left;">Julie</td>
<td style="text-align: left;">Lee</td>
<td style="text-align: left;">Assistant</td>
<td style="text-align: left;">F</td>
<td style="text-align: left;">13-Jun-65</td>
<td style="text-align: left;">9000.00</td>
<td style="text-align: left;">B005</td>
</tr>
</tbody>
</table>
</section>
<section id="aller-chercher-des-colonnes-spécifiques-et-toutes-les-rangées" class="level5">
<h5><a href="#aller-chercher-des-colonnes-spécifiques-et-toutes-les-rangées"><span class="header-section-number">6.3.4.1.2</span> Aller chercher des colonnes spécifiques et toutes les rangées</a></h5>
<p>On veut la liste des salaires de tous les employés en montrant seulement les numéros d’employés, les prénoms, les noms de famille et les détails du salaire.</p>
<p>Cette requête serait écrite comme</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, salary
    <span class="kw">from</span> Staff;</code></pre>
<p>Ce qui nous donnerait la table suivante:</p>
<table>
<caption>Résultat de la requête</caption>
<thead>
<tr class="header">
<th style="text-align: left;">staffNo</th>
<th style="text-align: left;">fName</th>
<th style="text-align: left;">lName</th>
<th style="text-align: left;">salary</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">SL21</td>
<td style="text-align: left;">John</td>
<td style="text-align: left;">White</td>
<td style="text-align: left;">30000.00</td>
</tr>
<tr class="even">
<td style="text-align: left;">SG37</td>
<td style="text-align: left;">Ann</td>
<td style="text-align: left;">Beech</td>
<td style="text-align: left;">12000.00</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SG14</td>
<td style="text-align: left;">David</td>
<td style="text-align: left;">Ford</td>
<td style="text-align: left;">18000.00</td>
</tr>
<tr class="even">
<td style="text-align: left;">SA9</td>
<td style="text-align: left;">Mary</td>
<td style="text-align: left;">Howe</td>
<td style="text-align: left;">9000.00</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SG5</td>
<td style="text-align: left;">Susan</td>
<td style="text-align: left;">Brand</td>
<td style="text-align: left;">24000.00</td>
</tr>
<tr class="even">
<td style="text-align: left;">SL41</td>
<td style="text-align: left;">Julie</td>
<td style="text-align: left;">Lee</td>
<td style="text-align: left;">9000.00</td>
</tr>
</tbody>
</table>
</section>
<section id="utiliser-distinct" class="level5">
<h5><a href="#utiliser-distinct"><span class="header-section-number">6.3.4.1.3</span> Utiliser DISTINCT</a></h5>
<p>Lorsqu’on fait un <code>select</code> sur une table, les copies sont conservés. Le mot clé <code>distinct</code> permet d’éliminer les copies. Par exemple,</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> <span class="kw">distinct</span> propertyNo
    <span class="kw">from</span> Viewing;</code></pre>
<p>va seulement retourner un seul numéro de propriété par copie.</p>
</section>
<section id="champs-calculés" class="level5">
<h5><a href="#champs-calculés"><span class="header-section-number">6.3.4.1.4</span> Champs calculés</a></h5>
<p>Nous voulons avoir la liste de tous les salaires mensuels de tous les employés, montrer les numéros d’employé, les prénoms, les noms de famille et les détails des salaires.</p>
<p>Il est possible d’ajouter des opérations arithmétiques à des expressions SQL. Ainsi, pour construire la requête demandée, nous pourrions écrire</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, salary/<span class="dv">12</span>
    <span class="kw">from</span> Staff;</code></pre>
<p>ou, avec un alias,</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, salary/<span class="dv">12</span> <span class="kw">as</span> monthlySalary
    <span class="kw">from</span> Staff;</code></pre>
</section>
</section>
<section id="sélection-de-rangées-where" class="level4">
<h4><a href="#sélection-de-rangées-where"><span class="header-section-number">6.3.4.2</span> Sélection de rangées (WHERE)</a></h4>
<p>Avec l’expression <code>where</code>, nous pouvons sélectionner des rangées spécifiques. Pour ce faire, nous utilisons le mot clé <code>where</code> suivi d’un prédicat. Les prédicats de base sont les suivants:</p>
<ul>
<li><em>Comparaison</em>: Compare la valeur d’une expression avec la valeur d’une autre expression.</li>
<li><em>Recherche d’écart</em>: Teste si la valeur d’une expression se retrouve dans une certaine plage de valeurs.</li>
<li><em>Appartenance à un ensemble</em>: Teste si la valeur d’une expression est égale à celle d’un ensemble de valeurs.</li>
<li><em>Correspondance à un masque</em>: Teste si une chaîne de caractères correspond à un modèle spécifique.</li>
<li><em>Null</em>: Teste si la colonne a une valeur nulle (inconnue).</li>
</ul>
<p>Les opérateurs de comparaison suivants sont disponibles dans le langage SQL:</p>
<pre><code>    =       égal
    &lt;&gt;      pas égale
    &lt;       plus petit que
    &lt;=      plus petit ou égal
    &gt;       plus grand que
    &gt;=      plus grand ou égal</code></pre>
<p>Il y aussi les opérateurs logiques <code>AND</code>, <code>OR</code> et <code>NOT</code> qui sont disponibles. Les prioriétés des opérations sont les suivantes:</p>
<ul>
<li>Une expression est évaluée de gauche à droite.</li>
<li>Les sous-expressions entre parenthèses sont évaluées en premier.</li>
<li>Les <code>NOT</code> sont évalués avant les <code>AND</code> et les <code>OR</code>.</li>
<li>Les <code>AND</code> sont évalués avant les <code>OR</code>.</li>
</ul>
<p>Il est important de retenir que les fonctions d’agrégation ne peuvent pas être utilisées dans une clause <code>WHERE</code>.</p>
<section id="exemples-dutilisation-du-where" class="level5">
<h5><a href="#exemples-dutilisation-du-where"><span class="header-section-number">6.3.4.2.1</span> Exemples d’utilisation du WHERE</a></h5>
<p>Dans cette section, nous allons voir des exemples d’utilisation de la clause <code>where</code>.</p>
<section id="prédicat-de-comparaison" class="level6">
<h6><a href="#prédicat-de-comparaison"><span class="header-section-number">6.3.4.2.1.1</span> Prédicat de comparaison</a></h6>
<p>On souhaite avoir la liste de tous les employés avec un salaire plus grand que 10000$.</p>
<p>Nous pouvons donc utiliser la clause <code>where</code> de la manière suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, position, salary
    <span class="kw">from</span> Staff
    <span class="kw">where</span> salary &gt; <span class="dv">10000</span>;</code></pre>
<p>Ce bout de code va créer une table dont les rangées correspondent aux rangées de la table initiale dont le salaire des employés est plus grand que 10000$.</p>
</section>
<section id="prédicat-de-comparaison-composé" class="level6">
<h6><a href="#prédicat-de-comparaison-composé"><span class="header-section-number">6.3.4.2.1.2</span> Prédicat de comparaison composé</a></h6>
<p>On souhaite avoir la liste de toutes les adresses des filiales de Londres et Glasgow.</p>
<p>Nous pouvons donc utiliser la clause <code>where</code> de la manière suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> *
    <span class="kw">from</span> Branch
    <span class="kw">where</span> city = <span class="st">&#39;London&#39;</span> <span class="kw">or</span> city = <span class="st">&#39;Glasgow&#39;</span>;</code></pre>
<p>Cela va créer une table dont les rangées correspondent aux rangées de la table initiale où la ville était soit Londres ou Glasgow.</p>
</section>
<section id="prédicat-de-recherche-décart-betweennot-between" class="level6">
<h6><a href="#prédicat-de-recherche-décart-betweennot-between"><span class="header-section-number">6.3.4.2.1.3</span> Prédicat de recherche d’écart (BETWEEN/NOT BETWEEN)</a></h6>
<p>On souhaite avoir tous les employés dont le salaire se situe entre 20000$ et 30000$.</p>
<p>Nous pouvons donc utiliser la clause <code>where</code> de la manière suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, position, salary
    <span class="kw">from</span> Staff
    <span class="kw">where</span> salary <span class="kw">between</span> <span class="dv">20000</span> <span class="kw">and</span> <span class="dv">30000</span>;</code></pre>
<p>Cela va créer une table dont les rangées correspondent aux rangées de la table initiale dont le salaire des employés était entre 20000 et 30000.</p>
<p>Nous aurions aussi pu écrire</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, position, salary
    <span class="kw">from</span> Staff
    <span class="kw">where</span> salary &gt;= <span class="dv">20000</span> <span class="kw">and</span> salary &lt;= <span class="dv">30000</span>;</code></pre>
</section>
<section id="prédicat-dappartenance-à-un-ensemble-innot-in" class="level6">
<h6><a href="#prédicat-dappartenance-à-un-ensemble-innot-in"><span class="header-section-number">6.3.4.2.1.4</span> Prédicat d’appartenance à un ensemble (IN/NOT IN)</a></h6>
<p>On souhaite avoir tous les employés qui sont des managers et des superviseurs.</p>
<p>Nous pouvons donc utiliser la clause <code>where</code> de la manière suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, position
    <span class="kw">from</span> Staff
    <span class="kw">where</span> position <span class="kw">in</span> (<span class="st">&#39;Manager&#39;</span>, <span class="st">&#39;Supervisor&#39;</span>);</code></pre>
<p>Cela va créer une table dont les rangées correspondent aux rangées de la table initiale dans lesquelles le poste des employés était soit un manager ou un superviseur.</p>
<p>Nous aurions aussi pu écrire</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, position
    <span class="kw">from</span> Staff
    <span class="kw">where</span> position = <span class="st">&#39;Manager&#39;</span> <span class="kw">or</span> position = <span class="st">&#39;Supervisor&#39;</span>;</code></pre>
</section>
<section id="prédicat-de-correspondance-à-un-masque-likenot-like" class="level6">
<h6><a href="#prédicat-de-correspondance-à-un-masque-likenot-like"><span class="header-section-number">6.3.4.2.1.5</span> Prédicat de correspondance à un masque (LIKE/NOT LIKE)</a></h6>
<p>Nous voulons trouver tous les propriétaires qui ont la chaîne de caractères ‘Glasgow’ dans leur adresse.</p>
<p>Le SQL possède deux symboles pour trouver des correspondances entre des chaînes de caractères:</p>
<ul>
<li>Le caractère % représente une séquence de zéro caractère ou plus.</li>
<li>Le caractère _ représente n’importe quel caractère.</li>
</ul>
<p>Tous les autres caractères se représentent eux-mêmes.</p>
<p>Ainsi, notre requête pour résoudre notre problème serait la suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> ownerNo, fName, lName, address, telNo
    <span class="kw">from</span> PrivateOwner
    <span class="kw">where</span> address <span class="kw">like</span> <span class="st">&#39;%Glasgow%&#39;</span>; <span class="co">-- N&#39;importe quelle chaine, tant qu&#39;elle contient &#39;Glasgow&#39;</span></code></pre>
</section>
<section id="prédicat-de-recherche-de-null-is-nullis-not-null" class="level6">
<h6><a href="#prédicat-de-recherche-de-null-is-nullis-not-null"><span class="header-section-number">6.3.4.2.1.6</span> Prédicat de recherche de NULL (IS NULL/IS NOT NULL)</a></h6>
<p>Nous voulons avoir les détails sur toutes les propriétés PG4 où un commentaire n’a pas été fourni.</p>
<p>Nous pouvons donc utiliser la clause de la manière suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> clientNo, viewDate
    <span class="kw">from</span> Viewing
    <span class="kw">where</span> propertyNo = <span class="st">&#39;PG4&#39;</span> <span class="kw">and</span> <span class="kw">comment</span> <span class="kw">is</span> <span class="kw">null</span>;</code></pre>
</section>
</section>
</section>
<section id="trier-les-résultats-order-by" class="level4">
<h4><a href="#trier-les-résultats-order-by"><span class="header-section-number">6.3.4.3</span> Trier les résultats (ORDER BY)</a></h4>
<p>La clause <code>ORDER BY</code> permet de classer des éléments selon un certain ordre. La clause <code>ORDER BY</code> reçoit en arguments la liste des identifiants des colonnes séparés par des virgules à partir desquels nous voulons trier. Il y a deux ordres de tri: en ordre croissant (ASC) et en ordre décroissant (DESC). La clause <code>ORDER BY</code> doit toujours être la dernière clause d’une expression <code>SELECT</code>. Le premier élément qui apparait dans la clause est appelé la <strong>clé majeure de tri</strong>. C’est elle qui va décider de l’ordre de tri général. Si les éléments de la colonne sont uniques, un élément de tri de va être suffisant. Sinon, on peut rajouter des éléments à la clause pour spécifier l’ordre de tri. On appelle tous les éléments qui apparaissent après la clé majeure de tri des <strong>clés mineures de tri</strong></p>
<section id="exemples-dutilisation-du-order-by" class="level5">
<h5><a href="#exemples-dutilisation-du-order-by"><span class="header-section-number">6.3.4.3.1</span> Exemples d’utilisation du ORDER BY</a></h5>
<p>Dans cette section, nous verrons des exemples d’utilisation de la clause <code>ORDER BY</code>.</p>
<section id="tri-avec-une-seule-colonne" class="level6">
<h6><a href="#tri-avec-une-seule-colonne"><span class="header-section-number">6.3.4.3.1.1</span> Tri avec une seule colonne</a></h6>
<p>Nous voulons la liste du salaire des employés en ordre décroissant.</p>
<p>Nous pourrions donc écrire la clause suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, salary
    <span class="kw">from</span> Staff
    <span class="kw">order</span> <span class="kw">by</span> salary <span class="kw">desc</span>;</code></pre>
</section>
<section id="tri-avec-plusieurs-colonnes" class="level6">
<h6><a href="#tri-avec-plusieurs-colonnes"><span class="header-section-number">6.3.4.3.1.2</span> Tri avec plusieurs colonnes</a></h6>
<p>Nous voulons avoir la liste des propriétés triées par le type des propriétés.</p>
<p>Nous pourrions écrire la clause suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql"><span class="kw">select</span> propertyNo, <span class="kw">type</span>, rooms, rent
<span class="kw">from</span> PropertyForRent
<span class="kw">order</span> <span class="kw">by</span> <span class="kw">type</span>;</code></pre>
<p>On obtiendrait alors la table suivante:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">propertyNo</th>
<th style="text-align: left;">type</th>
<th style="text-align: left;">rooms</th>
<th style="text-align: left;">rent</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">PL94</td>
<td style="text-align: left;">Flat</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">400</td>
</tr>
<tr class="even">
<td style="text-align: left;">PG4</td>
<td style="text-align: left;">Flat</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">350</td>
</tr>
<tr class="odd">
<td style="text-align: left;">PG36</td>
<td style="text-align: left;">Flat</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">375</td>
</tr>
<tr class="even">
<td style="text-align: left;">PG16</td>
<td style="text-align: left;">Flat</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">450</td>
</tr>
<tr class="odd">
<td style="text-align: left;">PA14</td>
<td style="text-align: left;">House</td>
<td style="text-align: left;">6</td>
<td style="text-align: left;">650</td>
</tr>
<tr class="even">
<td style="text-align: left;">PG21</td>
<td style="text-align: left;">House</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">600</td>
</tr>
</tbody>
</table>
<p>Par contre, si on précise une clé mineure de tri avec la clause suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql"><span class="kw">select</span> propertyNo, <span class="kw">type</span>, rooms, rent
<span class="kw">from</span> PropertyForRent
<span class="kw">order</span> <span class="kw">by</span> <span class="kw">type</span>, rent <span class="kw">desc</span>;</code></pre>
<p>On obtiendrait la table suivante:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">propertyNo</th>
<th style="text-align: left;">type</th>
<th style="text-align: left;">rooms</th>
<th style="text-align: left;">rent</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">PG16</td>
<td style="text-align: left;">Flat</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">450</td>
</tr>
<tr class="even">
<td style="text-align: left;">PL94</td>
<td style="text-align: left;">Flat</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">400</td>
</tr>
<tr class="odd">
<td style="text-align: left;">PG36</td>
<td style="text-align: left;">Flat</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">375</td>
</tr>
<tr class="even">
<td style="text-align: left;">PG4</td>
<td style="text-align: left;">Flat</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">350</td>
</tr>
<tr class="odd">
<td style="text-align: left;">PA14</td>
<td style="text-align: left;">House</td>
<td style="text-align: left;">6</td>
<td style="text-align: left;">650</td>
</tr>
<tr class="even">
<td style="text-align: left;">PG21</td>
<td style="text-align: left;">House</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">600</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
<section id="fonctions-sql-dagrégation" class="level4">
<h4><a href="#fonctions-sql-dagrégation"><span class="header-section-number">6.3.4.4</span> Fonctions SQL d’agrégation</a></h4>
<p>Les fonctions d’agrégation permettent d’effectuer des opérations sur des données. Il existe 5 types de fonctions d’agrégation définies par les standards ISO:</p>
<ul>
<li><code>COUNT</code>: Retourne le nombre de valeurs dans la colonne spécifiée.</li>
<li><code>SUM</code>: Retourne la somme des valeurs dans la colonne spécifiée.</li>
<li><code>AVG</code>: Retourne la moyenne des valeurs dans la colonne spécifiée.</li>
<li><code>MIN</code>: Retourne la plus petite valeur dans la colonne spécifiée.</li>
<li><code>MAX</code>: Retourne la plus grande valeur dans la colonne spécifiée.</li>
</ul>
<p>Les fonctions <code>AVG</code> et <code>SUM</code> peuvent seulement être utilisées sur des colonnes numériques. Toutes les fonctions éliminent les <em>nulls</em> avant d’effectuer leurs calculs. Il y a seulement <code>COUNT(*)</code> qui n’élimine pas les <em>nulls</em> avant de faire ses opérations.</p>
<p>Si on veut éliminer les copies, il faut utiliser le mot clé <code>DISTINCT</code> avant le nom de la colonne dans la fonction. Si on spécifie le mot clé <code>ALL</code> devant le nom des colonnes, on indique qu’on permet les copies.</p>
<section id="exemples-dutilisation-des-fonctions-sql-dagrégation" class="level5">
<h5><a href="#exemples-dutilisation-des-fonctions-sql-dagrégation"><span class="header-section-number">6.3.4.4.1</span> Exemples d’utilisation des fonctions SQL d’agrégation</a></h5>
<p>Dans cette section, nous verrons des exemples d’utilisation des fonctions SQL d’agrégation.</p>
<section id="utilisation-de-count" class="level6">
<h6><a href="#utilisation-de-count"><span class="header-section-number">6.3.4.4.1.1</span> Utilisation de <code>COUNT(*)</code></a></h6>
<p>Nous souhaitons savoir combien de propriétés coûtent plus chères que 350$ par mois.</p>
<p>Nous allons donc avoir la clause suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo <span class="fu">count</span>(salary)
    <span class="kw">from</span> Staff;</code></pre>
</section>
<section id="utilisation-de-countdistinct" class="level6">
<h6><a href="#utilisation-de-countdistinct"><span class="header-section-number">6.3.4.4.1.2</span> Utilisation de <code>COUNT(DISTINCT)</code></a></h6>
<p>Nous souhaitons savoir combien de propriétés différentes ont été vues en mai 2013.</p>
<p>Nous allons donc avoir la clause suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> <span class="fu">count</span>(<span class="kw">distinct</span> propertyNo) <span class="kw">as</span> myCount
    <span class="kw">from</span> Viewing
    <span class="kw">where</span> viewDate <span class="kw">between</span> <span class="st">&#39;1-May-13&#39;</span> <span class="kw">and</span> <span class="st">&#39;31-May-13&#39;</span>;</code></pre>
</section>
<section id="utilisation-de-count-et-sum" class="level6">
<h6><a href="#utilisation-de-count-et-sum"><span class="header-section-number">6.3.4.4.1.3</span> Utilisation de <code>COUNT</code> et <code>SUM</code></a></h6>
<p>Nous souhaitons trouver le nombre total de managers et la somme de leurs salaires.</p>
<p>Nous allons donc avoir la clause suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> <span class="fu">count</span>(staffNo) <span class="kw">as</span> myCount, <span class="fu">sum</span>(salary) <span class="kw">as</span> mySum
    <span class="kw">from</span> Staff
    <span class="kw">where</span> position = <span class="st">&#39;Manager&#39;</span>;</code></pre>
</section>
<section id="utilisation-de-min-max-et-avg" class="level6">
<h6><a href="#utilisation-de-min-max-et-avg"><span class="header-section-number">6.3.4.4.1.4</span> Utilisation de <code>MIN</code>, <code>MAX</code> et <code>AVG</code></a></h6>
<p>Nous souhaitons trouver le salaire minimum et maximum ainsi que la moyenne des salaires des employés.</p>
<p>Nous allons donc avoir la clause suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> <span class="fu">min</span>(salary) <span class="kw">as</span> myMin, <span class="fu">max</span>(salary) <span class="kw">as</span> myMax, <span class="fu">avg</span>(salary) <span class="kw">as</span> myAvg
    <span class="kw">from</span> Staff;</code></pre>
</section>
</section>
</section>
<section id="grouper-les-résultats-group-by" class="level4">
<h4><a href="#grouper-les-résultats-group-by"><span class="header-section-number">6.3.4.5</span> Grouper les résultats (<code>GROUP BY</code>)</a></h4>
<p>Lorsqu’on veut grouper des résultats, on se sert de la clause <code>GROUP BY</code>. Il est important de retenir que toutes les noms de colonnes qui apparaissent dans la clause <code>SELECT</code> doivent apparaître dans la clause <code>GROUP BY</code>, mais toutes les colonnes de <code>GROUP BY</code> ne sont pas obligées d’être dans la clause <code>SELECT</code>. La seule exception est si le nom de la colonne est seulement utilisé dans une fonction d’agrégation.</p>
<p>Aussi, lorsqu’une clause <code>WHERE</code> est utilisée avec la clause <code>GROUP BY</code>, la clause <code>WHERE</code> est appliquée en premier.</p>
<section id="exemple-dutilisation-de-group-by" class="level5">
<h5><a href="#exemple-dutilisation-de-group-by"><span class="header-section-number">6.3.4.5.1</span> Exemple d’utilisation de <code>GROUP BY</code></a></h5>
<p>Nous souhaitons trouver le nombre d’employés dans chaque branche ainsi que la somme de leurs salaires.</p>
<p>Nous allons donc avoir la clause suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> branchNo, <span class="fu">count</span>(staffNo) <span class="kw">as</span> myCount, <span class="fu">sum</span>(salary) <span class="kw">as</span> mySum
    <span class="kw">from</span> Staff
    <span class="kw">group</span> <span class="kw">by</span> branchNo
    <span class="kw">order</span> <span class="kw">by</span> branchNo;</code></pre>
<p>Nous aurons alors la table suivante:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">branchNo</th>
<th style="text-align: left;">myCount</th>
<th style="text-align: left;">mySum</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">B003</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">54000.00</td>
</tr>
<tr class="even">
<td style="text-align: left;">B005</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">39000.00</td>
</tr>
<tr class="odd">
<td style="text-align: left;">B007</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">9000.00</td>
</tr>
</tbody>
</table>
<p>Nous aurions aussi pu réécrire cette requête comme</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> branchNo, (<span class="kw">select</span> <span class="fu">count</span>(staffNo) <span class="kw">as</span> myCount
                      <span class="kw">from</span> Staff s
                      <span class="kw">where</span> s.branchNo = b.branchNo),
                     (<span class="kw">select</span> <span class="fu">sum</span>(salary) <span class="kw">as</span> mySum
                      <span class="kw">from</span> Staff s
                      <span class="kw">where</span> s.branchNo = b.branchNo)
    <span class="kw">from</span> Branch b
    <span class="kw">order</span> <span class="kw">by</span> branchNo;</code></pre>
</section>
</section>
<section id="restreindre-les-groupements-having" class="level4">
<h4><a href="#restreindre-les-groupements-having"><span class="header-section-number">6.3.4.6</span> Restreindre les groupements (<code>HAVING</code>)</a></h4>
<p>La clause <code>HAVING</code> a été conçue pour être utilisée avec la clause <code>GROUP BY</code> afin de restreindre les groupes qui apparaissent dans la table de résultats finale. Les noms de colonnes qui se retrouvent dans la clause <code>HAVING</code> doivent se retrouver dans la clause <code>GROUP BY</code>. La clause <code>HAVING</code> doit toujours inclure une fonction d’agrégation.</p>
<p>La clause <code>HAVING</code> n’est pas essentielle au langage SQL; le langage serait capable d’effectuer les mêmes opérations sans la clause <code>HAVING</code>.</p>
<section id="exemple-dutilisation-de-having" class="level5">
<h5><a href="#exemple-dutilisation-de-having"><span class="header-section-number">6.3.4.6.1</span> Exemple d’utilisation de <code>HAVING</code></a></h5>
<p>Nous souhaitons trouver le nombre d’employés qui travaillent dans chaque branche et la somme de leur salaire pour chaque branche qui a plus qu’un employé.</p>
<p>Nous aurons donc la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> branchNo, <span class="fu">count</span>(staffNo) <span class="kw">as</span> myCount, <span class="fu">sum</span>(salary) <span class="kw">as</span> mySum
    <span class="kw">from</span> Staff
    <span class="kw">group</span> <span class="kw">by</span> branchNo
    <span class="kw">having</span> <span class="fu">count</span>(staffNo) &gt; <span class="dv">1</span>
    <span class="kw">order</span> <span class="kw">by</span> branchNo;</code></pre>
<p>Nous aurons donc la table suivante:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">branchNo</th>
<th style="text-align: left;">myCount</th>
<th style="text-align: left;">mySum</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">B003</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">54000.00</td>
</tr>
<tr class="even">
<td style="text-align: left;">B005</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">39000.00</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="sous-requêtes" class="level4">
<h4><a href="#sous-requêtes"><span class="header-section-number">6.3.4.7</span> Sous-requêtes</a></h4>
<p>Une expression <code>SELECT</code> peut se retrouver dans une autre expression <code>SELECT</code>. Le résultat de ce <code>SELECT</code> sera alors utilisé pour déterminer le contenu du résultat final. Un <code>SELECT</code> peut aussi être utilisé dans une clause <code>WHERE</code> et <code>HAVING</code>. On l’appelle alors une <strong>sous-requête</strong>. Il y a trois types de sous-requêtes:</p>
<ul>
<li><strong>Sous-requête scalaire</strong>: Retourne une seule colonne et une seule ligne, soit une seule valeur. Utilisée lorsqu’une seule valeur est nécessaire.</li>
<li><strong>Sous-requête de ligne</strong>: Retourne plusieurs colonne, mais une seule ligne. Utilisée surtout dans les prédicats.</li>
<li><strong>Sous-requête de table</strong>: Retourne une ou plusieurs colonnes et plusieurs lignes. Utilisée lorsqu’une table est requise.</li>
</ul>
<p>Les règles suivantes s’appliquent aux sous-requêtes:</p>
<ul>
<li>La clause <code>ORDER BY</code> ne peut pas être utilisée dans une sous-requête.</li>
<li>Il ne doit y avoir qu’une seule colonne ou expression passée en argument au <code>SELECT</code> d’une sous-requête sauf si le mot clé <code>EXISTS</code> est utilisé.</li>
<li>Par défaut, les noms de colonnes dans une sous-requête réfère à celles de la table de la clause <code>FROM</code> de la sous-requête.</li>
<li>Quand une sous-requête est utilisée comme opérande dans une comparaison, elle doit toujours être à droite dans la comparaison.</li>
</ul>
<section id="mots-clés-any-et-all" class="level5">
<h5><a href="#mots-clés-any-et-all"><span class="header-section-number">6.3.4.7.1</span> Mots clés <code>ANY</code> et <code>ALL</code></a></h5>
<p>Les mots clés <code>ANY</code> et <code>ALL</code> peuvent être utilisés avec les sous-requêtes qui produisent une seule colonne. Si la sous-requête est précédée du mot clé <code>ALL</code>, la condition va être vraie seulement si elle est satisfaite par toutes les valeurs de la sous-requête. Si la sous-requête est précédée par le mot clé <code>ANY</code>, la condition va être vraie si elle satisfaite par au moins une valeur de la sous-requête. Le mot clé <code>SOME</code> est équivalent au mot clé <code>ANY</code>.</p>
</section>
<section id="exemple-dutilisation-de-sous-requêtes" class="level5">
<h5><a href="#exemple-dutilisation-de-sous-requêtes"><span class="header-section-number">6.3.4.7.2</span> Exemple d’utilisation de sous-requêtes</a></h5>
<p>Dans cette section, nous verrons des exemples d’utilisation de sous-requêtes.</p>
<section id="sous-requête-avec-lopérateur-dégalité" class="level6">
<h6><a href="#sous-requête-avec-lopérateur-dégalité"><span class="header-section-number">6.3.4.7.2.1</span> Sous-requête avec l’opérateur d’égalité</a></h6>
<p>Nous souhaitons trouver le personnel qui travaille dans la branche ‘163 Main St’.</p>
<p>Nous aurons donc la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, position
    <span class="kw">from</span> Staff
    <span class="kw">where</span> branchNo = (<span class="kw">select</span> branchNo
                      <span class="kw">from</span> Branch
                      <span class="kw">where</span> street = <span class="st">&#39;163 Main St&#39;</span>);</code></pre>
<p>La sous-requête va trouver le numéro de la branche qui correspond à la branche dont le nom de la rue est ‘163 Main St’. Cela va retourner une seule valeur. Il s’agit donc d’une sous-requête scalaire.</p>
</section>
<section id="sous-requête-avec-une-fonction-dagrégation" class="level6">
<h6><a href="#sous-requête-avec-une-fonction-dagrégation"><span class="header-section-number">6.3.4.7.2.2</span> Sous-requête avec une fonction d’agrégation</a></h6>
<p>Nous souhaitons trouver tous les employés dont le salaire est plus grand que la moyenne des salaires et montrer de combien leur salaire est plus grand que la moyenne.</p>
<p>Nous aurons donc la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, position,
           salary - (<span class="kw">select</span> <span class="fu">avg</span>(salary) <span class="kw">from</span> Staff) <span class="kw">as</span> salDiff
    <span class="kw">from</span> Staff
    <span class="kw">where</span> salary &gt; (<span class="kw">select</span> <span class="fu">avg</span>(salary) <span class="kw">from</span> Staff);</code></pre>
<p>Nous ne pouvons pas utiliser <code>avg(salary)</code> direct dans la clause <code>WHERE</code>, car les fonctions d’agrégation ne sont pas permises dans une clause <code>WHERE</code>.</p>
</section>
<section id="utilisation-de-in" class="level6">
<h6><a href="#utilisation-de-in"><span class="header-section-number">6.3.4.7.2.3</span> Utilisation de <code>IN</code></a></h6>
<p>Nous souhaitons avoir toutes les propriétés qui sont administrées par les employés qui travaillent à la branche à ‘163 Main St’.</p>
<p>Nous aurons donc la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> propertyNo, street, city, postcode, <span class="kw">type</span>, rooms, rent
    <span class="kw">from</span> PropertyForRent
    <span class="kw">where</span> staffNo <span class="kw">in</span> (<span class="kw">select</span> staffNo
                      <span class="kw">from</span> Staff
                      <span class="kw">where</span> branchNo = (<span class="kw">select</span> branchNo
                                        <span class="kw">from</span> Branch
                                        <span class="kw">where</span> street = <span class="st">&#39;163 Main St&#39;</span>));</code></pre>
<p>La dernière sous-requête selectionne le numéro de la branche qui se trouve à ‘163 Main St’. L’avant-dernière sous-requête sélectionne les employés qui travaille à cette branche. Ensuite, comme cette requête retourne plusieurs valeurs, nous utilisons le mot clé <code>IN</code>.</p>
<p>Nous obtenons donc la table suivante:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">propertyNo</th>
<th style="text-align: left;">street</th>
<th style="text-align: left;">city</th>
<th style="text-align: left;">postcode</th>
<th style="text-align: left;">type</th>
<th style="text-align: left;">rooms</th>
<th style="text-align: left;">rent</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">PG16</td>
<td style="text-align: left;">5 Novar Dr</td>
<td style="text-align: left;">Glasgow</td>
<td style="text-align: left;">G12 9AX</td>
<td style="text-align: left;">Flat</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">450</td>
</tr>
<tr class="even">
<td style="text-align: left;">PG36</td>
<td style="text-align: left;">2 Manor Rd</td>
<td style="text-align: left;">Glasgow</td>
<td style="text-align: left;">G32 4QX</td>
<td style="text-align: left;">Flat</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">375</td>
</tr>
<tr class="odd">
<td style="text-align: left;">PG21</td>
<td style="text-align: left;">18 Dale Rd</td>
<td style="text-align: left;">Glasgow</td>
<td style="text-align: left;">G12</td>
<td style="text-align: left;">House</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">600</td>
</tr>
</tbody>
</table>
</section>
<section id="utilisation-de-anysome" class="level6">
<h6><a href="#utilisation-de-anysome"><span class="header-section-number">6.3.4.7.2.4</span> Utilisation de <code>ANY</code>/<code>SOME</code></a></h6>
<p>Nous souhaitons trouver tous les employés dont le salaire est plus grand que le salaire d’au moins un employé à la branche B003.</p>
<p>Nous aurons donc la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, position, salary
    <span class="kw">from</span> Staff
    <span class="kw">where</span> salary &gt; <span class="kw">some</span>(<span class="kw">select</span> salary
                        <span class="kw">from</span> Staff
                        <span class="kw">where</span> branchNo = <span class="st">&#39;B003&#39;</span>);</code></pre>
<p>Nous obtiendrons donc la table suivante:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">staffNo</th>
<th style="text-align: left;">fName</th>
<th style="text-align: left;">lName</th>
<th style="text-align: left;">position</th>
<th style="text-align: left;">salary</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">SL21</td>
<td style="text-align: left;">John</td>
<td style="text-align: left;">White</td>
<td style="text-align: left;">Manager</td>
<td style="text-align: left;">30000.00</td>
</tr>
<tr class="even">
<td style="text-align: left;">SG14</td>
<td style="text-align: left;">David</td>
<td style="text-align: left;">Ford</td>
<td style="text-align: left;">Supervisor</td>
<td style="text-align: left;">18000.00</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SG5</td>
<td style="text-align: left;">Susan</td>
<td style="text-align: left;">Brand</td>
<td style="text-align: left;">Manager</td>
<td style="text-align: left;">24000.00</td>
</tr>
</tbody>
</table>
</section>
<section id="utilisation-de-all" class="level6">
<h6><a href="#utilisation-de-all"><span class="header-section-number">6.3.4.7.2.5</span> Utilisation de <code>ALL</code></a></h6>
<p>Nous souhaitons trouver tous les employés dont le salaire est plus grand que le salaire de tous les employés à la branche B003.</p>
<p>Nous aurons donc la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, position, salary
    <span class="kw">from</span> Staff
    <span class="kw">where</span> salary &gt; <span class="kw">all</span>(<span class="kw">select</span> salary
                       <span class="kw">from</span> Staff
                       <span class="kw">where</span> branchNo = <span class="st">&#39;B003&#39;</span>);</code></pre>
<p>Nous obtiendrons donc la table suivante:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">staffNo</th>
<th style="text-align: left;">fName</th>
<th style="text-align: left;">lName</th>
<th style="text-align: left;">position</th>
<th style="text-align: left;">salary</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">SL21</td>
<td style="text-align: left;">John</td>
<td style="text-align: left;">White</td>
<td style="text-align: left;">Manager</td>
<td style="text-align: left;">30000.00</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
<section id="requêtes-multi-tables" class="level4">
<h4><a href="#requêtes-multi-tables"><span class="header-section-number">6.3.4.8</span> Requêtes multi-tables</a></h4>
<p>Pour combiner des colonnes de plusieurs tables dans une seule table, nous devons utiliser une opération de <strong>jointure</strong>. L’opération de jointure du SQL combine les informations de deux tables en formant des paires de rangées liés. Ces paires de rangées sont celles où les colonnes correspondantes des deux tables ont la même valeur.</p>
<p>Pour faire une opération de jointure, il suffit d’inclure plus qu’une table dans la clause <code>FROM</code>. On sépare les noms de tables par des virgules. On peut aussi utiliser des alias. Pour ce faire, il suffit d’ajouter un espace après le nom de la table et mettre le nom de l’alias qu’on veut utiliser.</p>
<section id="calculer-une-jointure" class="level5">
<h5><a href="#calculer-une-jointure"><span class="header-section-number">6.3.4.8.1</span> Calculer une jointure</a></h5>
<p>Une jointure est un sous-ensemble du produit cartésien. Le produit cartésien de deux tables est une autre table avec toutes les paires de rangées possibles des deux tables. Si on fournit deux tables sans clause <code>WHERE</code>, le produit cartésien des deux tables sera calculé.</p>
<p>Les standards ISO ont établi une forme spéciale du <code>SELECT</code> pour le produit cartésien:</p>
<pre><code>    SELECT [DISTINCT | ALL] {* | columnList}
    FROM TableName1 CROSS JOIN TableName2</code></pre>
<p>La procédure pour effectuer une jointure avec un <code>SELECT</code> est la suivante:</p>
<ol type="1">
<li>Faire le produit cartésien avec les tables de la clause <code>FROM</code>.</li>
<li>S’il y a une clause <code>WHERE</code>, il faut appliquer la condition de recherche sur chacune des rangées du résultat du produit cartésien de sorte de ne retenir que les rangées qui satisfont la condition.</li>
<li>Pour chacune des rangées restantes, il faut déterminer la valeur de chacun des éléments dans la liste des éléments du <code>SELECT</code> afin de produire une seule rangée dans la table résultante.</li>
<li>S’il y a le mot clé <code>DISTINCT</code>, il faut éliminer toutes les copies de rangées de la table résultante.</li>
<li>S’il y a une clause <code>ORDER BY</code>, il faut trier la table selon la condition émise.</li>
</ol>
</section>
<section id="jointures-externes" class="level5">
<h5><a href="#jointures-externes"><span class="header-section-number">6.3.4.8.2</span> Jointures externes</a></h5>
<p>Les jointures vues jusqu’à présent gardent seulement les rangées qui correspondent entre les tables. Si une rangée ne correspond à aucune autre rangée, elle est omise du résultat.</p>
<p>La <strong>jointure externe</strong> permet de garder seulement ces rangées qui ne correspondent à aucune autre rangée. Il y a trois types de jointures externes:</p>
<ul>
<li><strong>Jointure externe gauche</strong></li>
<li><strong>Jointure externe droite</strong></li>
<li><strong>Jointure externe complète</strong></li>
</ul>
</section>
<section id="mots-clés-exists-et-not-exists" class="level5">
<h5><a href="#mots-clés-exists-et-not-exists"><span class="header-section-number">6.3.4.8.3</span> Mots clés <code>EXISTS</code> et <code>NOT EXISTS</code></a></h5>
<p>Les mots clés <code>EXISTS</code> et <code>NOT EXISTS</code> ont été conçus pour seulement fonctionner avec les sous-requêtes. Ils produisent une valeur de vrai ou faux. <code>EXISTS</code> est vrai seulement s’il existe au moins une rangée dans la table résultante retournée par la sous-requête. <code>EXISTS</code> retourne faux si la sous-requête retourne une table résultante vide.</p>
</section>
<section id="combiner-les-tables-résultantes-union-intersect-except" class="level5">
<h5><a href="#combiner-les-tables-résultantes-union-intersect-except"><span class="header-section-number">6.3.4.8.4</span> Combiner les tables résultantes (<code>UNION</code>, <code>INTERSECT</code>, <code>EXCEPT</code>)</a></h5>
<p>Dans le langage SQL, nous pouvons utiliser les opérations d’<em>union</em>, d’<em>intersection</em> et de <em>différence</em> pour combiner les résultats de deux ou plusieurs requêtes dans une seule table résultante:</p>
<ul>
<li>L’<strong>union</strong> de deux tables, <span class="math">\(A\)</span> et <span class="math">\(B\)</span>, est une table contenant toutes les rangées qui sont soit dans la table <span class="math">\(A\)</span> ou dans la table <span class="math">\(B\)</span>.</li>
<li>L’<strong>intersection</strong> de deux tables, <span class="math">\(A\)</span> et <span class="math">\(B\)</span>, est une table contenant toutes les rangées qui sont à la fois dans la table <span class="math">\(A\)</span> et <span class="math">\(B\)</span>.</li>
<li>La <strong>différence</strong> de deux tables, <span class="math">\(A\)</span> et <span class="math">\(B\)</span>, est une table contenant toutes les rangées qui sont dans la table <span class="math">\(A\)</span>, mais pas dans la table <span class="math">\(B\)</span>.</li>
</ul>
<p>Pour pouvoir se servir de ces opérations, les tables doivent être compatibles à l’union, c’est-à-dire avoir le même nombre de colonnes et que les colonnes ont la même longueur et le même type.</p>
<p>La façon d’utiliser ces opérations dans le langage se fait de la manière suivante:</p>
<pre><code>    operator[ALL][CORRESPONDING [BY {column1, [,...]}]]</code></pre>
</section>
<section id="exemples-dopérations-de-jointure" class="level5">
<h5><a href="#exemples-dopérations-de-jointure"><span class="header-section-number">6.3.4.8.5</span> Exemples d’opérations de jointure</a></h5>
<p>Dans cette section, nous verrons des exemples d’opérations de jointure.</p>
<section id="opération-de-jointure-simple" class="level6">
<h6><a href="#opération-de-jointure-simple"><span class="header-section-number">6.3.4.8.5.1</span> Opération de jointure simple</a></h6>
<p>Nous souhaitons avoir le nom de tous les clients qui ont vu une propriété avec tous les commentaires associés.</p>
<p>Nous aurons donc la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> c.clientNo, fName, lName, propertyNo, <span class="kw">comment</span>
    <span class="kw">from</span> Client c, Viewing v
    <span class="kw">where</span> c.clientNo = v.clientNo;</code></pre>
</section>
<section id="trier-une-opération-de-jointure" class="level6">
<h6><a href="#trier-une-opération-de-jointure"><span class="header-section-number">6.3.4.8.5.2</span> Trier une opération de jointure</a></h6>
<p>Pour chaque branche, nous souhaitons avoir la liste de tous les numéros d’employés et le nom des employés qui administrent des propriétés et les propriétés qu’ils administrent.</p>
<p>Nous aurons donc la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> s.branchNo, s.staffNo, fName, lName, propertyNo
    <span class="kw">from</span> Staff s, PropertyForRent p
    <span class="kw">where</span> s.staffNo = p.staffNo
    <span class="kw">order</span> <span class="kw">by</span> s.branchNo, s.staffNo, propertyNo;</code></pre>
</section>
<section id="opération-de-jointure-sur-trois-tables" class="level6">
<h6><a href="#opération-de-jointure-sur-trois-tables"><span class="header-section-number">6.3.4.8.5.3</span> Opération de jointure sur trois tables</a></h6>
<p>Pour chaque branche, nous souhaitons avoir la liste des numéros de personnel ainsi que le nom du personnel qui administre des propriétés y compris la ville dans laquelle chaque branche est située et les propriétés que le personnel administre.</p>
<p>Nous aurons donc la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> b.branchNo, b.city, s.staffNo, fName, lName, propertyNo
    <span class="kw">from</span> Branch b, Staff s, PropertyForRent p
    <span class="kw">where</span> b.branchNo = s.branchNo <span class="kw">and</span> s.staffNo = p.staffNo
    <span class="kw">order</span> <span class="kw">by</span> b.branchNo, s.staffNo, propertyNo;</code></pre>
</section>
<section id="multiples-groupements-de-colonnes" class="level6">
<h6><a href="#multiples-groupements-de-colonnes"><span class="header-section-number">6.3.4.8.5.4</span> Multiples groupements de colonnes</a></h6>
<p>Nous souhaitons trouver le nombre de propriétés administrées par chaque des membres du personnel ainsi que le numéro de branche de chaque membre du personnel.</p>
<p>Nous aurons donc la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> s.branchNo, s.staffNo, <span class="fu">count</span>(*) <span class="kw">as</span> myCount
    <span class="kw">from</span> Staff s, PropertyForRent p
    <span class="kw">where</span> s.staffNo = p.staffNo
    <span class="kw">group</span> <span class="kw">by</span> s.branchNo, s.staffNo
    <span class="kw">order</span> <span class="kw">by</span> s.branchNo, s.staffNo;</code></pre>
</section>
<section id="jointure-externe-gauche" class="level6">
<h6><a href="#jointure-externe-gauche"><span class="header-section-number">6.3.4.8.5.5</span> Jointure externe gauche</a></h6>
<p>Nous souhaitons trouver toutes les branches et toutes les propriétés qui sont dans la même ville.</p>
<p>Nous aurons donc la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> b.*, p.*
    <span class="kw">from</span> Branch1 b <span class="kw">left</span> <span class="kw">join</span> PropertyForRent1 p <span class="kw">on</span> b.bCity = p.pCity;</code></pre>
<p>La table résultante sera la suivante:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">branchNo</th>
<th style="text-align: left;">bCity</th>
<th style="text-align: left;">propertyNo</th>
<th style="text-align: left;">pCity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">B003</td>
<td style="text-align: left;">Glasgow</td>
<td style="text-align: left;">PG4</td>
<td style="text-align: left;">Glasgow</td>
</tr>
<tr class="even">
<td style="text-align: left;">B004</td>
<td style="text-align: left;">Bristol</td>
<td style="text-align: left;">null</td>
<td style="text-align: left;">null</td>
</tr>
<tr class="odd">
<td style="text-align: left;">B002</td>
<td style="text-align: left;">London</td>
<td style="text-align: left;">PL94</td>
<td style="text-align: left;">London</td>
</tr>
</tbody>
</table>
</section>
<section id="jointure-externe-droite" class="level6">
<h6><a href="#jointure-externe-droite"><span class="header-section-number">6.3.4.8.5.6</span> Jointure externe droite</a></h6>
<p>Nous souhaitons trouver toutes les propriétés et toutes les branches qui sont dans la même ville.</p>
<p>Nous aurons alors la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> b.*, p.*
    <span class="kw">from</span> Branch1 b <span class="kw">right</span> <span class="kw">join</span> PropertyForRent1 p <span class="kw">on</span> b.bCity = p.pCity;</code></pre>
<p>La table résultante sera la suivante:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">branchNo</th>
<th style="text-align: left;">bCity</th>
<th style="text-align: left;">propertyNo</th>
<th style="text-align: left;">pCity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">null</td>
<td style="text-align: left;">null</td>
<td style="text-align: left;">PA14</td>
<td style="text-align: left;">Aberdeen</td>
</tr>
<tr class="even">
<td style="text-align: left;">B003</td>
<td style="text-align: left;">Glasgow</td>
<td style="text-align: left;">PG4</td>
<td style="text-align: left;">Glasgow</td>
</tr>
<tr class="odd">
<td style="text-align: left;">B002</td>
<td style="text-align: left;">London</td>
<td style="text-align: left;">PL94</td>
<td style="text-align: left;">London</td>
</tr>
</tbody>
</table>
</section>
<section id="jointure-externe-complète" class="level6">
<h6><a href="#jointure-externe-complète"><span class="header-section-number">6.3.4.8.5.7</span> Jointure externe complète</a></h6>
<p>Nous souhaitons trouver toutes les branches et propriétés qui sont dans la même ville avec toutes les branches ou propriétés qui n’ont aucune correspondance.</p>
<p>Nous aurons alors la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> b.*, p.*
    <span class="kw">from</span> Branch1 b <span class="kw">full</span> <span class="kw">join</span> PropertyForRent1 p <span class="kw">on</span> b.bCity = p.pCity;</code></pre>
<p>La table résultant sera la suivante:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">branchNo</th>
<th style="text-align: left;">bCity</th>
<th style="text-align: left;">propertyNo</th>
<th style="text-align: left;">pCity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">null</td>
<td style="text-align: left;">null</td>
<td style="text-align: left;">PA14</td>
<td style="text-align: left;">Aberdeen</td>
</tr>
<tr class="even">
<td style="text-align: left;">B003</td>
<td style="text-align: left;">Glasgow</td>
<td style="text-align: left;">PG4</td>
<td style="text-align: left;">Glasgow</td>
</tr>
<tr class="odd">
<td style="text-align: left;">B004</td>
<td style="text-align: left;">Bristol</td>
<td style="text-align: left;">null</td>
<td style="text-align: left;">null</td>
</tr>
<tr class="even">
<td style="text-align: left;">B002</td>
<td style="text-align: left;">London</td>
<td style="text-align: left;">PL94</td>
<td style="text-align: left;">London</td>
</tr>
</tbody>
</table>
</section>
<section id="requête-utilisant-exists" class="level6">
<h6><a href="#requête-utilisant-exists"><span class="header-section-number">6.3.4.8.5.8</span> Requête utilisant <code>EXISTS</code></a></h6>
<p>Nous souhaitons trouver tout le personnel qui travaille à la branche de Londres.</p>
<p>Nous aurons alors la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, position
    <span class="kw">from</span> Staff s
    <span class="kw">where</span> <span class="kw">exists</span> (<span class="kw">select</span> *
                  <span class="kw">from</span> Branch b
                  <span class="kw">where</span> s.branchNo = b.branchNo <span class="kw">and</span> city = <span class="st">&#39;London&#39;</span>);</code></pre>
</section>
<section id="utiliser-union" class="level6">
<h6><a href="#utiliser-union"><span class="header-section-number">6.3.4.8.5.9</span> Utiliser <code>UNION</code></a></h6>
<p>Nous souhaitons avoir la liste de toutes les villes qui sont une branche soit une propriété.</p>
<p>Nous aurons alors la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    (<span class="kw">select</span> city
     <span class="kw">from</span> Branch
     <span class="kw">where</span> city <span class="kw">is</span> <span class="kw">not</span> <span class="kw">null</span>)
     <span class="kw">union</span>
    (<span class="kw">select</span> city
     <span class="kw">from</span> PropertyForRent
     <span class="kw">where</span> city <span class="kw">is</span> <span class="kw">not</span> <span class="kw">null</span>);</code></pre>
<p>ou</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    (<span class="kw">select</span> *
     <span class="kw">from</span> Branch
     <span class="kw">where</span> city <span class="kw">is</span> <span class="kw">not</span> <span class="kw">null</span>)
     <span class="kw">union</span> corresponding <span class="kw">by</span> city
    (<span class="kw">select</span> *
     <span class="kw">from</span> PropertyForRent
     <span class="kw">where</span> city <span class="kw">is</span> <span class="kw">not</span> <span class="kw">null</span>);</code></pre>
</section>
<section id="utiliser-intersect" class="level6">
<h6><a href="#utiliser-intersect"><span class="header-section-number">6.3.4.8.5.10</span> Utiliser <code>INTERSECT</code></a></h6>
<p>Nous souhaitons avoir la liste des villes où il y a à la fois une branche et une propriété.</p>
<p>Nous aurons alors la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    (<span class="kw">select</span> city
     <span class="kw">from</span> Branch)
     <span class="kw">intersect</span>
    (<span class="kw">select</span> city
     <span class="kw">from</span> PropertyForRent);</code></pre>
<p>ou</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    (<span class="kw">select</span> *
     <span class="kw">from</span> Branch)
     <span class="kw">intersect</span> corresponding <span class="kw">by</span> city
    (<span class="kw">select</span> *
     <span class="kw">from</span> PropertyForRent);</code></pre>
<p>Nous pourrions également réécrire ces requêtes sans l’opérateur <code>INTERSECT</code>:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> <span class="kw">distinct</span> b.city
    <span class="kw">from</span> Branch b, PropertyForRent p
    <span class="kw">where</span> b.city = p.city;</code></pre>
<p>ou</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> <span class="kw">distinct</span> city
    <span class="kw">from</span> Branch b
    <span class="kw">where</span> <span class="kw">exists</span> (<span class="kw">select</span> *
                  <span class="kw">from</span> PropertyForRent p
                  <span class="kw">where</span> b.city = p.city);</code></pre>
</section>
<section id="utiliser-except" class="level6">
<h6><a href="#utiliser-except"><span class="header-section-number">6.3.4.8.5.11</span> Utiliser <code>EXCEPT</code></a></h6>
<p>Nous souhaitons avoir la liste de toutes les villes où il y a une branche, mais pas de propriétés.</p>
<p>Nous aurons alors la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    (<span class="kw">select</span> city
     <span class="kw">from</span> Branch)
     <span class="kw">except</span>
    (<span class="kw">select</span> city
     <span class="kw">from</span> PropertyForRent);</code></pre>
<p>ou</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    (<span class="kw">select</span> *
     <span class="kw">from</span> Branch)
     <span class="kw">except</span> corresponding <span class="kw">by</span> city
    (<span class="kw">select</span> *
     <span class="kw">from</span> PropertyForRent);</code></pre>
<p>Nous pourrions également réécrire ces requêtes sans l’opérateur <code>EXCEPT</code>:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> <span class="kw">distinct</span> city
    <span class="kw">from</span> Branch
    <span class="kw">where</span> city <span class="kw">not</span> <span class="kw">in</span> (<span class="kw">select</span> city
               <span class="kw">from</span> PropertyForRent);</code></pre>
<p>ou</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> <span class="kw">distinct</span> city
    <span class="kw">from</span> Branch b
    <span class="kw">where</span> <span class="kw">not</span> <span class="kw">exists</span>
          (<span class="kw">select</span> *
           <span class="kw">from</span> PropertyForRent p
           <span class="kw">where</span> b.city = p.city);</code></pre>
</section>
</section>
</section>
<section id="mises-à-jour-de-la-base-de-données" class="level4">
<h4><a href="#mises-à-jour-de-la-base-de-données"><span class="header-section-number">6.3.4.9</span> Mises à jour de la base de données</a></h4>
<p>Le SQL est un langage de manipulation de données. Ainsi, il offre des instructions pour arriver à modifier le contenu des tables des bases de données. Il offre trois instructions:</p>
<ul>
<li><code>INSERT</code>: Ajoute des nouvelles rangées de données dans une table.</li>
<li><code>UPDATE</code>: Mets à jour les données d’une table.</li>
<li><code>DELETE</code>: Enlève des rangées de données d’une table.</li>
</ul>
<section id="insérer-des-données-dans-une-base-de-données-insert" class="level5">
<h5><a href="#insérer-des-données-dans-une-base-de-données-insert"><span class="header-section-number">6.3.4.9.1</span> Insérer des données dans une base de données (<code>INSERT</code>)</a></h5>
<p>Il y a deux forme de clause <code>INSERT</code>. La première forme permet d’insérer des données et a la forme suivante:</p>
<pre><code>    INSERT INTO TableName [(columnList)]
    VALUES (dataValueList)</code></pre>
<p>où <em>TableName</em> est soit une table de base ou une vue qu’on peut mettre à jour, <em>columnList</em> est une liste d’un nom de colonne ou plus séparés par des virgules. <em>columnList</em> est optionnel et, si omis, le SQL va considérer toutes les colonnes de la table originale dans l’ordre de création de celle-ci. Si spécifié, toutes les colonnes omises doivent être nullables excepté si <code>DEFAULT</code> a été spécifié au moment de leur création. <em>dataValueList</em> doit correspondre à <em>columnList</em> des manières suivantes:</p>
<ul>
<li>Le nombre d’éléments dans chaque liste doit être le même.</li>
<li>Il doit y avoir une correspondance directe entre la position des éléments dans les deux listes.</li>
<li>Le type des données de <em>dataValueList</em> doit être compatible avec le type de la colonne correspondante.</li>
</ul>
<p>La deuxième forme de <code>INSERT</code> permet de copier des rangées d’une table à l’autre et a le format suivant:</p>
<pre><code>    INSERT INTO TableName [(columnList)]
      SELECT ...</code></pre>
<p><em>TableName</em> et <em>columnList</em> ont les mêmes valeurs que lorsqu’on insère une rangée. La clause <code>SELECT</code> peut être n’importe quelle clause <code>SELECT</code> valide.</p>
<section id="exemple-de-insert-...-values" class="level6">
<h6><a href="#exemple-de-insert-...-values"><span class="header-section-number">6.3.4.9.1.1</span> Exemple de <code>INSERT ... VALUES</code></a></h6>
<p>Nous souhaitons insérer une nouvelle rangée dans la table <em>Staff</em> en donnant les données pour toutes les colonnes.</p>
<p>Nous aurons la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">insert</span> <span class="kw">into</span> Staff
    <span class="kw">values</span> (<span class="st">&#39;SG16&#39;</span>, <span class="st">&#39;Alan&#39;</span>, <span class="st">&#39;Brown&#39;</span>, <span class="st">&#39;Assistant&#39;</span>, <span class="st">&#39;M&#39;</span>, <span class="dt">DATE</span> <span class="st">&#39;1957-05-25&#39;</span>, <span class="dv">8300</span>, <span class="st">&#39;B003&#39;</span>);</code></pre>
</section>
<section id="exemple-de-insert-en-utilisant-des-valeurs-par-défaut" class="level6">
<h6><a href="#exemple-de-insert-en-utilisant-des-valeurs-par-défaut"><span class="header-section-number">6.3.4.9.1.2</span> Exemple de <code>INSERT</code> en utilisant des valeurs par défaut</a></h6>
<p>Nous souhaitons insérer une nouvelle rangée dans la table <em>Staff</em> en donnant toutes les données pour les colonnes obligatoires: <em>staffNo</em>, <em>fName</em>, <em>lName</em>, <em>position</em>, <em>salary</em> et <em>branchNo</em>.</p>
<p>Nous aurons la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">insert</span> <span class="kw">into</span> Staff (staffNo, fName, lName, position, salary, branchNo)
    <span class="kw">values</span> (<span class="st">&#39;SG44&#39;</span>, <span class="st">&#39;Anne&#39;</span>, <span class="st">&#39;Jones&#39;</span>, <span class="st">&#39;Assistant&#39;</span>, <span class="dv">8100</span>, <span class="st">&#39;B003&#39;</span>);</code></pre>
<p>Nous aurions aussi pu écrire:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">insert</span> <span class="kw">into</span> Staff
    <span class="kw">values</span> (<span class="st">&#39;SG44&#39;</span>, <span class="st">&#39;Anne&#39;</span>, <span class="st">&#39;Jones&#39;</span>, <span class="st">&#39;Assistant&#39;</span>, <span class="kw">null</span>, <span class="kw">null</span>, <span class="dv">8100</span>, <span class="st">&#39;B003&#39;</span>);</code></pre>
</section>
<section id="exemple-de-insert-...-select" class="level6">
<h6><a href="#exemple-de-insert-...-select"><span class="header-section-number">6.3.4.9.1.3</span> Exemple de <code>INSERT ... SELECT</code></a></h6>
<p>Assumons qu’il existe une table <em>StaffPropCount</em> qui contient le nom du personnel et le nombre de propriétés qu’il administre. La table a la forme suivante:</p>
<pre><code>    StaffPropCount(staffNo, fName, lName, propCount)</code></pre>
<p>Nous souhaitons populer la table <em>StaffPropCount</em> en utilisant les détails des tables <em>Staff</em> et <em>PropertyForRent</em>.</p>
<p>Nous aurons alors la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">insert</span> <span class="kw">into</span> StaffPropCount
   (<span class="kw">select</span> s.staffNo, fName, lName, <span class="fu">count</span>(*)
    <span class="kw">from</span> Staff s, PropertyForRent p
    <span class="kw">where</span> s.staffNo = p.staffNo
    <span class="kw">group</span> <span class="kw">by</span> s.staffNo, fName, lName)
    <span class="kw">union</span>
   (<span class="kw">select</span> staffNo, fName, lName, <span class="dv">0</span>
    <span class="kw">from</span> Staff s
    <span class="kw">where</span> <span class="kw">not</span> <span class="kw">exists</span>(<span class="kw">select</span> *
                     <span class="kw">from</span> PropertyForRent p
                     <span class="kw">where</span> p.staffNo = s.staffNo));</code></pre>
<p><em>Il est bon de noter que quelques dialectes de SQL ne permettent pas d’utiliser <code>UNION</code> à l’intérieur d’une sous-selection.</em></p>
<p>Nous obtenons alors la table suivante:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">staffNo</th>
<th style="text-align: left;">fName</th>
<th style="text-align: left;">lName</th>
<th style="text-align: left;">propCount</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">SG14</td>
<td style="text-align: left;">David</td>
<td style="text-align: left;">Ford</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">SL21</td>
<td style="text-align: left;">John</td>
<td style="text-align: left;">White</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SG37</td>
<td style="text-align: left;">Ann</td>
<td style="text-align: left;">Beech</td>
<td style="text-align: left;">2</td>
</tr>
<tr class="even">
<td style="text-align: left;">SA9</td>
<td style="text-align: left;">Mary</td>
<td style="text-align: left;">Howe</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SG5</td>
<td style="text-align: left;">Susan</td>
<td style="text-align: left;">Brand</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">SL41</td>
<td style="text-align: left;">Julie</td>
<td style="text-align: left;">Lee</td>
<td style="text-align: left;">1</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="modifier-les-données-dans-la-base-de-données-update" class="level5">
<h5><a href="#modifier-les-données-dans-la-base-de-données-update"><span class="header-section-number">6.3.4.9.2</span> Modifier les données dans la base de données (<code>UPDATE</code>)</a></h5>
<p>L’expression <code>UPDATE</code> permet de modifier le contenu de rangées déjà existantes d’une table. Elle prend le format suivant:</p>
<pre><code>    UPDATE TableName
    SET columnName1 = dataValue1 [, columnName2 = dataValue2 ...]
    [WHERE searchCondition]</code></pre>
<p><em>TableName</em> peut être le nom d’une table de base ou d’une vue qui peut être mise à jour. La clause <code>SET</code> spécifie le nom d’une ou plusieurs colonnes qui doivent être mises à jour. La clause <code>WHERE</code> est optionnelle, si omise, toutes les colonnes nommées sont mises à jour pour toutes leurs rangées. Si une clause <code>WHERE</code> est spécifiée, seules les rangées qui satisfont la condition de recherche vont être mises à jour. Les nouvelles <em>dataValues</em> doivent être compatibles avec le type de données pour la colonne correspondante.</p>
<section id="mise-à-jour-de-toutes-les-rangées" class="level6">
<h6><a href="#mise-à-jour-de-toutes-les-rangées"><span class="header-section-number">6.3.4.9.2.1</span> Mise à jour de toutes les rangées</a></h6>
<p>Nous souhaitons augmenter le salaire du personnel de 3%.</p>
<p>Nous aurons alors la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">update</span> Staff
    <span class="kw">set</span> salary = salary * <span class="fl">1.03</span>;</code></pre>
</section>
<section id="mettre-à-jour-des-rangées-spécifiques" class="level6">
<h6><a href="#mettre-à-jour-des-rangées-spécifiques"><span class="header-section-number">6.3.4.9.2.2</span> Mettre à jour des rangées spécifiques</a></h6>
<p>Nous souhaitons donner une augmentation de salaire de 5% à tous les managers.</p>
<p>Nous aurons alors la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">update</span> Staff
    <span class="kw">set</span> salary = salary * <span class="fl">1.05</span>
    <span class="kw">where</span> position = <span class="st">&#39;Manager&#39;</span>;</code></pre>
</section>
<section id="mettre-à-jour-plusieurs-colonnes" class="level6">
<h6><a href="#mettre-à-jour-plusieurs-colonnes"><span class="header-section-number">6.3.4.9.2.3</span> Mettre à jour plusieurs colonnes</a></h6>
<p>Nous souhaitons promouvoir <em>David Ford (staffNo = ‘SG14’)</em> au rang de manager et augmenter son salaire à 18000$.</p>
<p>Nous aurons alors la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">update</span> Staff
    <span class="kw">set</span> position = <span class="st">&#39;Manager&#39;</span>, salary = <span class="dv">18000</span>
    <span class="kw">where</span> staffNo = <span class="st">&#39;SG14&#39;</span>;</code></pre>
</section>
</section>
<section id="effacer-des-données-de-la-base-de-données-delete" class="level5">
<h5><a href="#effacer-des-données-de-la-base-de-données-delete"><span class="header-section-number">6.3.4.9.3</span> Effacer des données de la base de données (<code>DELETE</code>)</a></h5>
<p>L’expression <code>DELETE</code> permet d’effacer des rangées d’une table donnée. Son format est le suivant:</p>
<pre><code>    DELETE FROM TableName
    [WHERE searchCondition]</code></pre>
<p>Comme avec les clauses <code>INSERT</code> et <code>UPDATE</code>, <em>TableName</em> peut être le nom d’une table de base ou d’une vue qu’on peut mettre à jour. <em>searchCondition</em> est optionnel, si omis, toutes les rangées sont effacées de la table. Ça n’efface pas la table elle-même par contre. Si <em>searchCondition</em> est spécifié, seule les rangées qui satisfont la condition seront effacées.</p>
<section id="effacer-des-rangées-spécifiques" class="level6">
<h6><a href="#effacer-des-rangées-spécifiques"><span class="header-section-number">6.3.4.9.3.1</span> Effacer des rangées spécifiques</a></h6>
<p>Nous souhaitons effacer toutes les vues qui sont reliées à la propriété PG4.</p>
<p>Nous aurons alors la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">delete</span> <span class="kw">from</span> Viewing
    <span class="kw">where</span> propertyNo = <span class="st">&#39;PG4&#39;</span>;</code></pre>
</section>
<section id="effacer-toutes-les-rangées" class="level6">
<h6><a href="#effacer-toutes-les-rangées"><span class="header-section-number">6.3.4.9.3.2</span> Effacer toutes les rangées</a></h6>
<p>Nous souhaitons effacer toutes les rangées de la table <em>Viewing</em>.</p>
<p>Nous aurons alors la requête suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">delete</span> <span class="kw">from</span> Viewing;</code></pre>
</section>
</section>
</section>
</section>
</section>
</section>
<section id="sql-avancé" class="level1">
<h1><a href="#sql-avancé"><span class="header-section-number">7</span> SQL avancé</a></h1>
<p>Le SQL, contrairement aux autres langages, est un langage déclaratif. Pour introduire des concepts de langages de programmation, le standard du SQL a été mis à jour. Cette extension ce nomme le <strong>PL/SQL</strong>. Un programme <strong>PL/SQL</strong> comporte un maximum de trois parties:</p>
<ul>
<li>Une partie optionnelle de déclaration dans laquelle les variables, constantes, curseurs et exceptions sont déclarés</li>
<li>Une partie d’exécution obligatoire dans laquelle les variables sont manipulées</li>
<li>Une partie optionnelle pour les exceptions pour gérer les exceptions lancées lors de la partie d’exécution</li>
</ul>
<p>Un programme a la structure suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">[<span class="kw">DECLARE</span>             <span class="co">-- Optionnel</span>
    <span class="co">-- Déclarations]</span>
<span class="kw">BEGIN</span>                <span class="co">-- Obligatoire</span>
    <span class="co">-- Clauses exécutables</span>
[<span class="kw">EXCEPTION</span>           <span class="co">-- Optionnel</span>
    <span class="co">-- Gestionnaire d&#39;exceptions]</span>
<span class="kw">END</span>;                 <span class="co">-- Obligatoire</span></code></pre>
<section id="déclaration" class="level2">
<h2><a href="#déclaration"><span class="header-section-number">7.1</span> Déclaration</a></h2>
<p>Les variables et constantes doivent être déclarées avant de pouvoir être utilisées dans d’autres clauses ou déclarations.</p>
<section id="les-annotations-type-et-rowtype" class="level3">
<h3><a href="#les-annotations-type-et-rowtype"><span class="header-section-number">7.1.1</span> Les annotations <code>%TYPE</code> et <code>%ROWTYPE</code></a></h3>
<p>L’annotation <code>%TYPE</code> permet de dire au programme que la variable a le même type qu’une autre variable ou colonne. De manière similaire, l’annotation <code>%ROWTYPE</code> permet de dire qu’une variable a le même type qu’une rangée entière d’une table.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
</section>
<section id="exemples" class="level3">
<h3><a href="#exemples"><span class="header-section-number">7.1.2</span> Exemples</a></h3>
<p>Dans cette section, nous allons voir des exemples de déclarations.</p>
<section id="exemple-de-déclarations-normales" class="level4">
<h4><a href="#exemple-de-déclarations-normales"><span class="header-section-number">7.1.2.1</span> Exemple de déclarations normales</a></h4>
<pre class="sourceCode SQL"><code class="sourceCode sql">vStaffNo <span class="dt">VARCHAR2</span>(<span class="dv">5</span>);
vRent <span class="dt">NUMBER</span>(<span class="dv">6</span>, <span class="dv">2</span>) <span class="kw">NOT</span> <span class="kw">NULL</span> := <span class="dv">600</span>;
MAX_PROPERTIES <span class="kw">CONSTANT</span> <span class="dt">NUMBER</span> := <span class="dv">100</span>;</code></pre>
</section>
<section id="exemple-dutilisations-de-lannotation-type" class="level4">
<h4><a href="#exemple-dutilisations-de-lannotation-type"><span class="header-section-number">7.1.2.2</span> Exemple d’utilisations de l’annotation <code>%TYPE</code></a></h4>
<pre class="sourceCode SQL"><code class="sourceCode sql">vStaff Staff.staffNo%<span class="kw">TYPE</span>;
vStaffNo1 vStaffNo%<span class="kw">TYPE</span>;</code></pre>
</section>
<section id="exemple-dutilisations-de-lannotation-rowtype" class="level4">
<h4><a href="#exemple-dutilisations-de-lannotation-rowtype"><span class="header-section-number">7.1.2.3</span> Exemple d’utilisations de l’annotation <code>%ROWTYPE</code></a></h4>
<pre class="sourceCode SQL"><code class="sourceCode sql">vStaffRec Staff%ROWTYPE;</code></pre>
</section>
</section>
</section>
<section id="assignation" class="level2">
<h2><a href="#assignation"><span class="header-section-number">7.2</span> Assignation</a></h2>
<p>Les variables peuvent être assignées de deux façons:</p>
<ol type="1">
<li>En utilisant l’opérateur d’assignation (<code>:=</code>)</li>
<li>En utilisant le résultat d’un <code>SELECT</code> ou d’un <code>FETCH</code></li>
</ol>
<p>Dans le SQL standard, l’assignation se fait en utilisant le mot clé <code>SET</code> avec l’opérateur <code>=</code>.</p>
<section id="exemples-1" class="level3">
<h3><a href="#exemples-1"><span class="header-section-number">7.2.1</span> Exemples</a></h3>
<p>Dans cette section, nous allons voir des exemples d’assignation.</p>
<section id="exemple-dassignation-avec-un-select" class="level4">
<h4><a href="#exemple-dassignation-avec-un-select"><span class="header-section-number">7.2.1.1</span> Exemple d’assignation avec un <code>SELECT</code></a></h4>
<pre class="sourceCode SQL"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="fu">COUNT</span>(*) <span class="kw">INTO</span> x
  <span class="kw">FROM</span> PropertyForRent
  <span class="kw">WHERE</span> staffNo = vStaffNo;</code></pre>
</section>
<section id="exemple-dassignations-avec-lopérateur" class="level4">
<h4><a href="#exemple-dassignations-avec-lopérateur"><span class="header-section-number">7.2.1.2</span> Exemple d’assignations avec l’opérateur <code>:=</code></a></h4>
<pre class="sourceCode SQL"><code class="sourceCode sql">vStaffNo := <span class="st">&#39;SG14&#39;</span>;
vRent := <span class="dv">500</span>;</code></pre>
<p>En SQL standard, nous écririons</p>
<pre class="sourceCode SQL"><code class="sourceCode sql"><span class="kw">SET</span> vStaffNo = <span class="st">&#39;SG14&#39;</span>;
<span class="kw">SET</span> vRent = <span class="dv">500</span>;</code></pre>
</section>
</section>
</section>
<section id="clauses-de-contrôle" class="level2">
<h2><a href="#clauses-de-contrôle"><span class="header-section-number">7.3</span> Clauses de contrôle</a></h2>
<p>Le PL/SQL supporte les clauses de contrôle conditionnelles, itératives et séquentielles.</p>
<section id="lénoncé-conditionnel-if" class="level3">
<h3><a href="#lénoncé-conditionnel-if"><span class="header-section-number">7.3.1</span> L’énoncé conditionnel <code>IF</code></a></h3>
<p>L’énoncé conditionnel <code>IF</code> a la forme suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql"><span class="kw">IF</span> (condition) <span class="kw">THEN</span>
    &lt;SQL statement list&gt;
[<span class="kw">ELSIF</span> (condition) <span class="kw">THEN</span> &lt;SQL statement list&gt;]
[<span class="kw">ELSE</span> &lt;SQL statement list&gt;]
<span class="kw">END</span> <span class="kw">IF</span>;</code></pre>
<section id="exemple-dutilisation-du-if" class="level4">
<h4><a href="#exemple-dutilisation-du-if"><span class="header-section-number">7.3.1.1</span> Exemple d’utilisation du <code>IF</code></a></h4>
<pre class="sourceCode SQL"><code class="sourceCode sql"><span class="kw">IF</span> (position = <span class="st">&#39;Manager&#39;</span>) <span class="kw">THEN</span>
    salary := salary * <span class="fl">1.05</span>;
<span class="kw">ELSE</span>
    salary := salary * <span class="fl">1.03</span>;
<span class="kw">END</span> <span class="kw">IF</span>;</code></pre>
</section>
</section>
<section id="lénoncé-conditionnel-case" class="level3">
<h3><a href="#lénoncé-conditionnel-case"><span class="header-section-number">7.3.2</span> L’énoncé conditionnel <code>CASE</code></a></h3>
<p>L’énoncé conditionnel <code>CASE</code> permet la sélection d’un chemin d’exécution basé sur un ensemble d’alternatives. Il a la forme suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql"><span class="kw">CASE</span>(operand)
[<span class="kw">WHEN</span> (whenOperandList) | <span class="kw">WHEN</span> (searchCondition)
    <span class="kw">THEN</span> &lt;SQL statement list&gt;]
[<span class="kw">ELSE</span> &lt;SQL statement list&gt;]
<span class="kw">END</span> <span class="kw">CASE</span>;</code></pre>
<section id="exemple-dutilisation-du-case" class="level4">
<h4><a href="#exemple-dutilisation-du-case"><span class="header-section-number">7.3.2.1</span> Exemple d’utilisation du <code>CASE</code></a></h4>
<pre class="sourceCode SQL"><code class="sourceCode sql"><span class="kw">CASE</span> lowercase(x)
    <span class="kw">WHEN</span> <span class="st">&#39;a&#39;</span>        
        <span class="kw">THEN</span> x := <span class="dv">1</span>;
    <span class="kw">WHEN</span> <span class="st">&#39;b&#39;</span>        
        <span class="kw">THEN</span> x := <span class="dv">2</span>;
             y := <span class="dv">0</span>;
    <span class="kw">WHEN</span> <span class="st">&#39;default&#39;</span>  
        <span class="kw">THEN</span> x := <span class="dv">3</span>;
<span class="kw">END</span> <span class="kw">CASE</span>;</code></pre>
<pre class="sourceCode SQL"><code class="sourceCode sql"><span class="kw">UPDATE</span> Staff
<span class="kw">SET</span> salary = <span class="kw">CASE</span>
    <span class="kw">WHEN</span> position = <span class="st">&#39;Manager&#39;</span>
        <span class="kw">THEN</span> salary * <span class="fl">1.05</span>
    <span class="kw">ELSE</span>
        <span class="kw">THEN</span> salary * <span class="fl">1.02</span>
<span class="kw">END</span>;</code></pre>
</section>
</section>
<section id="énoncés-itératifs" class="level3">
<h3><a href="#énoncés-itératifs"><span class="header-section-number">7.3.3</span> Énoncés itératifs</a></h3>
<p>Dans cette section, nous allons voir les différents énoncés itératifs.</p>
<section id="énoncé-loop" class="level4">
<h4><a href="#énoncé-loop"><span class="header-section-number">7.3.3.1</span> Énoncé <code>LOOP</code></a></h4>
<p>L’énoncé <code>LOOP</code> a la forme suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">[labelName:]
<span class="kw">LOOP</span>
    &lt;SQL statement list&gt;
    EXIT [labelName] [<span class="kw">WHEN</span> (condition)]
<span class="kw">END</span> <span class="kw">LOOP</span> [labelName];</code></pre>
<p>Il est bon de noter que le standard SQL spécifie <code>LEAVE</code> au lieu de <code>EXIT WHEN (condition)</code>.</p>
<section id="exemple" class="level5">
<h5><a href="#exemple"><span class="header-section-number">7.3.3.1.1</span> Exemple</a></h5>
<pre class="sourceCode SQL"><code class="sourceCode sql">x := <span class="dv">1</span>;
myLoop:
<span class="kw">LOOP</span>
    x := x + <span class="dv">1</span>;
    <span class="kw">IF</span> (x &gt; <span class="dv">3</span>) <span class="kw">THEN</span>
        EXIT myLoop; <span class="co">-- Exit loop immediately</span>
<span class="kw">END</span> <span class="kw">LOOP</span> myLoop;

<span class="co">-- Control resumes here</span>
y := <span class="dv">2</span>;</code></pre>
</section>
</section>
<section id="énoncé-while-et-repeat" class="level4">
<h4><a href="#énoncé-while-et-repeat"><span class="header-section-number">7.3.3.2</span> Énoncé <code>WHILE</code> et <code>REPEAT</code></a></h4>
<p>L’énoncé <code>WHILE</code> a la forme suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql"><span class="kw">WHILE</span> (condition) <span class="kw">LOOP</span>
    &lt;SQL statement list&gt;
<span class="kw">END</span> <span class="kw">LOOP</span> [labelName];</code></pre>
<p>L’énoncé <code>REPEAT</code> a la forme suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql"><span class="kw">WHILE</span> (condition) DO
    &lt;SQL statement list&gt;
<span class="kw">END</span> <span class="kw">WHILE</span> [labelName];
REPEAT
    &lt;SQL statement list&gt;
<span class="kw">UNTIL</span> (condition)
<span class="kw">END</span> REPEAT [labelName];</code></pre>
</section>
</section>
</section>
</section>
<section id="annexe" class="level1">
<h1><a href="#annexe"><span class="header-section-number">8</span> Annexe</a></h1>
<dl>
<dt><strong>Abstraction des données</strong></dt>
<dd><p>Nom donné à l’approche qui cache la définition interne des données aux utilisateurs de la base de données et expose seulement la définition externe.</p>
</dd>
<dt><strong>Administrateur de la base de données (DBA)</strong></dt>
<dd><p>Est responsable de la réalisation physique de la base de données, incluant le design physique de la base de données et l’implantation, la sécurité, le contrôle d’intégrité, la maintenance du système opérationnel et d’assurer une performance satisfaisante des applications des utilisateurs.</p>
</dd>
<dt><strong>Administrateur des données (DA)</strong></dt>
<dd><p>Est responsable de gérer les ressources de données, incluant la planification de la base de données, le développement et la maintenance des standards, politiques et procédures. Il doit aussi s’occuper du design conceptuel/logique de la base de données.</p>
</dd>
<dt><strong>Agrégation</strong></dt>
<dd><p>Applique la liste des fonctions agrégates, <span class="math">\(AL\)</span>, à la relation <span class="math">\(R\)</span> pour définir une relation à partir de la liste agrégate. <span class="math">\(AL\)</span> contient une paire (<span class="math">\(\langle \text{ fonction_agrégate } \rangle , \langle \text{ attribut } \rangle\)</span> ou plus.</p>
</dd>
<dt><strong>Algèbre relationnelle</strong></dt>
<dd><p>Langage théorique avec des opérations qui marchent sur une ou plusieurs relations pour définir une autre relation sans changer la relation originale.</p>
</dd>
<dt><strong>Anomalies d’insertion</strong></dt>
<dd><p>Anomalies de mise à jour qui peuvent survenir lors de l’insertion d’un nouveau tuple.</p>
</dd>
<dt><strong>Anomalies de mise à jour</strong></dt>
<dd><p>Problèmes qui peuvent survenir lorsqu’on met à jour une base de données qui comporte de la redondance.</p>
</dd>
<dt><strong>Anomalies de modification</strong></dt>
<dd><p>Anomalies de mise à jour qui peuvent survenir lors de la modification d’un attribut.</p>
</dd>
<dt><strong>Anomalies de suppression</strong></dt>
<dd><p>Anomalies de mise à jour qui peuvent survenir lors de la suppression d’un tuple.</p>
</dd>
<dt><strong>Application de base de données</strong></dt>
<dd><p>Une application qui interagit avec la base de données à un certain point dans son exécution.</p>
</dd>
<dt><strong>Attribut (colonne ou champ)</strong></dt>
<dd><strong>Définition 1</strong>: Propriété qui décrit un aspect de l’objet que nous souhaitons enregistrer.
</dd>
<dd><strong>Définition 2</strong>: Colonne nommée d’une relation.
</dd>
<dd><p><strong>Définition 3</strong>: Décrit des propriétés des données ou des relations entre les données qui sont importantes pour l’entreprise.</p>
</dd>
<dt><strong>Base de données (BD)</strong></dt>
<dd><p>C’est une collection de données liées logiquement et sa description, conçu dans le but de répondre aux besoins d’information d’une organisation.</p>
</dd>
<dt><strong>Base de données relationnel</strong></dt>
<dd><p>Une collection de relations normalisées avec des noms distincts de relations.</p>
</dd>
<dt><strong>Cardinalité</strong></dt>
<dd><p>Le nombre de tuples que la relation contient.</p>
</dd>
<dt><strong>Catalogue système (dictionnaire de données ou metadata)</strong></dt>
<dd><p>Le nom donné à la description des données dans une base de données.</p>
</dd>
<dt><strong>Clé alternative (AK)</strong></dt>
<dd><p>Clé candidate qui n’a pas été choisie comme la clé primaire.</p>
</dd>
<dt><strong>Clé candidate (CK)</strong></dt>
<dd><p>Une superclé tel qu’aucun sous-ensemble propre est une superclé dans la relation.</p>
</dd>
<dt><strong>Clé composée</strong></dt>
<dd><p>Une clé candidate qui possède plus qu’un attribut.</p>
</dd>
<dt><strong>Clé primaire (PK)</strong></dt>
<dd><p>Clé candidate choisie pour identifier chaque tuple de manière unique dans la relation.</p>
</dd>
<dt><strong>Clé étrangère</strong></dt>
<dd><p>Un attribut, ou un ensemble d’attributs, à l’intérieur d’une relation qui correspond à la clé candidate d’une relation (possiblement la même).</p>
</dd>
<dt><strong>Compatible à l’union</strong></dt>
<dd><p>Quand les schémas de deux relations concordent, c’est-à-dire qu’ils ont le même nombre d’attributs avec chaque paire d’attributs correspondant ayant le même domaine.</p>
</dd>
<dt><strong>Concepteurs de bases de données logiques</strong></dt>
<dd><p>Responsables d’identifier les données (ou plutôt les entités et les attributs), les relations entre les données et les contraintes sur les données qui vont être enregistrées dans la base de données. Il doit avoir une bonne compréhension des données de l’organisation et des contraintes qui s’appliquent sur celles-ci.</p>
</dd>
<dt><strong>Concepteurs de bases de données physiques</strong></dt>
<dd><p>Décident comment la conception logique de la base de données va être physiquement implantée.</p>
</dd>
<dt><strong>Contraintes d’intégrité</strong></dt>
<dd><p>Restrictions sur l’ensemble des valeurs permises pour les attributs des relations.</p>
</dd>
<dt><strong>Contraintes générales</strong></dt>
<dd><p>Règles additionnelles spécifiées par les utilisateurs ou les administrateurs de bases de données de la base de données qui définissent ou contraignent des aspects de l’entreprise.</p>
</dd>
<dt><strong>Contraintes</strong></dt>
<dd><p>Règles de cohérence que la base de données ne peut enfreindre.</p>
</dd>
<dt><strong>Degré</strong></dt>
<dd><p>Le nombre d’attributs que la relation contient.</p>
</dd>
<dt><strong>Deuxième forme normale (2NF)</strong></dt>
<dd><strong>Définition</strong>: Une relation qui est dans la première forme normale et dont chaque attribut qui n’est pas une clé primaire est dépendant de la clé primaire.
</dd>
<dd><p><strong>Définition générale</strong>: Une relation qui est dans la première forme normale et dans laquelle tous les attributs qui ne font pas parties d’une clé candidate est <em>complètement dépendant</em> de n’importe quelle clé candidate.</p>
</dd>
<dt><strong>Différence</strong></dt>
<dd><p>Opération binaire de l’algèbre relationnelle qui définit une relation qui consiste des tuples qui sont dans la relation <span class="math">\(R\)</span>, mais pas dans la relation <span class="math">\(S\)</span>. <span class="math">\(R\)</span> et <span class="math">\(S\)</span> doivent être compatibles à l’union.</p>
</dd>
<dt><strong>Division</strong></dt>
<dd><p>Opération de l’algèbre relationnelle qui définit une relation à partir des attributs <span class="math">\(C\)</span>, où <span class="math">\(C\)</span> est l’ensemble des attributs de <span class="math">\(R\)</span> qui ne sont pas des attributs de <span class="math">\(S\)</span>, qui consiste à l’ensemble des tuples de <span class="math">\(R\)</span> qui concordent avec <em>tous</em> les tuples de <span class="math">\(S\)</span>.</p>
</dd>
<dt><strong>Domaine</strong></dt>
<dd><p>L’ensemble des valeurs allouées pour un ou plusieurs attributs.</p>
</dd>
<dt><strong>Décomposition d’opérations complexes</strong></dt>
<dd><p>Opération de l’algèbre relationnelle qui donne un nouveau nom à <span class="math">\(S\)</span> pour l’expression <span class="math">\(E\)</span>, et nomme optionnellement les attributs en <span class="math">\(a_1, a_2, \dots, a_n\)</span>. C’est une opération qui permet de donner un nom au résultat d’une opération relationnelle.</p>
</dd>
<dt><strong>Dépendance fonctionnelle (DF)</strong></dt>
<dd><p>Décrit le lien entre les attributs d’une relation.</p>
</dd>
<dt><strong>Dépendance fonctionnelle complète</strong></dt>
<dd><strong>Définition 1</strong>: Une dépendance fonctionnelle dans laquelle le déterminant à le nombre minimal d’attribut pour avoir une dépendance fonctionnelle avec les attributs à droite de la flèche.
</dd>
<dd><strong>Définition 2</strong>: Indique que si <span class="math">\(A\)</span> et <span class="math">\(B\)</span> sont des attributs d’une relation, <span class="math">\(B\)</span> est complètement fonctionnellement dépendant de <span class="math">\(A\)</span> si <span class="math">\(B\)</span> est fonctionnellement dépendant de <span class="math">\(A\)</span>, mais pas aucun sous-ensemble de <span class="math">\(A\)</span>.
</dd>
<dd><p><strong>Définition 3</strong>: Soit <span class="math">\(A\)</span> et <span class="math">\(B\)</span>, deux attributs d’une relation et <span class="math">\(C \subset A\)</span>, alors <span class="math">\((A \mapsto B) \land \neg (C \mapsto B)\)</span>.</p>
</dd>
<dt><strong>Dépendance multi-valuée</strong></dt>
<dd><p>Représente une dépendence entre des attributs (par exemple, <span class="math">\(A\)</span>, <span class="math">\(B\)</span> et <span class="math">\(C\)</span>) dans une relation, tel que pour chaque valeur de <span class="math">\(A\)</span>, il y un ensemble de valeurs <span class="math">\(B\)</span> et un ensemble de valeurs pour <span class="math">\(C\)</span>. Par contre, l’ensemble de valeurs de <span class="math">\(B\)</span> et <span class="math">\(C\)</span> sont indépendants chacun des autres.</p>
</dd>
<dt><strong>Dépendance partielle (DP)</strong></dt>
<dd><strong>Définition 1</strong>: Une dépendance fonctionnelle dans laquelle un des attributs peut être enlevé du déterminant et la dépendance fonctionnelle est encore valide.
</dd>
<dd><p><strong>Définition 2</strong>: Soit <span class="math">\(A\)</span> et <span class="math">\(B\)</span>, deux attributs d’une relation et <span class="math">\(C \subseteq A\)</span>, alors <span class="math">\(C \mapsto B\)</span>.</p>
</dd>
<dt><strong>Dépendance transitive (DT)</strong></dt>
<dd><strong>Définition 1</strong>: Si <span class="math">\(A\)</span>, <span class="math">\(B\)</span> et <span class="math">\(C\)</span> sont des attributs d’une relation tel que si <span class="math">\(A \mapsto B\)</span> et <span class="math">\(B \mapsto C\)</span>, alors <span class="math">\(C\)</span> est dépendant transitif de <span class="math">\(A\)</span> via <span class="math">\(B\)</span> (si <span class="math">\(A\)</span> n’est pas fonctionnellement dépendant de <span class="math">\(B\)</span> ou <span class="math">\(C\)</span>).
</dd>
<dd><p><strong>Définition 2</strong>: Soit <span class="math">\(A\)</span>, <span class="math">\(B\)</span> et <span class="math">\(C\)</span>, des attributs d’une relation tel que <span class="math">\((A \mapsto B) \land (B \mapsto C) \Rightarrow (A \mapsto C)\)</span>, si <span class="math">\(\neg (B \mapsto A) \lor \neg (C \mapsto A)\)</span></p>
</dd>
<dt><strong>Déterminant</strong></dt>
<dd><p>L’attribut, ou le groupe d’attributs, du côté gauche de la flèche d’une dépendance fonctionnelle.</p>
</dd>
<dt><strong>Entité</strong></dt>
<dd><p>Objet distinct (une personne, un endroit, une chose, un concept ou un événement) dans l’organisation qui doit être représenté dans la base de données.</p>
</dd>
<dt><strong>Equijointure</strong></dt>
<dd><p>Cas particulier de <span class="math">\(\theta\)</span>-join. C’est le cas où le prédicat <span class="math">\(F\)</span> contient seulement l’égalité (<span class="math">\(=\)</span>).</p>
</dd>
<dt><strong>Fermeture</strong></dt>
<dd><p>L’ensemble de toutes les dépendances fonctionnelles sous-entendues par un ensemble de dépendences fonctionnelles <span class="math">\(X\)</span>. Notée <span class="math">\(X^+\)</span>.</p>
</dd>
<dt><strong>Forme non normalisée (UNF)</strong></dt>
<dd><p>Une table qui contient une ou plusieurs répétitions de groupe.</p>
</dd>
<dt><strong>Forme normale de Boyce-Codd</strong></dt>
<dd><p>Une relation dont <em>tous</em> les <em>déterminants</em> sont des <em>clés candidates</em>.</p>
</dd>
<dt><strong>Indépendance des données</strong></dt>
<dd><p>La séparation de la description des données des applications rendant ainsi les applications immunisées aux changement de la description des données.</p>
</dd>
<dt><strong>Intersection</strong></dt>
<dd><p>Opération binaire de l’algèbre relationnelle qui définit une relation consistant de l’ensemble de tous les tuples qui sont à la fois dans <span class="math">\(R\)</span> et <span class="math">\(S\)</span>. <span class="math">\(R\)</span> et <span class="math">\(S\)</span> doivent être compatibles à l’union.</p>
</dd>
<dt><strong>Intégrité d’entité</strong></dt>
<dd><p>Règle d’intégrité qui stipule que, dans une relation de base, aucun attribut de la clé primaire ne peut être nul.</p>
</dd>
<dt><strong>Intégrité référentielle</strong></dt>
<dd><p>Règle d’intégrité qui stipule que, si une clé étrangère existe dans une relation, soit la valeur de la clé étrangère correspond à la valeur d’une clé candidate d’un tuple dans sa relation maison ou la valeur de la clé étrangère doit être complètement nulle.</p>
</dd>
<dt><strong>Jointure externe</strong></dt>
<dd><p>Jointure dans laquelle les tuples de <span class="math">\(R\)</span> qui n’ont pas de valeurs correspondantes avec les attributs en commun avec <span class="math">\(S\)</span> ne sont pas inclus dans la relation résultante. Les valeurs manquantes dans la deuxième relation sont mises à <em>null</em>.</p>
</dd>
<dt><strong>Jointure naturelle</strong></dt>
<dd><p>Equijointure des deux relations <span class="math">\(R\)</span> et <span class="math">\(S\)</span> sur tous leurs attributs communs <span class="math">\(x\)</span>. Une occurence de chacun des attributs communs est enlevée des résultats.</p>
</dd>
<dt><strong>Jointure theta (<span class="math">\(\theta\)</span>-join)</strong></dt>
<dd><p>Opération de l’algèbre relationnelle qui définit une relation qui contient les tuples satisfants le prédicat <span class="math">\(F\)</span> à partir du résultat du produit cartésien de <span class="math">\(R\)</span> et <span class="math">\(S\)</span>. Le prédicat <span class="math">\(F\)</span> est de la forme <span class="math">\(R.a_i~\theta~S.b_i\)</span> où <span class="math">\(\theta\)</span> peut être un des opérateur de comparaison (<span class="math">\(&lt; \)</span>, <span class="math">\(\leq\)</span>, <span class="math">\(&gt;\)</span>, <span class="math">\(\geq\)</span>, <span class="math">\(=\)</span>, <span class="math">\(\neq\)</span>).</p>
</dd>
<dt><strong>Langage de définition des données (DDL)</strong></dt>
<dd><p>Permet aux utilisateurs de spécifier les types, les structures et les contraintes à appliquer sur les données qui seront entreposées dans la base de données.</p>
</dd>
<dt><strong>Langage de manipulation des données (DML)</strong></dt>
<dd><p>Permet aux utilisateurs d’insérer, de mettre à jour, d’effacer et d’aller chercher des données dans la base de données.</p>
</dd>
<dt><strong>Langage de requête</strong></dt>
<dd><p>Permet de faire les opérations des langages de manipulation des données. Un exemple de langage de requête est le <em>SQL</em>.</p>
</dd>
<dt><strong>Normalisation</strong></dt>
<dd><strong>Définition 1</strong>: Une technique pour produire un ensemble de relations avec des propriétés désirables selon les besoins de données de l’entreprise.
</dd>
<dd><p><strong>Définition 2</strong>: Une technique formelle pour analyser les relations basée sur leur clé primaire (ou clés candidates) et les dépendances fonctionnelles.</p>
</dd>
<dt><strong>Null</strong></dt>
<dd><p>Représente une valeur pour un attribut qui est présentement inconnu ou pas applicable pour ce tuple.</p>
</dd>
<dt><strong>Opérations de jointure</strong></dt>
<dd><strong>Définition textuelle</strong>: Opération de l’algèbre relationnelle qui est équivalente à appliquer l’opération de sélection avec le prédicat de jointure au résultat du produit cartésien des deux relations d’entrée.
</dd>
<dd><p><strong>Définition mathématique</strong>: Si <span class="math">\(F\)</span> est le prédicat de jointure et <span class="math">\(R\)</span> ainsi que <span class="math">\(S\)</span> sont deux relations, alors l’opération de jointure entre les deux relations peut être décrite comme <span class="math">\(\sigma_{F}(R \times S)\)</span>.</p>
</dd>
<dt><strong>Première forme normale (1NF)</strong></dt>
<dd><p>Une relation dans laquelle l’intersection de chaque ligne et colonne contient seulement une valeur.</p>
</dd>
<dt><strong>Produit cartésien</strong></dt>
<dd><p>Opération binaire de l’algèbre relationnelle qui définit une relation qui est la concaténation de tous les tuples de la relation <span class="math">\(R\)</span> avec tous les tuples de la relation <span class="math">\(S\)</span>.</p>
</dd>
<dt><strong>Programme d’application</strong></dt>
<dd><p>Un programme informatique qui interagit avec la base de données en envoyant des requêtes (la plupart du temps des instructions <em>SQL</em>) au système de gestion des bases de données.</p>
</dd>
<dt><strong>Projection</strong></dt>
<dd><p>Opération unaire de l’algèbre relationnelle qui s’applique sur une seule relation <span class="math">\(R\)</span> et définie une relation qui contient un sous-ensemble vertical de <span class="math">\(R\)</span>. Elle extrait les valeurs des attributs spécifiés et élimine les copies.</p>
</dd>
<dt><strong>Quatrième forme normale</strong></dt>
<dd><p>Une relation dont toutes les dépendences multi-valuées non-triviales <span class="math">\(A \twoheadrightarrow B\)</span> ont comme propriété que <span class="math">\(A\)</span> est une clé candidate de la relation.</p>
</dd>
<dt><strong>Regroupement</strong></dt>
<dd><p>Groupe les tuples de la relation <span class="math">\(R\)</span> par les attributs de groupement, <span class="math">\(GA\)</span>, et applique ensuite la liste de fonctions agrégates <span class="math">\(AL\)</span> pour définir une nouvelle relation. <span class="math">\(AL\)</span> contient une paire (<span class="math">\(\langle \text{ fonction_agrégate } \rangle , \langle \text{ attribut } \rangle\)</span> ou plus. La relation résultante contient les attributs de groupement <span class="math">\(GA\)</span> avec le résultat de chacune des fonctions agrégates.</p>
</dd>
<dt><strong>Relation (table ou fichier)</strong></dt>
<dd><strong>Définition 1</strong>: Une association entre plusieurs entités.
</dd>
<dd><p><strong>Définition 2</strong>: Table avec des lignes et des colonnes.</p>
</dd>
<dt><strong>Relation de base</strong></dt>
<dd><strong>Définition 1</strong>: Relation qui correspond à une entité dans le schéma conceptuel.
</dd>
<dd><p><strong>Définition 2</strong>: Relation nommée qui correspond à une entité dans le schéma conceptuel, dont les tuples sont entreposés physiquement dans la base de données.</p>
</dd>
<dt><strong>Relation virtuelle (relation dérivée)</strong></dt>
<dd><p>Relation qui n’existe pas par elle-même, mais qui peut être dérivée dynamiquement d’une ou plusieurs relations de base.</p>
</dd>
<dt><strong>Règles d’affaires</strong></dt>
<dd><p>Les contraintes d’une organisation sur les données.</p>
</dd>
<dt><strong>Règles d’intégrité</strong></dt>
<dd><p>Contraintes ou restrictions qui s’appliquent sur toutes les instances de la base de données.</p>
</dd>
<dt><strong>Schéma conceptuel (modèle conceptuel)</strong></dt>
<dd><p>L’ensemble de tous les schémas de la base de données.</p>
</dd>
<dt><strong>Schéma de base de données relationnel</strong></dt>
<dd><p>Un ensemble de schémas de relation avec chacun un nom distinct.</p>
</dd>
<dt><strong>Schéma de relation</strong></dt>
<dd><p>Une relation nommée définie par un ensemble d’attributs et de paires de noms de domaines.</p>
</dd>
<dt><strong>Schéma</strong></dt>
<dd><p>Structure de la base de données.</p>
</dd>
<dt><strong>Semi-jointure</strong></dt>
<dd><p>Définit une relation qui contient les tuples de <span class="math">\(R\)</span> qui participent dans la jointure de <span class="math">\(R\)</span> avec <span class="math">\(S\)</span> satisfaisant le prédicat <span class="math">\(F\)</span>.</p>
</dd>
<dt><strong>Superclé</strong></dt>
<dd><p>Attribut, ou un ensemble d’attributs, qui identifient de manière unique un tuple dans une relation.</p>
</dd>
<dt><strong>Système de base de données</strong></dt>
<dd><p>L’ensemble des applications qui interagissent avec la base de données et le système de gestion de base de données.</p>
</dd>
<dt><strong>Système de gestion de base de données (DBMS ou SGBD (en français))</strong></dt>
<dd><p>Un logiciel qui permet aux utilisateurs de définir, maintenir et contrôler l’accès à la base de données.</p>
</dd>
<dt><strong>Sélection</strong></dt>
<dd><p>Opération unaire de l’algèbre relationnelle qui s’applique sur une seule relation <span class="math">\(R\)</span> et définit une relation qui contient seulement les tuples de <span class="math">\(R\)</span> qui satisfont la condition spécifée (le <em>prédicat</em>).</p>
</dd>
<dt><strong>Troisième forme normale (3NF)</strong></dt>
<dd><strong>Définition</strong>: Une relation qui est dans la première et deuxième forme normale et dans laquelle aucun attribut qui ne fait pas partie de la clé primaire est transitivement dépendant de la clé primaire.
</dd>
<dd><p><strong>Définition générale</strong>: Une relation qui est dans la première et deuxième forme normale et dans laquelle aucun attribut qui ne fait pas partie d’une clé candidate est transitivement dépendant d’une clé candidate.</p>
</dd>
<dt><strong>Tuple (ligne ou archive)</strong></dt>
<dd><p>Nom donné à une ligne dans une relation (ou table).</p>
</dd>
<dt><strong>Union</strong></dt>
<dd><p>L’union de deux relations <span class="math">\(R\)</span> et <span class="math">\(S\)</span> définit une relation qui contient tous les tuples de <span class="math">\(R\)</span> ou de <span class="math">\(S\)</span> ou bien des deux relations. Les tuples copies sont éliminés. <span class="math">\(R\)</span> et <span class="math">\(S\)</span> doivent être compatibles à l’union.</p>
</dd>
<dt><strong>Utilisateurs naïfs</strong></dt>
<dd><p>Ignorent tout du système de gestion de bases de données. Ils accèdent à la base de données par des programmes spécifiques. Ils utilisent les opérations de bases de données en appuyant sur des boutons ou en entrant des commandes simples.</p>
</dd>
<dt><strong>Utilisateurs sophistiqués</strong></dt>
<dd><p>Familiés avec la structure de la base de données et des installations fournies par le système de gestion de bases de données. Ils sont capable d’utiliser un langage de requêtes comme le <em>SQL</em> pour exécuter les opérations requises. Ils sont parfois même capables d’écrire des applications pour leur propre usage.</p>
</dd>
<dt><strong>Vue</strong></dt>
<dd><p>Résultat dynamique d’une ou plusieurs opérations opérant sur les relations de base afin de produire une autre relation. Une vue est une <em>relation virtuelle</em> qui n’existe pas nécessairement dans la base de données mais qui peut être produite sur demande par un utilisateur donné au moment de la requête.</p>
</dd>
</dl>
</section>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Il est important de se rappeler que ces annotations sont propres aux bases de données <em>Oracle</em>.<a href="#fnref1">↩</a></p></li>
</ol>
</section>
<script>
    document.getElementById("TOC").className = "mobile-hidden";

    var button = document.getElementById("toggle-nav");

    button.addEventListener("click", function() {
        var tableOfContents = document.getElementById("TOC");
        var navbar = document.getElementsByClassName("navbar")[0];
        if (tableOfContents.className === "") {
            navbar.id = "";
            tableOfContents.className = "mobile-hidden";
        }
        else {
            navbar.id = "fixed-navbar";
            tableOfContents.className = "";
        }
    }, false);
</script>
</body>
</html>
