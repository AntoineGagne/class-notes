<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Antoine Gagné">
  <title>Notes de cours</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="../../web_notes/css/notes_style.css">
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<div class="navbar">
    <button id="toggle-nav">
        <span class="sr-only">Toggle navigation</span>
        <span class="bar"></span>
        <span class="bar"></span>
        <span class="bar"></span>
    </button>
</div>
<header>
<h1 class="title">Notes de cours</h1>
<h2 class="author">Antoine Gagné</h2>
<h3 class="date">5 février 2016</h3>
</header>
<nav id="TOC">
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a><ul>
<li><a href="#lancêtre-des-bases-de-données"><span class="toc-section-number">1.1</span> L’ancêtre des bases de données</a><ul>
<li><a href="#problèmes"><span class="toc-section-number">1.1.1</span> Problèmes</a><ul>
<li><a href="#séparation-et-isolation-des-données"><span class="toc-section-number">1.1.1.1</span> Séparation et isolation des données</a></li>
<li><a href="#duplication-des-données"><span class="toc-section-number">1.1.1.2</span> Duplication des données</a></li>
<li><a href="#dépendences-des-données"><span class="toc-section-number">1.1.1.3</span> Dépendences des données</a></li>
<li><a href="#format-de-fichiers"><span class="toc-section-number">1.1.1.4</span> Format de fichiers</a></li>
<li><a href="#requêtes-fixes-et-prolifération-de-programmes"><span class="toc-section-number">1.1.1.5</span> Requêtes fixes et prolifération de programmes</a></li>
<li><a href="#résumé"><span class="toc-section-number">1.1.1.6</span> Résumé</a></li>
</ul></li>
</ul></li>
<li><a href="#lapproche-par-base-de-données"><span class="toc-section-number">1.2</span> L’approche par base de données</a><ul>
<li><a href="#les-bases-de-données"><span class="toc-section-number">1.2.1</span> Les bases de données</a><ul>
<li><a href="#définition"><span class="toc-section-number">1.2.1.1</span> Définition</a></li>
<li><a href="#avantages"><span class="toc-section-number">1.2.1.2</span> Avantages</a></li>
</ul></li>
<li><a href="#les-systèmes-de-gestion-de-bases-de-données-dbms-ou-sgbd"><span class="toc-section-number">1.2.2</span> Les systèmes de gestion de bases de données (DBMS ou SGBD)</a><ul>
<li><a href="#définition-1"><span class="toc-section-number">1.2.2.1</span> Définition</a></li>
<li><a href="#fonctionnalités-fournies"><span class="toc-section-number">1.2.2.2</span> Fonctionnalités fournies</a></li>
<li><a href="#avantages-1"><span class="toc-section-number">1.2.2.3</span> Avantages</a><ul>
<li><a href="#contrôle-de-la-redondance-des-données"><span class="toc-section-number">1.2.2.3.1</span> Contrôle de la redondance des données</a></li>
<li><a href="#cohérence-des-données"><span class="toc-section-number">1.2.2.3.2</span> Cohérence des données</a></li>
<li><a href="#plus-dinformations-avec-le-même-nombre-de-données"><span class="toc-section-number">1.2.2.3.3</span> Plus d’informations avec le même nombre de données</a></li>
<li><a href="#partage-des-données"><span class="toc-section-number">1.2.2.3.4</span> Partage des données</a></li>
<li><a href="#meilleure-intégrité-des-données"><span class="toc-section-number">1.2.2.3.5</span> Meilleure intégrité des données</a></li>
<li><a href="#sécurité-accrue"><span class="toc-section-number">1.2.2.3.6</span> Sécurité accrue</a></li>
<li><a href="#application-des-standards"><span class="toc-section-number">1.2.2.3.7</span> Application des standards</a></li>
<li><a href="#économies-de-taille"><span class="toc-section-number">1.2.2.3.8</span> Économies de taille</a></li>
<li><a href="#balance-de-besoins-contradictoires"><span class="toc-section-number">1.2.2.3.9</span> Balance de besoins contradictoires</a></li>
<li><a href="#amélioration-de-laccessibilité-et-de-la-réactivité-des-données"><span class="toc-section-number">1.2.2.3.10</span> Amélioration de l’accessibilité et de la réactivité des données</a></li>
<li><a href="#productivité-accrue"><span class="toc-section-number">1.2.2.3.11</span> Productivité accrue</a></li>
<li><a href="#maintenance-améliorée-grâce-à-lindépendence-des-données"><span class="toc-section-number">1.2.2.3.12</span> Maintenance améliorée grâce à l’indépendence des données</a></li>
<li><a href="#amélioration-de-laccès-simultané"><span class="toc-section-number">1.2.2.3.13</span> Amélioration de l’accès simultané</a></li>
<li><a href="#meilleurs-services-de-restauration-et-de-sauvegarde-des-données"><span class="toc-section-number">1.2.2.3.14</span> Meilleurs services de restauration et de sauvegarde des données</a></li>
</ul></li>
<li><a href="#désavantages"><span class="toc-section-number">1.2.2.4</span> Désavantages</a><ul>
<li><a href="#complexité"><span class="toc-section-number">1.2.2.4.1</span> Complexité</a></li>
<li><a href="#taille"><span class="toc-section-number">1.2.2.4.2</span> Taille</a></li>
<li><a href="#coût-des-systèmes-de-gestion-de-bases-de-données"><span class="toc-section-number">1.2.2.4.3</span> Coût des systèmes de gestion de bases de données</a></li>
<li><a href="#coûts-additionnels-de-matériel"><span class="toc-section-number">1.2.2.4.4</span> Coûts additionnels de matériel</a></li>
<li><a href="#coût-de-conversion"><span class="toc-section-number">1.2.2.4.5</span> Coût de conversion</a></li>
<li><a href="#performance"><span class="toc-section-number">1.2.2.4.6</span> Performance</a></li>
<li><a href="#plus-gros-impact-en-cas-de-défaillance."><span class="toc-section-number">1.2.2.4.7</span> Plus gros impact en cas de défaillance.</a></li>
</ul></li>
<li><a href="#mécanisme-de-vision"><span class="toc-section-number">1.2.2.5</span> Mécanisme de vision</a><ul>
<li><a href="#bénéfices"><span class="toc-section-number">1.2.2.5.1</span> Bénéfices</a></li>
</ul></li>
<li><a href="#composants-dun-système-de-gestion-de-bases-de-données"><span class="toc-section-number">1.2.2.6</span> Composants d’un système de gestion de bases de données</a><ul>
<li><a href="#matériel"><span class="toc-section-number">1.2.2.6.1</span> Matériel</a></li>
<li><a href="#logiciel"><span class="toc-section-number">1.2.2.6.2</span> Logiciel</a></li>
<li><a href="#données"><span class="toc-section-number">1.2.2.6.3</span> Données</a></li>
<li><a href="#procédures"><span class="toc-section-number">1.2.2.6.4</span> Procédures</a></li>
<li><a href="#humains"><span class="toc-section-number">1.2.2.6.5</span> Humains</a></li>
</ul></li>
<li><a href="#conception-de-bases-de-données"><span class="toc-section-number">1.2.2.7</span> Conception de bases de données</a></li>
<li><a href="#rôles-dans-un-environnement-de-bases-de-données"><span class="toc-section-number">1.2.2.8</span> Rôles dans un environnement de bases de données</a><ul>
<li><a href="#administrateurs-des-données-et-de-la-base-de-données"><span class="toc-section-number">1.2.2.8.1</span> Administrateurs des données et de la base de données</a></li>
<li><a href="#concepteurs-de-bases-de-données"><span class="toc-section-number">1.2.2.8.2</span> Concepteurs de bases de données</a></li>
<li><a href="#développeurs-dapplication"><span class="toc-section-number">1.2.2.8.3</span> Développeurs d’application</a></li>
<li><a href="#utilisateurs"><span class="toc-section-number">1.2.2.8.4</span> Utilisateurs</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#modèle-relationnel"><span class="toc-section-number">2</span> Modèle relationnel</a><ul>
<li><a href="#structure-des-données-relationnelles"><span class="toc-section-number">2.1</span> Structure des données relationnelles</a></li>
<li><a href="#relations-mathématiques"><span class="toc-section-number">2.2</span> Relations mathématiques</a></li>
<li><a href="#relations-des-bases-de-données"><span class="toc-section-number">2.3</span> Relations des bases de données</a></li>
<li><a href="#propriétés-des-relations"><span class="toc-section-number">2.4</span> Propriétés des relations</a></li>
<li><a href="#clés-relationnelles"><span class="toc-section-number">2.5</span> Clés relationnelles</a><ul>
<li><a href="#superclé"><span class="toc-section-number">2.5.1</span> Superclé</a></li>
<li><a href="#clé-candidate"><span class="toc-section-number">2.5.2</span> Clé candidate</a></li>
<li><a href="#clé-composée"><span class="toc-section-number">2.5.3</span> Clé composée</a></li>
<li><a href="#clé-primaire"><span class="toc-section-number">2.5.4</span> Clé primaire</a></li>
<li><a href="#clé-alternative"><span class="toc-section-number">2.5.5</span> Clé alternative</a></li>
<li><a href="#clé-étrangère"><span class="toc-section-number">2.5.6</span> Clé étrangère</a></li>
</ul></li>
<li><a href="#contraintes-dintégrité"><span class="toc-section-number">2.6</span> Contraintes d’intégrité</a><ul>
<li><a href="#null"><span class="toc-section-number">2.6.1</span> Null</a></li>
<li><a href="#intégrité-dentité"><span class="toc-section-number">2.6.2</span> Intégrité d’entité</a></li>
<li><a href="#intégrité-référentielle"><span class="toc-section-number">2.6.3</span> Intégrité référentielle</a></li>
<li><a href="#contraintes-générales"><span class="toc-section-number">2.6.4</span> Contraintes générales</a></li>
</ul></li>
<li><a href="#vues"><span class="toc-section-number">2.7</span> Vues</a><ul>
<li><a href="#définition-2"><span class="toc-section-number">2.7.1</span> Définition</a></li>
<li><a href="#utilités"><span class="toc-section-number">2.7.2</span> Utilités</a></li>
<li><a href="#mise-à-jour-des-vues"><span class="toc-section-number">2.7.3</span> Mise à jour des vues</a></li>
</ul></li>
</ul></li>
<li><a href="#normalisation"><span class="toc-section-number">3</span> Normalisation</a><ul>
<li><a href="#redondance-de-données-et-anomalies-de-mises-à-jour"><span class="toc-section-number">3.1</span> Redondance de données et anomalies de mises à jour</a><ul>
<li><a href="#anomalies-dinsertion"><span class="toc-section-number">3.1.1</span> Anomalies d’insertion</a></li>
<li><a href="#anomalies-de-suppression"><span class="toc-section-number">3.1.2</span> Anomalies de suppression</a></li>
<li><a href="#anomalies-de-modification"><span class="toc-section-number">3.1.3</span> Anomalies de modification</a></li>
</ul></li>
<li><a href="#dépendances-fonctionnelles"><span class="toc-section-number">3.2</span> Dépendances fonctionnelles</a><ul>
<li><a href="#définition-3"><span class="toc-section-number">3.2.1</span> Définition</a></li>
<li><a href="#déterminant"><span class="toc-section-number">3.2.2</span> Déterminant</a></li>
<li><a href="#dépendance-fonctionnelle-complète"><span class="toc-section-number">3.2.3</span> Dépendance fonctionnelle complète</a></li>
<li><a href="#dépendance-fonctionnelle-partielle"><span class="toc-section-number">3.2.4</span> Dépendance fonctionnelle partielle</a></li>
<li><a href="#dépendance-transitive"><span class="toc-section-number">3.2.5</span> Dépendance transitive</a></li>
<li><a href="#résumé-1"><span class="toc-section-number">3.2.6</span> Résumé</a></li>
</ul></li>
<li><a href="#normalisation-et-formes-normales"><span class="toc-section-number">3.3</span> Normalisation et formes normales</a><ul>
<li><a href="#définition-de-la-normalisation"><span class="toc-section-number">3.3.1</span> Définition de la normalisation</a></li>
<li><a href="#forme-non-normalisée-unf-à-première-forme-normale"><span class="toc-section-number">3.3.2</span> Forme non normalisée (UNF) à première forme normale</a><ul>
<li><a href="#définition-de-la-forme-non-normalisée-unf"><span class="toc-section-number">3.3.2.1</span> Définition de la forme non normalisée (UNF)</a></li>
<li><a href="#définition-de-la-première-forme-normale-1nf"><span class="toc-section-number">3.3.2.2</span> Définition de la première forme normale (1NF)</a></li>
<li><a href="#technique-de-normalisation"><span class="toc-section-number">3.3.2.3</span> Technique de normalisation</a><ul>
<li><a href="#mise-à-plat"><span class="toc-section-number">3.3.2.3.1</span> Mise à plat</a></li>
<li><a href="#séparer-les-données-dupliquées"><span class="toc-section-number">3.3.2.3.2</span> Séparer les données dupliquées</a></li>
</ul></li>
</ul></li>
<li><a href="#première-forme-normale-à-la-deuxième-forme-normale"><span class="toc-section-number">3.3.3</span> Première forme normale à la deuxième forme normale</a><ul>
<li><a href="#définition-de-la-deuxième-forme-normale-2nf"><span class="toc-section-number">3.3.3.1</span> Définition de la deuxième forme normale (2NF)</a></li>
<li><a href="#technique-de-normalisation-1"><span class="toc-section-number">3.3.3.2</span> Technique de normalisation</a></li>
</ul></li>
<li><a href="#deuxième-forme-normale-à-la-troisième-forme-normale"><span class="toc-section-number">3.3.4</span> Deuxième forme normale à la troisième forme normale</a><ul>
<li><a href="#définition-de-la-troisième-forme-normale-3nf"><span class="toc-section-number">3.3.4.1</span> Définition de la troisième forme normale (3NF)</a></li>
<li><a href="#technique-de-normalisation-2"><span class="toc-section-number">3.3.4.2</span> Technique de normalisation</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#normalisation-avancée"><span class="toc-section-number">4</span> Normalisation avancée</a><ul>
<li><a href="#règles-dinférence-des-dépendances-fonctionnelles"><span class="toc-section-number">4.1</span> Règles d’inférence des dépendances fonctionnelles</a><ul>
<li><a href="#axiomes-darmstrong"><span class="toc-section-number">4.1.1</span> Axiomes d’Armstrong</a></li>
<li><a href="#ensembles-minimaux-de-dépendances-fonctionnelles"><span class="toc-section-number">4.1.2</span> Ensembles minimaux de dépendances fonctionnelles</a></li>
</ul></li>
<li><a href="#forme-normale-de-boyce-codd-bcnf"><span class="toc-section-number">4.2</span> Forme normale de Boyce-Codd (BCNF)</a><ul>
<li><a href="#définition-4"><span class="toc-section-number">4.2.1</span> Définition</a></li>
<li><a href="#technique-de-normalisation-3"><span class="toc-section-number">4.2.2</span> Technique de normalisation</a></li>
</ul></li>
<li><a href="#dépendance-multi-valuée"><span class="toc-section-number">4.3</span> Dépendance multi-valuée</a><ul>
<li><a href="#définition-5"><span class="toc-section-number">4.3.1</span> Définition</a></li>
<li><a href="#types-de-dépendances-multi-valuées"><span class="toc-section-number">4.3.2</span> Types de dépendances multi-valuées</a></li>
</ul></li>
<li><a href="#quatrième-forme-normale"><span class="toc-section-number">4.4</span> Quatrième forme normale</a><ul>
<li><a href="#définition-6"><span class="toc-section-number">4.4.1</span> Définition</a></li>
<li><a href="#technique-de-normalisation-4"><span class="toc-section-number">4.4.2</span> Technique de normalisation</a></li>
</ul></li>
</ul></li>
<li><a href="#algèbre-relationnelle"><span class="toc-section-number">5</span> Algèbre relationnelle</a><ul>
<li><a href="#définition-7"><span class="toc-section-number">5.1</span> Définition</a></li>
<li><a href="#opérations"><span class="toc-section-number">5.2</span> Opérations</a><ul>
<li><a href="#opérations-unaires"><span class="toc-section-number">5.2.1</span> Opérations unaires</a><ul>
<li><a href="#sélection-ou-restriction"><span class="toc-section-number">5.2.1.1</span> Sélection (ou restriction)</a></li>
<li><a href="#projection"><span class="toc-section-number">5.2.1.2</span> Projection</a></li>
</ul></li>
<li><a href="#opérations-binaires"><span class="toc-section-number">5.2.2</span> Opérations binaires</a><ul>
<li><a href="#union"><span class="toc-section-number">5.2.2.1</span> Union</a></li>
<li><a href="#différence"><span class="toc-section-number">5.2.2.2</span> Différence</a></li>
<li><a href="#intersection"><span class="toc-section-number">5.2.2.3</span> Intersection</a></li>
<li><a href="#produit-cartésien"><span class="toc-section-number">5.2.2.4</span> Produit cartésien</a></li>
<li><a href="#décomposition-dopérations-complexes"><span class="toc-section-number">5.2.2.5</span> Décomposition d’opérations complexes</a></li>
</ul></li>
<li><a href="#opérations-de-jointure"><span class="toc-section-number">5.2.3</span> Opérations de jointure</a><ul>
<li><a href="#jointure-theta-theta-join"><span class="toc-section-number">5.2.3.1</span> Jointure theta (<span class="math">\(\theta\)</span>-join)</a></li>
<li><a href="#equijointure"><span class="toc-section-number">5.2.3.2</span> Equijointure</a></li>
<li><a href="#jointure-naturelle"><span class="toc-section-number">5.2.3.3</span> Jointure naturelle</a></li>
<li><a href="#jointure-externe"><span class="toc-section-number">5.2.3.4</span> Jointure externe</a></li>
<li><a href="#semi-jointure"><span class="toc-section-number">5.2.3.5</span> Semi-jointure</a></li>
</ul></li>
<li><a href="#division"><span class="toc-section-number">5.2.4</span> Division</a></li>
<li><a href="#agrégation"><span class="toc-section-number">5.2.5</span> Agrégation</a></li>
<li><a href="#regroupement"><span class="toc-section-number">5.2.6</span> Regroupement</a></li>
</ul></li>
</ul></li>
<li><a href="#structured-query-language-sql-manipulation-des-données"><span class="toc-section-number">6</span> Structured Query Language (SQL) : Manipulation des données</a><ul>
<li><a href="#objectifs-du-sql"><span class="toc-section-number">6.1</span> Objectifs du SQL</a></li>
<li><a href="#informations-sur-le-sql"><span class="toc-section-number">6.2</span> Informations sur le SQL</a><ul>
<li><a href="#terminalogie"><span class="toc-section-number">6.2.1</span> Terminalogie</a></li>
</ul></li>
<li><a href="#écrire-des-commandes-sql"><span class="toc-section-number">6.3</span> Écrire des commandes SQL</a><ul>
<li><a href="#convention-de-code"><span class="toc-section-number">6.3.1</span> Convention de code</a></li>
<li><a href="#manipulation-des-données"><span class="toc-section-number">6.3.2</span> Manipulation des données</a></li>
<li><a href="#litéraux"><span class="toc-section-number">6.3.3</span> Litéraux</a></li>
<li><a href="#select"><span class="toc-section-number">6.3.4</span> SELECT</a><ul>
<li><a href="#exemples-dutilisation-du-select"><span class="toc-section-number">6.3.4.1</span> Exemples d’utilisation du SELECT</a><ul>
<li><a href="#aller-chercher-toutes-les-colonnes-et-rangées"><span class="toc-section-number">6.3.4.1.1</span> Aller chercher toutes les colonnes et rangées</a></li>
<li><a href="#aller-chercher-des-colonnes-spécifiques-et-toutes-les-rangées"><span class="toc-section-number">6.3.4.1.2</span> Aller chercher des colonnes spécifiques et toutes les rangées</a></li>
<li><a href="#utiliser-distinct"><span class="toc-section-number">6.3.4.1.3</span> Utiliser DISTINCT</a></li>
<li><a href="#champs-calculés"><span class="toc-section-number">6.3.4.1.4</span> Champs calculés</a></li>
</ul></li>
<li><a href="#sélection-de-rangées-where"><span class="toc-section-number">6.3.4.2</span> Sélection de rangées (WHERE)</a><ul>
<li><a href="#exemples-dutilisation-du-where"><span class="toc-section-number">6.3.4.2.1</span> Exemples d’utilisation du WHERE</a><ul>
<li><a href="#prédicat-de-comparaison"><span class="toc-section-number">6.3.4.2.1.1</span> Prédicat de comparaison</a></li>
<li><a href="#prédicat-de-comparaison-composé"><span class="toc-section-number">6.3.4.2.1.2</span> Prédicat de comparaison composé</a></li>
<li><a href="#prédicat-de-recherche-décart-betweennot-between"><span class="toc-section-number">6.3.4.2.1.3</span> Prédicat de recherche d’écart (BETWEEN/NOT BETWEEN)</a></li>
<li><a href="#prédicat-dappartenance-à-un-ensemble-innot-in"><span class="toc-section-number">6.3.4.2.1.4</span> Prédicat d’appartenance à un ensemble (IN/NOT IN)</a></li>
<li><a href="#prédicat-de-correspondance-à-un-masque-likenot-like"><span class="toc-section-number">6.3.4.2.1.5</span> Prédicat de correspondance à un masque (LIKE/NOT LIKE)</a></li>
<li><a href="#prédicat-de-recherche-de-null-is-nullis-not-null"><span class="toc-section-number">6.3.4.2.1.6</span> Prédicat de recherche de NULL (IS NULL/IS NOT NULL)</a></li>
</ul></li>
</ul></li>
<li><a href="#trier-les-résultats-order-by"><span class="toc-section-number">6.3.4.3</span> Trier les résultats (ORDER BY)</a><ul>
<li><a href="#exemples-dutilisation-du-order-by"><span class="toc-section-number">6.3.4.3.1</span> Exemples d’utilisation du ORDER BY</a><ul>
<li><a href="#tri-avec-une-seule-colonne"><span class="toc-section-number">6.3.4.3.1.1</span> Tri avec une seule colonne</a></li>
<li><a href="#tri-avec-plusieurs-colonnes"><span class="toc-section-number">6.3.4.3.1.2</span> Tri avec plusieurs colonnes</a></li>
</ul></li>
</ul></li>
<li><a href="#fonctions-sql-dagrégation"><span class="toc-section-number">6.3.4.4</span> Fonctions SQL d’agrégation</a><ul>
<li><a href="#exemples-dutilisation-des-fonctions-sql-dagrégation"><span class="toc-section-number">6.3.4.4.1</span> Exemples d’utilisation des fonctions SQL d’agrégation</a><ul>
<li><a href="#utilisation-de-count"><span class="toc-section-number">6.3.4.4.1.1</span> Utilisation de <code>COUNT(*)</code></a></li>
<li><a href="#utilisation-de-countdistinct"><span class="toc-section-number">6.3.4.4.1.2</span> Utilisation de <code>COUNT(DISTINCT)</code></a></li>
<li><a href="#utilisation-de-count-et-sum"><span class="toc-section-number">6.3.4.4.1.3</span> Utilisation de <code>COUNT</code> et <code>SUM</code></a></li>
<li><a href="#utilisation-de-min-max-et-avg"><span class="toc-section-number">6.3.4.4.1.4</span> Utilisation de <code>MIN</code>, <code>MAX</code> et <code>AVG</code></a></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#annexe"><span class="toc-section-number">7</span> Annexe</a></li>
</ul>
</nav>
<p>Ce document regroupe l’ensemble de mes notes pour le cours <strong>Modèles et langages de bases de données</strong>.</p>
<section id="introduction" class="level1">
<h1><a href="#introduction"><span class="header-section-number">1</span> Introduction</a></h1>
<p>Ce chapitre est une introduction aux bases de données et aux système de gestion de bases de données. Il expliquera leur raison d’exister, les fonctions typiques, les composants majeurs, etc.</p>
<section id="lancêtre-des-bases-de-données" class="level2">
<h2><a href="#lancêtre-des-bases-de-données"><span class="header-section-number">1.1</span> L’ancêtre des bases de données</a></h2>
<p>Le prédécesseur des bases de données est l’approche par fichiers. Cette approche utilisait un système décentralisé où chaque système avait ses propres données.</p>
<section id="problèmes" class="level3">
<h3><a href="#problèmes"><span class="header-section-number">1.1.1</span> Problèmes</a></h3>
<p>L’approche par fichiers comprend cinq problèmes majeurs.</p>
<section id="séparation-et-isolation-des-données" class="level4">
<h4><a href="#séparation-et-isolation-des-données"><span class="header-section-number">1.1.1.1</span> Séparation et isolation des données</a></h4>
<p>Dans une approche par fichiers, les données sont séparées et isolées. Cela fait en sorte qu’il est plus difficile d’accéder aux données. Lorsqu’on veut accéder à des données, on doit synchroniser notre traitement des fichiers pour s’assurer que les bonnes données sont extraites.</p>
</section>
<section id="duplication-des-données" class="level4">
<h4><a href="#duplication-des-données"><span class="header-section-number">1.1.1.2</span> Duplication des données</a></h4>
<p>Un autre problème de cette approche est la duplication des données. Chaque département a sa propre version des données. Cela fait en sorte que les départements vont avoir des données identiques entre eux dans certains cas. C’est donc du gaspillage de temps et d’argent, car les données être entrées plusieurs fois par des personnes différentes. De plus, ça veut également dire qu’il y a plus d’espace de stockage qui est pris. Finalement, il y a plus de risques d’avoir des informations incorrectes, car il peut y arriver que la synchronisation entre les différents fichiers des départements ne s’est pas bien faite.</p>
</section>
<section id="dépendences-des-données" class="level4">
<h4><a href="#dépendences-des-données"><span class="header-section-number">1.1.1.3</span> Dépendences des données</a></h4>
<p>Les programmes dépendent d’un format de fichier particulier. Si le format change, toutes les applications connectées à ce fichier doivent changer aussi. Le format des données est donc assez rigide, car il n’y a pas d’abstraction quant à la disposition de celles-ci. De plus, changer une adresse de données va nécessiter la création d’un programme pour pouvoir changer tous les champs de manière à ce qu’ils soient conformes à la nouvelle structure.</p>
</section>
<section id="format-de-fichiers" class="level4">
<h4><a href="#format-de-fichiers"><span class="header-section-number">1.1.1.4</span> Format de fichiers</a></h4>
<p>Comme la structure des fichiers est dépendant du langage de programmation, il est plus difficile d’utiliser différents langages pour les différentes applications. En effet, un fichier généré dans un langage va être différent du même fichier généré à partir d’un autre langage.</p>
</section>
<section id="requêtes-fixes-et-prolifération-de-programmes" class="level4">
<h4><a href="#requêtes-fixes-et-prolifération-de-programmes"><span class="header-section-number">1.1.1.5</span> Requêtes fixes et prolifération de programmes</a></h4>
<p>Les besoins de nouvelles requêtes peuvent changer à tous moments. Étant donné que les requêtes sont écrites par les développeurs d’application, il était très difficile d’ajouter des nouvelles requêtes rapidement. Il n’y avait aucun moyen de créer des requêtes non planifiées pour aller voir les types de données disponibles. Le fait que ce soit les développeurs d’application qui devaient écrire toutes les requêtes faisait en sorte que leur charge de travail était énorme et, donc, dans certain cas, ils étaient obligés de couper dans certaines fonctionnalités. Par exemple, les fonctionnalités suivantes étaient souvent omises:</p>
<ul>
<li>Aucune mesure de sécurité ou de vérification de l’intégrité des données</li>
<li>La récupération des données dans le cas d’un disfonctionnement logiciel ou matériel était limité ou inexistant</li>
<li>Accès aux fichier était restreint à un utilisateur à la fois</li>
</ul>
</section>
<section id="résumé" class="level4">
<h4><a href="#résumé"><span class="header-section-number">1.1.1.6</span> Résumé</a></h4>
<p>Tous les facteurs limitants de l’approche par fichiers peuvent être attribués à deux facteurs:</p>
<ul>
<li>La définition des données est incrustée dans les applications au lieu d’être enregistré séparemment et indépendemment</li>
<li>Il n’y a aucun contrôle sur les accès et manipulations des données hormis celui imposé par les programmes</li>
</ul>
</section>
</section>
</section>
<section id="lapproche-par-base-de-données" class="level2">
<h2><a href="#lapproche-par-base-de-données"><span class="header-section-number">1.2</span> L’approche par base de données</a></h2>
<p>L’approche par fichiers ne répondant pas aux besoins des entreprises, une nouvelle solution fut inventée: l’approche par base de données.</p>
<section id="les-bases-de-données" class="level3">
<h3><a href="#les-bases-de-données"><span class="header-section-number">1.2.1</span> Les bases de données</a></h3>
<section id="définition" class="level4">
<h4><a href="#définition"><span class="header-section-number">1.2.1.1</span> Définition</a></h4>
<p>Une <strong>base de données</strong> est une collection de données liées logiquement et sa description, conçu dans le but de répondre aux besoins d’information d’une organisation.</p>
</section>
<section id="avantages" class="level4">
<h4><a href="#avantages"><span class="header-section-number">1.2.1.2</span> Avantages</a></h4>
<p>Les bases de données ont plusieurs avantages par rapport à l’approche par fichiers. Par exemple:</p>
<ul>
<li>Une base de données a le minimum de duplication possible.</li>
<li>Au lieu d’être liée à un seul département, elle est partagée à toute l’organisation complète.</li>
<li>Elle peut être accédée par plusieurs utilisateurs en même temps.</li>
<li>En plus de contenir les données, elle contient aussi une description de ces données.</li>
<li>La définition des données est cachée aux utilisateurs qui ne voient que leurs définitions externes ce qui permet de protéger les programmes des modifications à la base de données.</li>
</ul>
</section>
</section>
<section id="les-systèmes-de-gestion-de-bases-de-données-dbms-ou-sgbd" class="level3">
<h3><a href="#les-systèmes-de-gestion-de-bases-de-données-dbms-ou-sgbd"><span class="header-section-number">1.2.2</span> Les systèmes de gestion de bases de données (DBMS ou SGBD)</a></h3>
<section id="définition-1" class="level4">
<h4><a href="#définition-1"><span class="header-section-number">1.2.2.1</span> Définition</a></h4>
<p>Un <strong>système de gestion de base de données</strong> est un logiciel qui permet aux utilisateurs de définir, créer, maintenir et contrôler l’accès à la base de données.</p>
</section>
<section id="fonctionnalités-fournies" class="level4">
<h4><a href="#fonctionnalités-fournies"><span class="header-section-number">1.2.2.2</span> Fonctionnalités fournies</a></h4>
<p>Les systèmes de gestion de bases de données donnent accès à des fonctionnalités. Par exemple:</p>
<ul>
<li>Permet aux utilisateurs de définir la base de données avec un <strong>langage de définition de données (DDL)</strong>. Ce langage permet de spécifier les types, les structures et les contraintes à appliquer sur les données qui vont être entreposées dans la base de données.</li>
<li>Permet aux utilisateurs de d’insérer, de mettre à jour, d’effacer et d’aller chercher des données dans la base de données avec un <strong>langage de manipulation de données (DML)</strong>. Le langage de manipulation de données permet de faire ces opérations avec un <strong>langage de requête</strong> comme le <strong>langage structuré de requête (SQL)</strong>.</li>
<li>Permet un accès contrôlé à la base de données. Par exemple:
<ul>
<li>Système de sécurité qui empêche les accès non autorisés à la base de données</li>
<li>Système d’intégrité qui maintient la consistence des données</li>
<li>Système de contrôle d’accès multiple qui permet l’accès partagé à la base de données</li>
<li>Système de contrôle de récupération qui permet de remettre la base de données à un état antérieur après un problème matériel ou logiciel</li>
<li>Catalogue usager qui contient des descriptions des données dans la base de données</li>
</ul></li>
</ul>
</section>
<section id="avantages-1" class="level4">
<h4><a href="#avantages-1"><span class="header-section-number">1.2.2.3</span> Avantages</a></h4>
<p>Il y a plusieurs avantages aux systèmes de gestion de bases de données. Parmi ces avantages, on dénombre le contrôle de la redondance des données, la cohérence des données, plus d’informations avec le même nombre de données, le partage des données, une meilleure intégrité des données, une sécurité accrue, l’application des standards, des économies de taille, la balance de besoins contradictoires, l’amélioration de l’accessibilité et de la réactivité des données, une productivité accrue, maintenance améliorée grâce à l’indépendence des données, amélioration de l’accès simultané et de meilleurs services de restauration des données.</p>
<section id="contrôle-de-la-redondance-des-données" class="level5">
<h5><a href="#contrôle-de-la-redondance-des-données"><span class="header-section-number">1.2.2.3.1</span> Contrôle de la redondance des données</a></h5>
<p>L’approche par bases de données essaie d’éliminer les redondances en intégrant les fichiers de sorte que des copies des mêmes données ne sont pas enregistrées. Toutefois, l’approche par bases de données n’élimine pas toutes les redondances, elle ne fait que contrôler la quantité de redondance. Dans certains cas, il est nécessaire de dupliquer des données clés pour modéliser des relations. Dans d’autres cas, il est désirable de dupliquer quelques données pour améliorer les performances.</p>
</section>
<section id="cohérence-des-données" class="level5">
<h5><a href="#cohérence-des-données"><span class="header-section-number">1.2.2.3.2</span> Cohérence des données</a></h5>
<p>En éliminant ou en controllant les redondances, on réduit le risques d’incohérences. S’il n’y a qu’une copie d’une données dans la base de données, n’importe quelle mise à jour de sa valeur ne va devoir être fait qu’une fois. S’il y a plusieurs copies et que le système est au courant, il peut s’assurer que toutes les copies sont consistentes.</p>
</section>
<section id="plus-dinformations-avec-le-même-nombre-de-données" class="level5">
<h5><a href="#plus-dinformations-avec-le-même-nombre-de-données"><span class="header-section-number">1.2.2.3.3</span> Plus d’informations avec le même nombre de données</a></h5>
<p>Comme toutes les informations sont accessibles par tous les départements d’une organisation, il est possible d’avoir plus d’information avec les mêmes données.</p>
</section>
<section id="partage-des-données" class="level5">
<h5><a href="#partage-des-données"><span class="header-section-number">1.2.2.3.4</span> Partage des données</a></h5>
<p>Comme la base de données est commune à toute l’organisation, elle peut être accéder par tout le monde.</p>
</section>
<section id="meilleure-intégrité-des-données" class="level5">
<h5><a href="#meilleure-intégrité-des-données"><span class="header-section-number">1.2.2.3.5</span> Meilleure intégrité des données</a></h5>
<p>L’intégrité d’une base de données réfère à la validité et à la cohérence des données enregistrées. L’intégrité est exprimé en termes de contraintes que la base de données ne peut violer.</p>
</section>
<section id="sécurité-accrue" class="level5">
<h5><a href="#sécurité-accrue"><span class="header-section-number">1.2.2.3.6</span> Sécurité accrue</a></h5>
<p>La sécurité des bases de données est la protection de la base de données contre les utilisateurs non autorisés. L’intégraton permet à l’administrateur de la base de données de définir la sécurité de la base de données. Cette sécurité peut prendre la forme d’identifiants et de mots de passe.</p>
</section>
<section id="application-des-standards" class="level5">
<h5><a href="#application-des-standards"><span class="header-section-number">1.2.2.3.7</span> Application des standards</a></h5>
<p>L’intégraton permet à l’administrateur de la base de données d’appliquer les standards nécessaires. Ceux-ci peuvent prendre la forme de format de données, format de la documentation, les procédures de mise à jour et règles d’accès.</p>
</section>
<section id="économies-de-taille" class="level5">
<h5><a href="#économies-de-taille"><span class="header-section-number">1.2.2.3.8</span> Économies de taille</a></h5>
<p>Combiner toutes les données d’une organisations dans une base de données et créer un ensemble d’application qui marche avec cette seule source de données peut permettre d’économiser beaucoup d’argent. En effet, au lieu que chaque département ait leur propre budget pour la maintenant et le développement de leur système basé sur une approche fichier, les efforts peuvent être combinés pour être concentré vers la base de données uniques pouvant ainsi sauver de l’argent.</p>
</section>
<section id="balance-de-besoins-contradictoires" class="level5">
<h5><a href="#balance-de-besoins-contradictoires"><span class="header-section-number">1.2.2.3.9</span> Balance de besoins contradictoires</a></h5>
<p>Chaque utilisateur ou département a des besoins qui peuvent être en conflit avec ceux des autres utilisateurs. Comme la base de données est sous le contrôle de l’administrateur de bases de données, celui-ci peut prendre des décisions à propos de la conception et de l’utilisation de la base de données qui vont tirer le maximum des ressources disponibles de l’organisation.</p>
</section>
<section id="amélioration-de-laccessibilité-et-de-la-réactivité-des-données" class="level5">
<h5><a href="#amélioration-de-laccessibilité-et-de-la-réactivité-des-données"><span class="header-section-number">1.2.2.3.10</span> Amélioration de l’accessibilité et de la réactivité des données</a></h5>
<p>En raison de l’intégration, les données qui sont partagées à travers les frontières des différents départements sont directement accessibles aux utilisateurs. Cela donne un système qui a potentiellement beaucoup plus de fonctionnalités.</p>
</section>
<section id="productivité-accrue" class="level5">
<h5><a href="#productivité-accrue"><span class="header-section-number">1.2.2.3.11</span> Productivité accrue</a></h5>
<p>Un système de gestion de gestion de bases de données fourni par défaut la plupart des fonctionnalités d’une approche par fichiers. Ainsi, le programmeur n’a pas à se concentrer sur les aspects de base de la base de données et peut se concentrer sur les aspects plus spécifiques à sa propre application.</p>
</section>
<section id="maintenance-améliorée-grâce-à-lindépendence-des-données" class="level5">
<h5><a href="#maintenance-améliorée-grâce-à-lindépendence-des-données"><span class="header-section-number">1.2.2.3.12</span> Maintenance améliorée grâce à l’indépendence des données</a></h5>
<p>Un système de gestion de bases de données sépare la description des données des applications, rendant ainsi les applications immunisées contre les changements de descriptions des données.</p>
</section>
<section id="amélioration-de-laccès-simultané" class="level5">
<h5><a href="#amélioration-de-laccès-simultané"><span class="header-section-number">1.2.2.3.13</span> Amélioration de l’accès simultané</a></h5>
<p>La plupart des systèmes de gestion de bases de données contrôlent les accès simultanés à la base de données rendant ainsi les problèmes d’accès simultanés impossible.</p>
</section>
<section id="meilleurs-services-de-restauration-et-de-sauvegarde-des-données" class="level5">
<h5><a href="#meilleurs-services-de-restauration-et-de-sauvegarde-des-données"><span class="header-section-number">1.2.2.3.14</span> Meilleurs services de restauration et de sauvegarde des données</a></h5>
<p>Les systèmes de gestion de bases de données ont des mesures pour minimiser les dégats en cas de défaillance.</p>
</section>
</section>
<section id="désavantages" class="level4">
<h4><a href="#désavantages"><span class="header-section-number">1.2.2.4</span> Désavantages</a></h4>
<p>Il y a aussi quelques désavantages aux systèmes de gestion de bases de données tels que une plus grande complexité, une plus grande taille, le coût des systèmes de gestion de bases de données, les coûts additionnels de matériel, le coût de conversion, la performance et un plus gros impact en cas de défaillance.</p>
<section id="complexité" class="level5">
<h5><a href="#complexité"><span class="header-section-number">1.2.2.4.1</span> Complexité</a></h5>
<p>La plupart des fonctionnalités dont nous nous attendons d’un système de gestion de bases de données font en sorte que c’est un logiciel très complexe. Une incompréhension du système peut amener des mauvaises décisions de conception qui peuvent avoir des conséquences sérieuses pour l’organisation.</p>
</section>
<section id="taille" class="level5">
<h5><a href="#taille"><span class="header-section-number">1.2.2.4.2</span> Taille</a></h5>
<p>La complexité et toutes les fonctionnalités des systèmes de gestion de bases de données font en sorte que c’est un logiciel extrêmement lourd qui demande beaucoup d’espace disque et qui demande beaucoup de mémoire pour l’exécuter.</p>
</section>
<section id="coût-des-systèmes-de-gestion-de-bases-de-données" class="level5">
<h5><a href="#coût-des-systèmes-de-gestion-de-bases-de-données"><span class="header-section-number">1.2.2.4.3</span> Coût des systèmes de gestion de bases de données</a></h5>
<p>Le coût des systèmes de gestion de bases de données varie en fonction des fonctionnalités et de l’environnement fournis. Également, il y a des frais annuels de maintenance qui s’imposent.</p>
</section>
<section id="coûts-additionnels-de-matériel" class="level5">
<h5><a href="#coûts-additionnels-de-matériel"><span class="header-section-number">1.2.2.4.4</span> Coûts additionnels de matériel</a></h5>
<p>Les besoins en espace de disque pour la base de données et le système de gestion de bases de données peut demander à acheter du nouvel espace disque. De plus, pour atteindre les performances requises, il peut être nécessaire d’acheter une machine dédiée pour exécuter la base de données.</p>
</section>
<section id="coût-de-conversion" class="level5">
<h5><a href="#coût-de-conversion"><span class="header-section-number">1.2.2.4.5</span> Coût de conversion</a></h5>
<p>Dans certains cas, le coût de conversion des applications existants pour qu’elles roulent sur le nouveau système peut être très grand.</p>
</section>
<section id="performance" class="level5">
<h5><a href="#performance"><span class="header-section-number">1.2.2.4.6</span> Performance</a></h5>
<p>Une approche par fichiers permet de créer des applications et des formats de fichier qui ont un but spécifique. Cela fait en sorte que leur performance est souvent très bonne. Par contre, dans le cas d’un système de gestion de bases de données, on essaie d’être plus général dans le but de desservir plus d’applications. Cette généralité entraîne souvent un coût au niveau de la performance.</p>
</section>
<section id="plus-gros-impact-en-cas-de-défaillance." class="level5">
<h5><a href="#plus-gros-impact-en-cas-de-défaillance."><span class="header-section-number">1.2.2.4.7</span> Plus gros impact en cas de défaillance.</a></h5>
<p>La centralisation des données augmente la vulnérabilité du système. Comme tout le monde dépend de la base de données, sa défaillance peut amener plusieurs opérations à s’arrêter.</p>
</section>
</section>
<section id="mécanisme-de-vision" class="level4">
<h4><a href="#mécanisme-de-vision"><span class="header-section-number">1.2.2.5</span> Mécanisme de vision</a></h4>
<p>En plus d’offrir toutes les fonctionnalités précédentes, les système de gestion de base de données offrent un <strong>mécanisme de vue</strong> qui permet aux utilisateurs d’avoir leur propre vue de la base de données. Par exemple, une vue pourrait permettre de ne voir que certaines entités de la base de données</p>
<section id="bénéfices" class="level5">
<h5><a href="#bénéfices"><span class="header-section-number">1.2.2.5.1</span> Bénéfices</a></h5>
<p>Les vues offrent plusieurs bénéfices tels que:</p>
<ul>
<li>Un niveau de sécurité supplémentaire, car on peut exclure des données que certains utilisateurs ne devraient pas voir</li>
<li>Un mécanisme pour paramétrer l’apparence de la base de données</li>
<li>Permet de présenter une vision immutable de la structure de la base de données même si la base de données en dessous est changée, car la vue va seulement présentée les données qui intéressent l’utilisateur. Donc, même si les autres champs changent, tant que les champs qui intéressent l’utilisateur n’ont pas changé, la vue de l’utilisateur ne sera pas affectée.</li>
</ul>
</section>
</section>
<section id="composants-dun-système-de-gestion-de-bases-de-données" class="level4">
<h4><a href="#composants-dun-système-de-gestion-de-bases-de-données"><span class="header-section-number">1.2.2.6</span> Composants d’un système de gestion de bases de données</a></h4>
<p>Un système de gestion de bases de données est composées de plusieurs choses.</p>
<section id="matériel" class="level5">
<h5><a href="#matériel"><span class="header-section-number">1.2.2.6.1</span> Matériel</a></h5>
<p>Un système de gestion de bases de données a besoin de matériel pour fonctionner. Ce matériel peut aller d’un simple ordinateur personnel à un réseau d’ordinateurs. Quelques systèmes de gestion de bases de données nécessite un système d’exploitation particulier ou du matériel spécifique alors que d’autres, non. Les système de gestion de bases de données ont besoin d’un minimum de mémoire et d’espace disque pour fonctionner, mais ce minimum ne garantit pas une performance adéquate. Un exemple d’<strong>architecture client-serveur</strong> se retrouve à la figure suivante. Dans cette figure, on remarque le serveur central qui sert de <strong>backend</strong> au système de gestion de bases de données et les différents ordinateurs qui servent de <strong>frontend</strong> au système de gestion de bases de données.</p>
<figure>
<img src="images/exemple_materiel_SGBD.png" alt="Exemple d’architecture client-serveur" /><figcaption>Exemple d’architecture client-serveur</figcaption>
</figure>
</section>
<section id="logiciel" class="level5">
<h5><a href="#logiciel"><span class="header-section-number">1.2.2.6.2</span> Logiciel</a></h5>
<p>La composante logiciel comprend le logiciel de système de gestion de bases de données lui-même, les programmes d’application, le système d’exploitation et le logiciel de réseau si le système de gestion de bases de données est utilisé par un réseau.</p>
</section>
<section id="données" class="level5">
<h5><a href="#données"><span class="header-section-number">1.2.2.6.3</span> Données</a></h5>
<p>Les données sont la partie la plus importante d’un système de gestion de bases de données. Elles servent de pont entre les humains et les machines. La base de données contient les données opérationnelles et les metadatas. La structure de la base de données est appelée <strong>schéma</strong>. Les schémas contiennent des <strong>tables</strong>. Les champs dans ces tables sont appelés des <strong>attributs</strong>.</p>
</section>
<section id="procédures" class="level5">
<h5><a href="#procédures"><span class="header-section-number">1.2.2.6.4</span> Procédures</a></h5>
<p>Les procédures sont les instructions et les règles qui régissent la forme et l’utilisation de la base de données. Ces procédures sont destinées aux utilisateurs du système et au personnel qui est responsable de la base de données.</p>
</section>
<section id="humains" class="level5">
<h5><a href="#humains"><span class="header-section-number">1.2.2.6.5</span> Humains</a></h5>
<p>Les personnes impliquées avec le système.</p>
</section>
</section>
<section id="conception-de-bases-de-données" class="level4">
<h4><a href="#conception-de-bases-de-données"><span class="header-section-number">1.2.2.7</span> Conception de bases de données</a></h4>
<p>La structure d’une base de données est déterminée lors du <strong>design de la base de données</strong>.</p>
</section>
<section id="rôles-dans-un-environnement-de-bases-de-données" class="level4">
<h4><a href="#rôles-dans-un-environnement-de-bases-de-données"><span class="header-section-number">1.2.2.8</span> Rôles dans un environnement de bases de données</a></h4>
<p>Il y a quatre types de personnes dans un environnement de bases de données. Il y a les administrateurs des données et de la base de données, les concepteurs de bases de données, les développeurs d’application et les utilisateurs.</p>
<section id="administrateurs-des-données-et-de-la-base-de-données" class="level5">
<h5><a href="#administrateurs-des-données-et-de-la-base-de-données"><span class="header-section-number">1.2.2.8.1</span> Administrateurs des données et de la base de données</a></h5>
<p>Les administrateurs des données et de la base de données sont des rôles qui sont chargés du contrôle et de la gestion du système de gestion de la base de données et de ses données.</p>
<ul>
<li>L’<strong>administrateur des données (DA)</strong> est responsable de gérer les ressources de données, incluant la planification de la base de données, le développement et la maintenance des standards, politiques et procédures. Il doit aussi s’occuper du design conceptuel/logique de la base de données.</li>
<li>L’<strong>administrateur de la base de données (DBA)</strong> est responsable de la réalisation physique de la base de données, incluant le design physique de la base de données et l’implantation, la sécurité, le contrôle d’intégrité, la maintenance du système opérationnel et d’assurer une performance satisfaisante des applications des utilisateurs.</li>
</ul>
</section>
<section id="concepteurs-de-bases-de-données" class="level5">
<h5><a href="#concepteurs-de-bases-de-données"><span class="header-section-number">1.2.2.8.2</span> Concepteurs de bases de données</a></h5>
<p>Il y a deux types de concepteurs de bases de données. Il y a les <strong>concepteurs de bases de données logiques</strong> et les <strong>concepteurs de bases de données physiques</strong>.</p>
<ul>
<li><strong>Concepteurs de bases de données logiques</strong>: Responsables d’identifier les données (ou plutôt les entités et les attributs), les relations entre les données et les contraintes sur les données qui vont être enregistrées dans la base de données. Il doit avoir une bonne compréhension des données de l’organisation et des contraintes qui s’appliquent sur celles-ci.</li>
<li><strong>Concepteurs de bases de données physiques</strong>: Décident comment la conception logique de la base de données va être physiquement implantée. Cela consiste à:
<ul>
<li>Transformer le design logique de la base de données dans un ensemble de tables et de contraintes d’intégrité.</li>
<li>Sélectionner des structures d’entreposage et des méthodes d’accès aux données pour obtenir une bonne performance.</li>
<li>Établir les mesures de sécurité requises pour les données.</li>
</ul></li>
</ul>
</section>
<section id="développeurs-dapplication" class="level5">
<h5><a href="#développeurs-dapplication"><span class="header-section-number">1.2.2.8.3</span> Développeurs d’application</a></h5>
<p>Les développeurs d’application sont responsables de développer des programmes qui vont fournir les fonctionnalités requises aux usagers. Ces applications vont interagir avec la base de données.</p>
</section>
<section id="utilisateurs" class="level5">
<h5><a href="#utilisateurs"><span class="header-section-number">1.2.2.8.4</span> Utilisateurs</a></h5>
<p>Les utilisateurs sont ceux qui ont besoin des informations de la base de données. On distingue deux types d’utilisateurs, les <strong>utilisateurs naïfs</strong> et les <strong>utilisateurs sophistiqués</strong>.</p>
<ul>
<li><p><strong>Utilisateurs naïfs</strong>: Ignorent tout du système de gestion de bases de données. Ils accèdent à la base de données par des programmes spécifiques. Ils utilisent les opérations de bases de données en appuyant sur des boutons ou en entrant des commandes simples.</p></li>
<li><p><strong>Utilisateurs sophistiqués</strong>: Familiés avec la structure de la base de données et des installations fournies par le système de gestion de bases de données. Ils sont capable d’utiliser un langage de requêtes comme le <em>SQL</em> pour exécuter les opérations requises. Ils sont parfois même capables d’écrire des applications pour leur propre usage.</p></li>
</ul>
</section>
</section>
</section>
</section>
</section>
<section id="modèle-relationnel" class="level1">
<h1><a href="#modèle-relationnel"><span class="header-section-number">2</span> Modèle relationnel</a></h1>
<p>Dans ce chapitre, nous aborderons le modèle relationnel et ses différents éléments.</p>
<section id="structure-des-données-relationnelles" class="level2">
<h2><a href="#structure-des-données-relationnelles"><span class="header-section-number">2.1</span> Structure des données relationnelles</a></h2>
<p>La structure des données relationnelles peut être décomposée dans les éléments suivants:</p>
<dl>
<dt><strong>Relation (table ou fichier)</strong></dt>
<dd><p>Table avec des lignes et des colonnes.</p>
</dd>
<dt><strong>Attribut (colonne ou champ)</strong></dt>
<dd><p>Colonne nommée d’une relation.</p>
</dd>
<dt><strong>Domaine</strong></dt>
<dd><p>L’ensemble des valeurs allouées pour un ou plusieurs attributs.</p>
</dd>
<dt><strong>Tuple (ligne ou archive)</strong></dt>
<dd><p>Nom donné à une ligne dans une relation (ou table).</p>
</dd>
<dt><strong>Degré</strong></dt>
<dd><p>Le nombre d’attributs que la relation contient.</p>
</dd>
</dl>
<p>Une relation de degré un est appelée une relation unaire. Une relation de degré deux est appelée une relation binaire, une de degré trois est appelée une relation tertiaire et, après ça, le terme n-tiaire est utilisé.</p>
<dl>
<dt><strong>Cardinalité</strong></dt>
<dd><p>Le nombre de tuples que la relation contient.</p>
</dd>
<dt><strong>Base de données relationnel</strong></dt>
<dd><p>Une collection de relations normalisées avec des noms distincts de relations.</p>
</dd>
</dl>
</section>
<section id="relations-mathématiques" class="level2">
<h2><a href="#relations-mathématiques"><span class="header-section-number">2.2</span> Relations mathématiques</a></h2>
<p>Une relation mathématique est définie comme étant le <strong>produit cartésien</strong> de plusieurs ensembles. Le <strong>produit cartésien</strong> est défini comme suit:</p>
<p>Soit <span class="math">\(D_1, D_2, \dots D_n\)</span>, <span class="math">\(n\)</span> ensembles. Leur produit cartésien est défini comme:</p>
<p><span class="math">\[D_1 \times D_2 \times \dots \times D_n = \{ (d_1, d_2, \dots, d_n) 
\mid d_1 \in D_1, d_2 \in D_2, \dots d_n \in D_n\}\]</span></p>
<p>qui peut être réécrit comme</p>
<p><span class="math">\[\prod_{i = 1}^n D_i\]</span></p>
</section>
<section id="relations-des-bases-de-données" class="level2">
<h2><a href="#relations-des-bases-de-données"><span class="header-section-number">2.3</span> Relations des bases de données</a></h2>
<p>En applicant les notions vues à la section précédente, nous pouvons désormais définir un schéma de relation. Soit <span class="math">\(A_1, A_2, \dots, A_n\)</span> des attributs avec comme domaines <span class="math">\(D_1, D_2, \dots, D_n\)</span>. Alors, l’ensemble <span class="math">\(\{A_1: D_1, A_2: D_2, \dots, A_n: D_n\}\)</span> est un schéma de relation. Une relation <span class="math">\(R\)</span> définie par le schéma de relation <span class="math">\(S\)</span> est un ensemble qui met en relation les noms des attributs avec leurs domaines respectifs. Ainsi, la relation <span class="math">\(R\)</span> est un ensemble de <span class="math">\(n\)</span>-tuples:</p>
<p><span class="math">\[(A_1: d_1, A_2: d_2, \dots, A_n: d_n)~\textrm{tel que}~d_1 \in D_1, d_2 \in D_2, \dots, d_n \in D_n\]</span></p>
<p>Chaque élément du n-tuple consiste d’un attribut et d’une valeur pour cet attribut. Finalement, nous pouvons définir le <strong>schéma relationnel de bases de données</strong>. Soit <span class="math">\(R_1, R_2, \dots, R_n\)</span> des ensembles de schémas de relation, alors nous pouvons écrire le schéma relationnel de bases de données comme:</p>
<p><span class="math">\[R = \{R_1, R_2, \dots, R_n\}\]</span></p>
</section>
<section id="propriétés-des-relations" class="level2">
<h2><a href="#propriétés-des-relations"><span class="header-section-number">2.4</span> Propriétés des relations</a></h2>
<p>Une relation a les propriétés suivantes:</p>
<ul>
<li>elle a un nom qui est distinct de tous les autres noms dans le schéma relationnel;</li>
<li>chaque cellule contient exactement une valeur atomique;</li>
<li>chaque attribut a un nom distinct;</li>
<li>les valeurs d’un attribut proviennent tous d’un même domaine;</li>
<li>chaque tuple est distinct; il n’y a pas de doublons;</li>
<li>l’ordre des attributs n’a pas d’importance;</li>
<li>l’ordre des tuples n’a pas d’importance, en théorie.</li>
</ul>
</section>
<section id="clés-relationnelles" class="level2">
<h2><a href="#clés-relationnelles"><span class="header-section-number">2.5</span> Clés relationnelles</a></h2>
<p>Comme il n’y a pas de tuples identiques dans une relation, nous devons être capables d’identifier un ou plusieurs attributs qui identifient chaque tuple dans la relation. Ces attributs sont appelés des <strong>clés relationnelles</strong>.</p>
<section id="superclé" class="level3">
<h3><a href="#superclé"><span class="header-section-number">2.5.1</span> Superclé</a></h3>
<p>Une <strong>superclé</strong> est un attribut, ou un ensemble d’attributs, qui identifient de manière unique un tuple dans une relation.</p>
</section>
<section id="clé-candidate" class="level3">
<h3><a href="#clé-candidate"><span class="header-section-number">2.5.2</span> Clé candidate</a></h3>
<p>Une <strong>clé candidate</strong> est une superclé tel qu’aucun sous-ensemble propre est une superclé dans la relation. Une clé candidate <span class="math">\(K\)</span> d’une relation <span class="math">\(R\)</span> possède deux propriétés:</p>
<ul>
<li><em>Unicité</em>: Pour chaque tuple de <span class="math">\(R\)</span>, les valeurs de <span class="math">\(K\)</span> identifient de manière unique ce tuple.</li>
<li><em>Irréductibilité</em>: Aucun sous-ensemble de <span class="math">\(K\)</span> a la propriété d’unicité.</li>
</ul>
</section>
<section id="clé-composée" class="level3">
<h3><a href="#clé-composée"><span class="header-section-number">2.5.3</span> Clé composée</a></h3>
<p>Une <strong>clé composée</strong> est une clé candidate qui possède plus qu’un attribut.</p>
</section>
<section id="clé-primaire" class="level3">
<h3><a href="#clé-primaire"><span class="header-section-number">2.5.4</span> Clé primaire</a></h3>
<p>Une <strong>clé primaire</strong> est la clé candidate choisie pour identifier chaque tuple de manière unique dans la relation.</p>
</section>
<section id="clé-alternative" class="level3">
<h3><a href="#clé-alternative"><span class="header-section-number">2.5.5</span> Clé alternative</a></h3>
<p>Les clés candidates qui ne sont pas choisies pour être la clé primaire sont dites <strong>clés alternatives</strong>.</p>
</section>
<section id="clé-étrangère" class="level3">
<h3><a href="#clé-étrangère"><span class="header-section-number">2.5.6</span> Clé étrangère</a></h3>
<p>Une <strong>clé étrangère</strong> est un attribut, ou un ensemble d’attributs, à l’intérieur d’une relation qui correspond à la clé candidate d’une relation (possiblement la même).</p>
</section>
</section>
<section id="contraintes-dintégrité" class="level2">
<h2><a href="#contraintes-dintégrité"><span class="header-section-number">2.6</span> Contraintes d’intégrité</a></h2>
<p>Comme chaque attribut à un domaine associé, il y a des contraintes (appelées <strong>contraintes de domaine</strong>) qui forment des restrictions sur l’ensemble des valeurs permises pour les attributs des relations. Il y a aussi des <strong>règles d’intégrité</strong> qui sont des contraintes qui s’appliquent sur toutes les instances de la base de données. Il y a deux règles d’intégrité importantes: l’<strong>intégrité d’entité</strong> et l’<strong>intégrité référentielle</strong>. Il existe également d’autres contraintes d’intégrité telles que la <strong>multiplicité</strong> et les <strong>contraintes générales</strong>.</p>
<section id="null" class="level3">
<h3><a href="#null"><span class="header-section-number">2.6.1</span> Null</a></h3>
<p>Les nulls représentent une valeur pour un attribut qui est présentement inconnu ou pas applicable pour ce tuple. Les nulls peuvent poser des problèmes d’implantation, car le modèle relationnel est basé le calcul de prédicat de premier ordre, qui permet seulement deux valeur: vrai ou faux.</p>
</section>
<section id="intégrité-dentité" class="level3">
<h3><a href="#intégrité-dentité"><span class="header-section-number">2.6.2</span> Intégrité d’entité</a></h3>
<p>Cette règle s’applique aux clé primaires des <strong>relations de base</strong>. Une relation de base est une relation qui correspond à une entité dans le schéma conceptuel. Cette règle stipule que, dans une relation de base, aucun attribut de la clé primaire ne peut être nul. En effet, une clé primaire est l’identifiant minimal qui est utilisé pour identifier les tuples de manière unique. Si on inclut les nulls, nous disons que tous les attributs ne sont pas nécessaires pour identifier de manière unique les tuples. Il y a donc une contradiction.</p>
</section>
<section id="intégrité-référentielle" class="level3">
<h3><a href="#intégrité-référentielle"><span class="header-section-number">2.6.3</span> Intégrité référentielle</a></h3>
<p>Cette règle s’applique seulement aux clés étrangères. Elle stipule que, si une clé étrangère existe dans une relation, soit la valeur de la clé étrangère correspond à la valeur d’une clé candidate d’un tuple dans sa relation maison ou la valeur de la clé étrangère doit être complètement nulle.</p>
</section>
<section id="contraintes-générales" class="level3">
<h3><a href="#contraintes-générales"><span class="header-section-number">2.6.4</span> Contraintes générales</a></h3>
<p>Les contraintes générales sont des règles additionnelles spécifiées par les utilisateurs ou les administrateurs de bases de données de la base de données qui définissent ou contraignent des aspects de l’entreprise.</p>
</section>
</section>
<section id="vues" class="level2">
<h2><a href="#vues"><span class="header-section-number">2.7</span> Vues</a></h2>
<p>Dans le modèle relationnel, une vue n’est pas la structure de la base de données telle que l’aperçoit un utilisateur particulier. Une vue est plutôt une <strong>relation virtuelle</strong> ou une <strong>relation dérivée</strong>, c’est-à-dire une relation qui n’existe pas par elle-même, mais qui peut être dérivée dynamiquement d’une ou plusieurs relations de base.</p>
<section id="définition-2" class="level3">
<h3><a href="#définition-2"><span class="header-section-number">2.7.1</span> Définition</a></h3>
<p>Une vue est le résultat dynamique d’une ou plusieurs opérations opérant sur les relations de base afin de produire une autre relation. Une vue est une <em>relation virtuelle</em> qui n’existe pas nécessairement dans la base de données mais qui peut être produite sur demande par un utilisateur donné au moment de la requête. Les vues semblent exister pour l’utilisateur et peuvent être manipulées, mais elles ne sont pas nécessairement enregistrées dans la base de données comme une relation de base. Toutes les opérations sur les vues sont automatiquement traduites en opération sur les relations de base duquelles celles-ci sont dérivées. De plus, les vues sont <strong>dynamiques</strong> ce qui impliquent que les changements aux relations de base influeront immédiatement les vues.</p>
</section>
<section id="utilités" class="level3">
<h3><a href="#utilités"><span class="header-section-number">2.7.2</span> Utilités</a></h3>
<p>Le mécanisme de vues est désirable pour plusieurs raisons:</p>
<ul>
<li>Fourni un mécanisme puissant et flexible pour cacher des parties de la base de données à certains utilisateurs. Les utilisateurs ne sont pas au courant des attributs cachés par la vue.</li>
<li>Permet aux utilisateurs d’accéder aux données d’une façon adaptée à leurs besoins. De cette façon, les même données peuvent être vues par différentes personnes de différentes façons.</li>
<li>Peut simplifier des opérations complexes sur les relations de base.</li>
</ul>
<p>Une vue devrait être développée de sorte qu’elle supporte le modèle externe que l’utilisateur trouve familier. Les vues fournissent une indépendence des données logiques.</p>
</section>
<section id="mise-à-jour-des-vues" class="level3">
<h3><a href="#mise-à-jour-des-vues"><span class="header-section-number">2.7.3</span> Mise à jour des vues</a></h3>
<p>Toutes les mises à jour à une relation de base devraient immédiatement être reflétées dans les vues qui font références à cette relation de base. De façon similaire, si une vue est mise à jour, la relation de base sur laquelle elle est basée devrait être mise à jour aussi. Toutefois, il y a des restrictions sur les types de modification qui peuvent être faits sur les vues. Les conditions sous lesquelles la mise à jour à partir de la vue est possible sont les suivantes:</p>
<ul>
<li>Les mises à jour sont permises sur une vue définie en utilisant une requête simple qui implique une seule relation de base et qui contient ou bien la clé primaire ou une clé candidate de la relation de base.</li>
<li>Les mises à jour ne sont pas permises par des vues impliquant de multiples relations de base.</li>
<li>Les mises à jour ne sont pas permises par des vues impliquant l’aggrégation ou le groupement d’opérations.</li>
</ul>
</section>
</section>
</section>
<section id="normalisation" class="level1">
<h1><a href="#normalisation"><span class="header-section-number">3</span> Normalisation</a></h1>
<p>Dans ce chapitre, nous allons parler de la normalisation et de ses buts. Nous allons aussi aborder le concept de dépendances fonctionnelles.</p>
<section id="redondance-de-données-et-anomalies-de-mises-à-jour" class="level2">
<h2><a href="#redondance-de-données-et-anomalies-de-mises-à-jour"><span class="header-section-number">3.1</span> Redondance de données et anomalies de mises à jour</a></h2>
<p>En éliminant la redondance dans les bases de données, on en retire les bénéfices suivants:</p>
<ul>
<li>les mises à jour des données sont faites avec un nombre minimal d’opérations réduisant ainsi les risques d’incohérences dans la base de données;</li>
<li>le nombre d’espace de stockage requis pour les relation est diminué réduisant ainsi les coûts.</li>
</ul>
<p>Les relations qui ont des données redondantes peuvent avoir des problèmes appelés des <strong>anomalies de mise à jour</strong>. Il y a trois types d’anomalies de mise à jour: les <strong>anomalies d’insertion</strong>, les <strong>anomalies de suppression</strong> et les <strong>anomalies de modification</strong>.</p>
<section id="anomalies-dinsertion" class="level3">
<h3><a href="#anomalies-dinsertion"><span class="header-section-number">3.1.1</span> Anomalies d’insertion</a></h3>
<p>Si on ajoute des nouvelles données à la base de données, il peut y avoir des incohérences avec les champs déjà existants. De plus, si la table est mal faite, on peut être forcé d’ajouter des <em>nulls</em> pour pouvoir ajouter de nouveaux tuples.</p>
</section>
<section id="anomalies-de-suppression" class="level3">
<h3><a href="#anomalies-de-suppression"><span class="header-section-number">3.1.2</span> Anomalies de suppression</a></h3>
<p>Si on efface un attribut d’un tuple qui contient la dernière information sur un des attributs, cette information sera perdu lorsque l’attribut sera enlevé.</p>
</section>
<section id="anomalies-de-modification" class="level3">
<h3><a href="#anomalies-de-modification"><span class="header-section-number">3.1.3</span> Anomalies de modification</a></h3>
<p>Si on modifie la valeur d’un attribut, il faut s’assurer que dans la table, toutes les tuples qui contiennent cet attribut sont modifier. Sinon, on risque d’avoir une anomalie de modification. On peut éviter ces anomalies en décomposant les relations en plus petites relations. Cette façon de faire possède deux propriétés intéressantes:</p>
<ul>
<li>la propriété du <strong>raccord sans pertes</strong> qui assure que toutes les instances de la relation originale peuvent être identifiées avec les relations plus petites.</li>
<li>la propriété de <strong>préservation des dépendances</strong> qui assure qu’une contrainte de la relation originale sera maintenue en maintenant la contraintes sur les relations plus petites.</li>
</ul>
</section>
</section>
<section id="dépendances-fonctionnelles" class="level2">
<h2><a href="#dépendances-fonctionnelles"><span class="header-section-number">3.2</span> Dépendances fonctionnelles</a></h2>
<p>Les <strong>dépendances fonctionnelles</strong> jouent un rôle important dans la normalisation des bases de données.</p>
<section id="définition-3" class="level3">
<h3><a href="#définition-3"><span class="header-section-number">3.2.1</span> Définition</a></h3>
<p>Assumons un schéma relationnel possédant les attributs <span class="math">\((A, B, C, \dots, Z)\)</span> et une base de données décrite par une <strong>relation universelle</strong> <span class="math">\(R = (A, B, C, \dots, Z)\)</span>. Cela veut dire que tous les attributs dans la base de données ont un nom unique. Une <strong>dépendance fonctionnelle</strong> décrit le lien entre les attributs d’une relation. Par exemple, si <span class="math">\(A\)</span> et <span class="math">\(B\)</span> sont des attributs de la relation <span class="math">\(R\)</span>, <span class="math">\(B\)</span> est fonctionnellement dépendant de <span class="math">\(A\)</span> (dénoté <span class="math">\(A \mapsto B\)</span>), si chaque valeur de <span class="math">\(A\)</span> est associée à seulement une valeur de <span class="math">\(B\)</span> (<span class="math">\(A\)</span> et <span class="math">\(B\)</span> peuvent consister de plus d’un attributs).</p>
</section>
<section id="déterminant" class="level3">
<h3><a href="#déterminant"><span class="header-section-number">3.2.2</span> Déterminant</a></h3>
<p>Le terme <strong>déterminant</strong> réfère à l’attribut, ou le groupe d’attributs, du côté gauche de la flèche d’une dépendance fonctionnelle.</p>
</section>
<section id="dépendance-fonctionnelle-complète" class="level3">
<h3><a href="#dépendance-fonctionnelle-complète"><span class="header-section-number">3.2.3</span> Dépendance fonctionnelle complète</a></h3>
<p>Une <strong>dépendance fonctionnelle complète</strong> est une dépendance fonctionnelle dans laquelle le déterminant à le nombre minimal d’attribut pour avoir une dépendance fonctionnelle avec les attributs à droite de la flèche.</p>
</section>
<section id="dépendance-fonctionnelle-partielle" class="level3">
<h3><a href="#dépendance-fonctionnelle-partielle"><span class="header-section-number">3.2.4</span> Dépendance fonctionnelle partielle</a></h3>
<p>Une dépendance fonctionnelle est dite dépendance fonctionnelle partielle dans laquelle un des attributs peut être enlevé du déterminant et la dépendance fonctionnelle est encore valide.</p>
</section>
<section id="dépendance-transitive" class="level3">
<h3><a href="#dépendance-transitive"><span class="header-section-number">3.2.5</span> Dépendance transitive</a></h3>
<p>Si <span class="math">\(A\)</span>, <span class="math">\(B\)</span> et <span class="math">\(C\)</span> sont des attributs d’une relation tel que si <span class="math">\(A \mapsto B\)</span> et <span class="math">\(B \mapsto C\)</span>, alors <span class="math">\(C\)</span> est dépendant transitif de <span class="math">\(A\)</span> via <span class="math">\(B\)</span> (si <span class="math">\(A\)</span> n’est pas fonctionnellement dépendant de <span class="math">\(B\)</span> ou <span class="math">\(C\)</span>).</p>
</section>
<section id="résumé-1" class="level3">
<h3><a href="#résumé-1"><span class="header-section-number">3.2.6</span> Résumé</a></h3>
<p>Les dépendances fonctionnelles qui nous intéressent pour la normalisation possèdent les propriétés suivantes:</p>
<ul>
<li>Il y a une relation <em>un à un</em> entre les attributs du déterminant et ceux du côté droit d’une dépendance fonctionnelle.</li>
<li>Elles sont toujours valides</li>
<li>Le déterminant a le minimum d’attributs nécessaires pour maintenir une dépendance fonctionnelle avec le côté droit. Il doit donc y avoir une dépendance fonctionnelle complète entre les attributs du côté gauche avec ceux du côté droit.</li>
</ul>
</section>
</section>
<section id="normalisation-et-formes-normales" class="level2">
<h2><a href="#normalisation-et-formes-normales"><span class="header-section-number">3.3</span> Normalisation et formes normales</a></h2>
<p>Dans cette section, nous verrons la normalisation ainsi que les différentes formes normales ainsi que les techniques pour les obtenir.</p>
<section id="définition-de-la-normalisation" class="level3">
<h3><a href="#définition-de-la-normalisation"><span class="header-section-number">3.3.1</span> Définition de la normalisation</a></h3>
<p>La <strong>normalisation</strong> est une technique pour produire un ensemble de relations avec des propriétés désirables selon les besoins de données de l’entreprise. Les caractéristiques d’un bon ensemble de relations sont les suivantes:</p>
<ul>
<li>le <em>nombre minimal d’attributs</em> pour supporter les besoins en données de l’entreprise;</li>
<li>les attributs avec des relations logiques (décrites comme des <strong>dépendances fonctionnelles</strong>) sont dans les mêmes relations;</li>
<li>il y a un <em>minimum de redondance</em>, avec chaque attribut qui se retrouve seulement une fois dans la base de données excepté les attributs qui sont ou qui font parties de clés étrangères qui sont essentielles pour lier des relations.</li>
</ul>
</section>
<section id="forme-non-normalisée-unf-à-première-forme-normale" class="level3">
<h3><a href="#forme-non-normalisée-unf-à-première-forme-normale"><span class="header-section-number">3.3.2</span> Forme non normalisée (UNF) à première forme normale</a></h3>
<p>Dans cette section, nous verrons comment passer de la forme non normalisée à la première forme normale.</p>
<section id="définition-de-la-forme-non-normalisée-unf" class="level4">
<h4><a href="#définition-de-la-forme-non-normalisée-unf"><span class="header-section-number">3.3.2.1</span> Définition de la forme non normalisée (UNF)</a></h4>
<p>Une table qui contient une ou plusieurs répétitions de groupe.</p>
</section>
<section id="définition-de-la-première-forme-normale-1nf" class="level4">
<h4><a href="#définition-de-la-première-forme-normale-1nf"><span class="header-section-number">3.3.2.2</span> Définition de la première forme normale (1NF)</a></h4>
<p>Une relation dans laquelle l’intersection de chaque ligne et colonne contient seulement une valeur.</p>
</section>
<section id="technique-de-normalisation" class="level4">
<h4><a href="#technique-de-normalisation"><span class="header-section-number">3.3.2.3</span> Technique de normalisation</a></h4>
<p>Il y a deux approches pour passer de la forme non normalisée à la première forme normale.</p>
<section id="mise-à-plat" class="level5">
<h5><a href="#mise-à-plat"><span class="header-section-number">3.3.2.3.1</span> Mise à plat</a></h5>
<p>Remplir les colonnes de lignes vides avec les données non dupliquées.</p>
</section>
<section id="séparer-les-données-dupliquées" class="level5">
<h5><a href="#séparer-les-données-dupliquées"><span class="header-section-number">3.3.2.3.2</span> Séparer les données dupliquées</a></h5>
<p>Placer les données dupliquées avec une copie de l’attribut clé dans une relation différente.</p>
</section>
</section>
</section>
<section id="première-forme-normale-à-la-deuxième-forme-normale" class="level3">
<h3><a href="#première-forme-normale-à-la-deuxième-forme-normale"><span class="header-section-number">3.3.3</span> Première forme normale à la deuxième forme normale</a></h3>
<p>Dans cette section, nous verrons comment passer de la première forme normale à la deuxième forme normale.</p>
<section id="définition-de-la-deuxième-forme-normale-2nf" class="level4">
<h4><a href="#définition-de-la-deuxième-forme-normale-2nf"><span class="header-section-number">3.3.3.1</span> Définition de la deuxième forme normale (2NF)</a></h4>
<p>Une relation qui est dans la deuxième forme normale est une relation qui est dans la première forme normale et dont chaque attribut qui n’est pas une clé primaire est <em>complètement dépendant</em> de la clé primaire. En d’autres mots, il ne faut pas qu’un attribut qui n’est pas une clé primaire soit dépendant d’un sous-ensemble de la clé primaire.</p>
</section>
<section id="technique-de-normalisation-1" class="level4">
<h4><a href="#technique-de-normalisation-1"><span class="header-section-number">3.3.3.2</span> Technique de normalisation</a></h4>
<p>Pour passer de la première forme normale à la deuxième, il faut enlever les dépendances partielles. Si une dépendance fonctionnelle existe, il faut enlever les attributs qui sont partiellement dépendants de la relation en les plaçant dans une nouvelle relation avec une copie de leur déterminant.</p>
<p>Voici un exemple:</p>
<p>Nous avons une table avec les attributs <em>teacher_id</em>, <em>subject</em> et <em>teacher_age</em>. La clé primaire est donnée par les attributs <em>teacher_id</em> et <em>subject</em>.</p>
<figure>
<img src="images/1NF_to_2NF.png" alt="Exemple de la normalisation d’une table en 1NF - Première photo" /><figcaption>Exemple de la normalisation d’une table en 1NF - Première photo</figcaption>
</figure>
<p>Comme <em>teacher_age</em> dépend de <em>teacher_id</em> seulement, il n’est pas complètement dépendant de la clé primaire. Nous devons donc séparer la table comme suit:</p>
<figure>
<img src="images/1NF_to_2NF_2nd_image.png" alt="Exemple de la normalisation d’une table en 1NF - Deuxième photo" /><figcaption>Exemple de la normalisation d’une table en 1NF - Deuxième photo</figcaption>
</figure>
</section>
</section>
<section id="deuxième-forme-normale-à-la-troisième-forme-normale" class="level3">
<h3><a href="#deuxième-forme-normale-à-la-troisième-forme-normale"><span class="header-section-number">3.3.4</span> Deuxième forme normale à la troisième forme normale</a></h3>
<p>Dans cette section, nous verrons comment passer de la deuxième forme normale à la troisième forme normale.</p>
<section id="définition-de-la-troisième-forme-normale-3nf" class="level4">
<h4><a href="#définition-de-la-troisième-forme-normale-3nf"><span class="header-section-number">3.3.4.1</span> Définition de la troisième forme normale (3NF)</a></h4>
<p>Une relation qui est dans la première et deuxième forme normale et dans laquelle aucun attribut qui ne fait pas partie de la clé primaire est <em>transitivement dépendant</em> de la clé primaire.</p>
</section>
<section id="technique-de-normalisation-2" class="level4">
<h4><a href="#technique-de-normalisation-2"><span class="header-section-number">3.3.4.2</span> Technique de normalisation</a></h4>
<p>Pour passer de la deuxième forme normale à la troisième, il faut enlever les dépendances transitives. Si une dépendance transitive existe, il faut l’enlever de la relation en mettant l’attribut dans une nouvelle relation avec une copie du déterminant.</p>
<p>Voici un exemple:</p>
<p>Nous avons les attributs <em>emp_id</em>, <em>emp_name</em>, <em>emp_zip</em>, <em>emp_state</em>, <em>emp_city</em> et <em>emp_district</em>. L’attribut <em>emp_id</em> est la clé primaire.</p>
<figure>
<img src="images/2NF_to_3NF.png" alt="Exemple de la normalisation d’une table en 2NF - Première photo" /><figcaption>Exemple de la normalisation d’une table en 2NF - Première photo</figcaption>
</figure>
<p>On remarque que <em>emp_state</em>, <em>emp_city</em> et <em>emp_district</em> sont dépendants de l’attribut <em>emp_zip</em> qui lui-même est dépendant de l’attribut <em>emp_id</em>. Nous avons donc une dépendance transitive. Pour s’en débarrasser, on sépare la table de la façon suivante:</p>
<figure>
<img src="images/2NF_to_3NF_2nd_image.png" alt="Exemple de la normalisation d’une table en 2NF - Deuxième photo" /><figcaption>Exemple de la normalisation d’une table en 2NF - Deuxième photo</figcaption>
</figure>
</section>
</section>
</section>
</section>
<section id="normalisation-avancée" class="level1">
<h1><a href="#normalisation-avancée"><span class="header-section-number">4</span> Normalisation avancée</a></h1>
<p>Ce chapitre traitera de notions de normalisations avancées telles que la <strong>forme normale Boyce-Codd</strong>.</p>
<section id="règles-dinférence-des-dépendances-fonctionnelles" class="level2">
<h2><a href="#règles-dinférence-des-dépendances-fonctionnelles"><span class="header-section-number">4.1</span> Règles d’inférence des dépendances fonctionnelles</a></h2>
<p>Comme il peut y avoir beaucoup de dépendances fonctionnelles, il faut trouver des règles pour nous permettre d’identifier les plus importantes plus facilement. L’ensemble des dépendances fonctionnelles qui sont sous-entendues pour un ensemble de dépendances fonctionnelles <span class="math">\(X\)</span> est appelé la <strong>fermeture</strong> de <span class="math">\(X\)</span>, écrit <span class="math">\(X^+\)</span></p>
<section id="axiomes-darmstrong" class="level3">
<h3><a href="#axiomes-darmstrong"><span class="header-section-number">4.1.1</span> Axiomes d’Armstrong</a></h3>
<p>Les <strong>axiomes d’Armstrong</strong> indiquent comment des dépendances fonctionnelles peuvent être déduites de dépendences données. Soit <span class="math">\(A\)</span>, <span class="math">\(B\)</span>, <span class="math">\(C\)</span>, des sous-ensembles des attributs de la relation <span class="math">\(R\)</span>. Nous avons alors:</p>
<ol type="1">
<li><strong>Réflexivité</strong>: <span class="math">\((B \subset A) \Rightarrow (A \mapsto B)\)</span></li>
<li><strong>Augmentation</strong>: <span class="math">\((A \mapsto B) \Rightarrow (A, C \mapsto B, C)\)</span></li>
<li><strong>Transitivité</strong>: <span class="math">\((A \mapsto B) \land (B \mapsto C) \Rightarrow (A \mapsto C)\)</span></li>
</ol>
<p>Ces règles peuvent être utilisées pour trouver <span class="math">\(X^+\)</span>. D’autres règles peuvent être dérivées des règles précédentes. Soit <span class="math">\(D\)</span>, un autre sous-ensemble des attributs de <span class="math">\(R\)</span>. Nous avons alors:</p>
<ol start="4" type="1">
<li><strong>Autodétermination</strong>: <span class="math">\(A \mapsto A\)</span></li>
<li><strong>Décomposition</strong>: <span class="math">\((A \mapsto B, C) \Rightarrow (A \mapsto B) \land (A \mapsto C)\)</span></li>
<li><strong>Union</strong>: <span class="math">\((A \mapsto B) \land (A \mapsto C) \Rightarrow (A \mapsto B, C)\)</span></li>
<li><strong>Composition</strong>: <span class="math">\((A \mapsto B) \land (C \mapsto D) \Rightarrow (A, C \mapsto B, D)\)</span></li>
</ol>
</section>
<section id="ensembles-minimaux-de-dépendances-fonctionnelles" class="level3">
<h3><a href="#ensembles-minimaux-de-dépendances-fonctionnelles"><span class="header-section-number">4.1.2</span> Ensembles minimaux de dépendances fonctionnelles</a></h3>
<p>Un ensemble de dépendances fonctionnelles <span class="math">\(X\)</span> est minimal s’il satisfait les exigences suivantes:</p>
<ul>
<li>Chaque dépendance de <span class="math">\(X\)</span> a un seul attribut du côté droit.</li>
<li>On ne peut pas remplacer une dépendance <span class="math">\(A \mapsto B\)</span> dans <span class="math">\(X\)</span> avec une dépendance <span class="math">\(C \mapsto B\)</span>, où <span class="math">\(C\)</span> est un sous-ensemble de <span class="math">\(A\)</span>, et avoir un ensemble de dépendences équivalentes à <span class="math">\(X\)</span>.</li>
<li>On ne peut pas pas enlever une dépendance de <span class="math">\(X\)</span> et toujours avoir un ensemble de dépendances équivalent à <span class="math">\(X\)</span>.</li>
</ul>
</section>
</section>
<section id="forme-normale-de-boyce-codd-bcnf" class="level2">
<h2><a href="#forme-normale-de-boyce-codd-bcnf"><span class="header-section-number">4.2</span> Forme normale de Boyce-Codd (BCNF)</a></h2>
<p>Comme la troisième forme normale souffre encore de redondances, il existe une forme normale plus forte appelée la <strong>forme normale de Boyce-Codd</strong>.</p>
<section id="définition-4" class="level3">
<h3><a href="#définition-4"><span class="header-section-number">4.2.1</span> Définition</a></h3>
<p>Une relation est en <strong>forme normale de Boyce-Codd</strong> si et seulement si <em>tous les déterminants</em> sont des <em>clés candidates</em>. Il y a un potentiel de briser la forme normale de Boyce-Codd si une des deux conditions suivantes est respectée:</p>
<ul>
<li>La relation contient deux (ou plus) clés candidates;</li>
<li>Les clés candidates se recoupent, soit qu’elles ont au moins un attribut en commun.</li>
</ul>
</section>
<section id="technique-de-normalisation-3" class="level3">
<h3><a href="#technique-de-normalisation-3"><span class="header-section-number">4.2.2</span> Technique de normalisation</a></h3>
<p>Lorsqu’une dépendance fonctionnelle enfreint les contraintes pour que la relation soit en <em>BCNF</em>, il faut mettre cette dépendance dans une autre table.</p>
</section>
</section>
<section id="dépendance-multi-valuée" class="level2">
<h2><a href="#dépendance-multi-valuée"><span class="header-section-number">4.3</span> Dépendance multi-valuée</a></h2>
<p>L’existence d’une dépendance multi-valuée est dû à la première forme normale qui empêche un attribut dans un tuple d’avoir un ensemble de valeurs.</p>
<section id="définition-5" class="level3">
<h3><a href="#définition-5"><span class="header-section-number">4.3.1</span> Définition</a></h3>
<p>Représente une dépendence entre des attributs (par exemple, <span class="math">\(A\)</span>, <span class="math">\(B\)</span> et <span class="math">\(C\)</span>) dans une relation, tel que pour chaque valeur de <span class="math">\(A\)</span>, il y un ensemble de valeurs <span class="math">\(B\)</span> et un ensemble de valeurs pour <span class="math">\(C\)</span>. Par contre, l’ensemble de valeurs de <span class="math">\(B\)</span> et <span class="math">\(C\)</span> sont indépendants chacun des autres. On dénote une dépendance multi-valuée entre les attributs <span class="math">\(A\)</span>, <span class="math">\(B\)</span> et <span class="math">\(C\)</span> en utilisant la notation suivante:</p>
<p><span class="math">\[A \twoheadrightarrow B\]</span> <span class="math">\[A \twoheadrightarrow C\]</span></p>
</section>
<section id="types-de-dépendances-multi-valuées" class="level3">
<h3><a href="#types-de-dépendances-multi-valuées"><span class="header-section-number">4.3.2</span> Types de dépendances multi-valuées</a></h3>
<p>Une dépendance multi-valuée peut être définie comme <strong>triviale</strong> ou <strong>non-triviale</strong>.</p>
<ul>
<li><strong>Triviale</strong>: Une dépendance multi-valuée est définie comme <strong>triviale</strong> si <span class="math">\((B \subset A) \lor (A \cup B = R)\)</span>.</li>
<li><strong>Non-triviale</strong>: Une dépendance multi-valuée est définie comme <strong>non-triviale</strong> si <span class="math">\(\neg ((B \subset A) \lor (A \cup B = R))\)</span></li>
</ul>
</section>
</section>
<section id="quatrième-forme-normale" class="level2">
<h2><a href="#quatrième-forme-normale"><span class="header-section-number">4.4</span> Quatrième forme normale</a></h2>
<p>La <strong>quatrième forme normale</strong> vient corriger les problèmes que les dépendances multi-valuées apportent.</p>
<section id="définition-6" class="level3">
<h3><a href="#définition-6"><span class="header-section-number">4.4.1</span> Définition</a></h3>
<p>Une relation est dans la <strong>quatrième forme normale</strong> si et seulement si pour toutes les dépendences multi-valuées non-triviales <span class="math">\(A \twoheadrightarrow B\)</span>, <span class="math">\(A\)</span> est une clé candidate de la relation.</p>
</section>
<section id="technique-de-normalisation-4" class="level3">
<h3><a href="#technique-de-normalisation-4"><span class="header-section-number">4.4.2</span> Technique de normalisation</a></h3>
<p>Il faut enlever la dépendance multi-valuée de la relation en plaçant les attributs multi-valués dans une nouvelle relation avec une copie du déterminant.</p>
</section>
</section>
</section>
<section id="algèbre-relationnelle" class="level1">
<h1><a href="#algèbre-relationnelle"><span class="header-section-number">5</span> Algèbre relationnelle</a></h1>
<p>Dans ce chapitre, nous verrons l’algèbre relationnelle et son utilité.</p>
<section id="définition-7" class="level2">
<h2><a href="#définition-7"><span class="header-section-number">5.1</span> Définition</a></h2>
<p>L’<strong>algèbre relationnelle</strong> est un langage théorique avec des opérations qui marchent sur une ou plusieurs relations pour définir une autre relation sans changer la relation originale.</p>
<p>Comme à la fois les opérandes et les résultats sont des relations, le résultat d’une opération peut être passer en paramètre à une autre opération. Cela permet aux expressions d’être imbriquées. Cette propriété s’appelle <strong>fermeture</strong>.</p>
</section>
<section id="opérations" class="level2">
<h2><a href="#opérations"><span class="header-section-number">5.2</span> Opérations</a></h2>
<p>L’algèbre relationnelle supporte plusieurs opérations. Dans cette section, nous allons définir différents types d’opérations. Dans ces définitions, nous avons <span class="math">\(R\)</span> et <span class="math">\(S\)</span>, deux relations définies par les attributs <span class="math">\(A = (a_1, a_2, \dots, a_N)\)</span> et <span class="math">\(B = (b_1, b_2, \dots, b_M)\)</span> respectivement.</p>
<section id="opérations-unaires" class="level3">
<h3><a href="#opérations-unaires"><span class="header-section-number">5.2.1</span> Opérations unaires</a></h3>
<p>L’algèbre relationnelle possède deux opérations unaires: la <strong>sélection</strong> et la <strong>projection</strong>.</p>
<section id="sélection-ou-restriction" class="level4">
<h4><a href="#sélection-ou-restriction"><span class="header-section-number">5.2.1.1</span> Sélection (ou restriction)</a></h4>
<p>La <strong>sélection</strong> s’applique sur une seule relation <span class="math">\(R\)</span> et définit une relation qui contient seulement les tuples de <span class="math">\(R\)</span> qui satisfont la condition spécifée (le <em>prédicat</em>).</p>
<p>On l’écrit</p>
<p><span class="math">\[
  \sigma_{prédicat}(R)
\]</span></p>
<p>où <span class="math">\(\sigma\)</span> est le nom de l’opération, <span class="math">\(prédicat\)</span> est le prédicat à respecter et <span class="math">\(R\)</span> est la relation sur laquelle l’opération est appliquée.</p>
<p>La sélection s’applique à l’horizontal dans une table.</p>
</section>
<section id="projection" class="level4">
<h4><a href="#projection"><span class="header-section-number">5.2.1.2</span> Projection</a></h4>
<p>La <strong>projection</strong> s’applique sur une seule relation <span class="math">\(R\)</span> et définie une relation qui contient un sous-ensemble vertical de <span class="math">\(R\)</span>. Elle extrait les valeurs des attributs spécifiés et élimine les duplicats.</p>
<p>On l’écrit</p>
<p><span class="math">\[
  \Pi_{a_1, \dots, a_n}(R)
\]</span></p>
<p>où <span class="math">\(\Pi\)</span> dénote le nom de l’opération, <span class="math">\(a_1, \dots, a_n\)</span> est le nom de chacun des attributs spécifiés et <span class="math">\(R\)</span> est la relation sur laquelle l’opération est appliquée.</p>
<p>La sélection s’applique à la vertical dans une table.</p>
</section>
</section>
<section id="opérations-binaires" class="level3">
<h3><a href="#opérations-binaires"><span class="header-section-number">5.2.2</span> Opérations binaires</a></h3>
<p>Il y a des cas où nous voulons extraire les informations de plusieurs relations à la fois. Les opérations binaires permettent de combiner les informations de deux relations à la fois.</p>
<section id="union" class="level4">
<h4><a href="#union"><span class="header-section-number">5.2.2.1</span> Union</a></h4>
<p>L’<strong>union</strong> de deux relations <span class="math">\(R\)</span> et <span class="math">\(S\)</span> définit une relation qui contient tous les tuples de <span class="math">\(R\)</span> ou de <span class="math">\(S\)</span> ou bien des deux relations. Les tuples copies sont éliminés. <span class="math">\(R\)</span> et <span class="math">\(S\)</span> doivent être compatibles à l’union.</p>
<p>On l’écrit</p>
<p><span class="math">\[
  R \cup S
\]</span></p>
<p>où <span class="math">\(R\)</span> et <span class="math">\(S\)</span> sont deux relations.</p>
</section>
<section id="différence" class="level4">
<h4><a href="#différence"><span class="header-section-number">5.2.2.2</span> Différence</a></h4>
<p>La <strong>différence</strong> définit une relation qui consiste des tuples qui sont dans la relation <span class="math">\(R\)</span>, mais pas dans la relation <span class="math">\(S\)</span>. <span class="math">\(R\)</span> et <span class="math">\(S\)</span> doivent être compatibles à l’union.</p>
<p>On l’écrit</p>
<p><span class="math">\[
  R - S
\]</span></p>
<p>où <span class="math">\(R\)</span> et <span class="math">\(S\)</span> sont deux ensembles.</p>
</section>
<section id="intersection" class="level4">
<h4><a href="#intersection"><span class="header-section-number">5.2.2.3</span> Intersection</a></h4>
<p><strong>L’intersection</strong> définit une relation consistant de l’ensemble de tous les tuples qui sont à la fois dans <span class="math">\(R\)</span> et <span class="math">\(S\)</span>. <span class="math">\(R\)</span> et <span class="math">\(S\)</span> doivent être compatibles à l’union.</p>
<p>On l’écrit</p>
<p><span class="math">\[
  R \cap S \iff R - (R - S)
\]</span></p>
<p>où <span class="math">\(R\)</span> et <span class="math">\(S\)</span> sont des relations.</p>
</section>
<section id="produit-cartésien" class="level4">
<h4><a href="#produit-cartésien"><span class="header-section-number">5.2.2.4</span> Produit cartésien</a></h4>
<p>Le <strong>produit cartésien</strong> définit une relation qui est la concaténation de tous les tuples de la relation <span class="math">\(R\)</span> avec tous les tuples de la relation <span class="math">\(S\)</span>.</p>
<p>On l’écrit</p>
<p><span class="math">\[
  R \times S
\]</span></p>
<p>où <span class="math">\(R\)</span> et <span class="math">\(S\)</span> sont des relations.</p>
</section>
<section id="décomposition-dopérations-complexes" class="level4">
<h4><a href="#décomposition-dopérations-complexes"><span class="header-section-number">5.2.2.5</span> Décomposition d’opérations complexes</a></h4>
<p>La <strong>décomposition d’opérations complexes</strong> donne un nouveau nom à <span class="math">\(S\)</span> pour l’expression <span class="math">\(E\)</span>, et nomme optionnellement les attributs en <span class="math">\(a_1, a_2, \dots, a_n\)</span>.</p>
<p>On l’écrit</p>
<p><span class="math">\[
  \rho_{s}(E) \text{ ou } \rho_{s_{(a_1, a_2, \dots, a_n)}}(E)
\]</span></p>
</section>
</section>
<section id="opérations-de-jointure" class="level3">
<h3><a href="#opérations-de-jointure"><span class="header-section-number">5.2.3</span> Opérations de jointure</a></h3>
<p>Les <strong>opérations de jointure</strong> sont parmies les opérations les plus utiles de l’algèbre relationnelle. Les opérations de jointure sont équivalents à appliquer l’opération de sélection avec le prédicat de jointure au résultat du produit cartésien des deux relations d’entrée. De manière plus symbolique, si on a <span class="math">\(F\)</span> comme prédicat de jointure et <span class="math">\(R\)</span> ainsi que <span class="math">\(S\)</span>, deux relations, nous avons que l’opération de jointure peut être définie comme:</p>
<p><span class="math">\[
  \sigma_{F}(R \times S)
\]</span></p>
<p>Les types d’opérations de jointure sont les suivants:</p>
<ul>
<li><strong>Jointure <em>theta</em></strong> ou <strong>(<span class="math">\(\theta\)</span>-join)</strong></li>
<li><strong>Equijointure</strong></li>
<li><strong>Jointure naturelle</strong></li>
<li><strong>Jointure externe</strong></li>
<li><strong>Semi-jointure</strong></li>
</ul>
<section id="jointure-theta-theta-join" class="level4">
<h4><a href="#jointure-theta-theta-join"><span class="header-section-number">5.2.3.1</span> Jointure theta (<span class="math">\(\theta\)</span>-join)</a></h4>
<p>L’opération de <strong>jointure theta</strong> définit une relation qui contient les tuples satisfants le prédicat <span class="math">\(F\)</span> à partir du résultat du produit cartésien de <span class="math">\(R\)</span> et <span class="math">\(S\)</span>. Le prédicat <span class="math">\(F\)</span> est de la forme <span class="math">\(R.a_i~\theta~S.b_i\)</span> où <span class="math">\(\theta\)</span> peut être un des opérateur de comparaison (<span class="math">\(&lt; \)</span>, <span class="math">\(\leq\)</span>, <span class="math">\(&gt;\)</span>, <span class="math">\(\geq\)</span>, <span class="math">\(=\)</span>, <span class="math">\(\neq\)</span>).</p>
<p>On l’écrit</p>
<p><span class="math">\[
  R \bowtie_{F} S \iff \sigma_{F}(R \times S)
\]</span></p>
<p>où <span class="math">\(F\)</span> est le prédicat et <span class="math">\(R\)</span> ainsi que <span class="math">\(S\)</span> sont des relations.</p>
</section>
<section id="equijointure" class="level4">
<h4><a href="#equijointure"><span class="header-section-number">5.2.3.2</span> Equijointure</a></h4>
<p>L’<strong>equijointure</strong> est un cas particulier de <span class="math">\(\theta\)</span>-join. C’est le cas où le prédicat <span class="math">\(F\)</span> contient seulement l’égalité (<span class="math">\(=\)</span>).</p>
</section>
<section id="jointure-naturelle" class="level4">
<h4><a href="#jointure-naturelle"><span class="header-section-number">5.2.3.3</span> Jointure naturelle</a></h4>
<p>La <strong>jointure naturelle</strong> est une equijointure des deux relations <span class="math">\(R\)</span> et <span class="math">\(S\)</span> sur tous leurs attributs communs <span class="math">\(x\)</span>. Une occurence de chacun des attributs communs est enlevée des résultats.</p>
<p>On l’écrit</p>
<p><span class="math">\[
  R \bowtie S
\]</span></p>
<p>où <span class="math">\(R\)</span> et <span class="math">\(S\)</span> sont des relations.</p>
</section>
<section id="jointure-externe" class="level4">
<h4><a href="#jointure-externe"><span class="header-section-number">5.2.3.4</span> Jointure externe</a></h4>
<p>La <strong>jointure externe</strong> (gauche) est une jointure dans laquelle les tuples de <span class="math">\(R\)</span> qui n’ont pas de valeurs correspondantes avec les attributs en commun avec <span class="math">\(S\)</span> ne sont pas inclus dans la relation résultante. Les valeurs manquantes dans la deuxième relation sont mises à <em>null</em>.</p>
<p>On l’écrit</p>
<p><span class="math">\[
\begin{align*}
  &amp;R \rtimes S \text{ (Jointure externe gauche) }
  \\
  &amp;R \ltimes S \text{ (Jointure externe droite) }
\end{align*}
\]</span></p>
</section>
<section id="semi-jointure" class="level4">
<h4><a href="#semi-jointure"><span class="header-section-number">5.2.3.5</span> Semi-jointure</a></h4>
<p>La <strong>semi-jointure</strong> définit une relation qui contient les tuples de <span class="math">\(R\)</span> qui participent dans la jointure de <span class="math">\(R\)</span> avec <span class="math">\(S\)</span> satisfaisant le prédicat <span class="math">\(F\)</span>.</p>
<p>On l’écrit</p>
<p><span class="math">\[
  R \triangleright_{F} S \iff \Pi_{A}(R \bowtie_{F} S)
\]</span></p>
<p>où <span class="math">\(A\)</span> est l’ensemble de tous les attributs de <span class="math">\(R\)</span>.</p>
</section>
</section>
<section id="division" class="level3">
<h3><a href="#division"><span class="header-section-number">5.2.4</span> Division</a></h3>
<p>Assumons que la relation <span class="math">\(R\)</span> est définie à partir de l’ensemble d’attributs <span class="math">\(A\)</span> et que la relation <span class="math">\(S\)</span> est définie à partir de l’ensemble d’attributs <span class="math">\(B\)</span> tel que <span class="math">\(B \subseteq A\)</span>. Soit <span class="math">\(C = A - B\)</span>, c’est-à-dire <span class="math">\(C\)</span> est l’ensemble des attributs de <span class="math">\(R\)</span> qui ne sont pas des attributs de <span class="math">\(S\)</span>. Alors, l’opération de division définit une relation à partir des attributs <span class="math">\(C\)</span> qui consiste à l’ensemble des tuples de <span class="math">\(R\)</span> qui concordent avec <em>tous</em> les tuples de <span class="math">\(S\)</span>.</p>
<p>On l’écrit</p>
<p><span class="math">\[
  R \div S
\]</span></p>
<p>que l’on peut aussi réécrire comme</p>
<p><span class="math">\[
\begin{align*}
  T_1~ &amp;\neg ~\Pi_{C}(R)
  \\
  T_2~ &amp;\neg ~\Pi_{C}((T_1 \times S) - R)
  \\
  T~ &amp;\neg ~T_{1} - T_{2}
\end{align*}
\]</span></p>
</section>
<section id="agrégation" class="level3">
<h3><a href="#agrégation"><span class="header-section-number">5.2.5</span> Agrégation</a></h3>
<p>Applique la liste des fonctions agrégates, <span class="math">\(AL\)</span>, à la relation <span class="math">\(R\)</span> pour définir une relation à partir de la liste agrégate. <span class="math">\(AL\)</span> contient une paire (<span class="math">\(\langle \text{ fonction_agrégate } \rangle , \langle \text{ attribut } \rangle\)</span> ou plus.</p>
<p>On l’écrit</p>
<p><span class="math">\[
  _ {AL} (R)
\]</span></p>
<p>Les principales fonctions agrégates sont les suivantes:</p>
<ul>
<li><em>COUNT</em>: Retourne le nombre de valeurs de l’attribut associé.</li>
<li><em>SUM</em>: Retourne la somme des valeurs de l’attribut associé.</li>
<li><em>AVG</em>: Retourne la moyenne des valeurs de l’attribut associé.</li>
<li><em>MIN</em>: Retourne la plus petite valeur de l’attribut associé.</li>
<li><em>MAX</em>: Retourne la plus grande valeur de l’attribut associé.</li>
</ul>
</section>
<section id="regroupement" class="level3">
<h3><a href="#regroupement"><span class="header-section-number">5.2.6</span> Regroupement</a></h3>
<p>Groupe les tuples de la relation <span class="math">\(R\)</span> par les attributs de groupement, <span class="math">\(GA\)</span>, et applique ensuite la liste de fonctions agrégates <span class="math">\(AL\)</span> pour définir une nouvelle relation. <span class="math">\(AL\)</span> contient une paire (<span class="math">\(\langle \text{ fonction_agrégate } \rangle , \langle \text{ attribut } \rangle\)</span> ou plus. La relation résultante contient les attributs de groupement <span class="math">\(GA\)</span> avec le résultat de chacune des fonctions agrégates.</p>
<p>On l’écrit</p>
<p><span class="math">\[
 _ {GA~AL}(R)
\]</span></p>
<p>La forme générale de l’opération de regroupement est la suivante:</p>
<p><span class="math">\[
  a_1, a_2, \dots, a_n~ {}_{\langle A_p a_p \rangle, \langle A_q a_q \rangle, \dots, \langle A_z a_z \rangle}(R)
\]</span></p>
<p>où <span class="math">\(R\)</span> est une relation quelconque, <span class="math">\(a_1, a_2, \dots, a_n\)</span> sont des attributs de <span class="math">\(R\)</span>, <span class="math">\(a_p, a_q, \dots, a_z\)</span> sont d’autres attributs de <span class="math">\(R\)</span> et <span class="math">\(A_p, A_q, \dots, A_z\)</span> sont des fonctions agrégates. Les tuples de <span class="math">\(R\)</span> sont partitionnés de sorte que:</p>
<ul>
<li>tous les tuples dans un groupe on la même valeur pour <span class="math">\(a_1, a_2, \dots, a_n\)</span>;</li>
<li>les tuples dans différents groupes ont des valeurs différentes pour <span class="math">\(a_1, a_2, \dots, a_n\)</span>.</li>
</ul>
</section>
</section>
</section>
<section id="structured-query-language-sql-manipulation-des-données" class="level1">
<h1><a href="#structured-query-language-sql-manipulation-des-données"><span class="header-section-number">6</span> Structured Query Language (SQL) : Manipulation des données</a></h1>
<p>Dans ce chapitre, nous aborderons des notions sur le <strong>Structured Query Language</strong> ou <strong>SQL</strong>.</p>
<section id="objectifs-du-sql" class="level2">
<h2><a href="#objectifs-du-sql"><span class="header-section-number">6.1</span> Objectifs du SQL</a></h2>
<p>Idéalement, un langage de bases de données devrait permettre de</p>
<ul>
<li>créer la base de données et les structures des relations</li>
<li>faire des opérations de gestion de données telles que l’insertion, la modification and la supression de données des relations</li>
<li>faire des requêtes à la fois simples et complexes</li>
</ul>
<p>Le langage doit être simple; sa syntaxe et sa structure de commandes doivent être simples à apprendre. Le langage doit aussi être portable, c’est-à-dire qu’il doit être conforme à des standards pour que nous puissions utiliser les mêmes commandes d’un système de gestion de bases de données à un autre.</p>
</section>
<section id="informations-sur-le-sql" class="level2">
<h2><a href="#informations-sur-le-sql"><span class="header-section-number">6.2</span> Informations sur le SQL</a></h2>
<p>Le SQL est un <strong>langage orienté transformation</strong> ce qui veut dire que c’est un langage qui a été développé pour utiliser des relations pour transformer des entrées en des sorties demandées. Le SQL possède deux parties majeurs:</p>
<ul>
<li>Un <strong>langage de définition des données (DDL)</strong> pour définir la structure de la base de données et contrôler l’accès aux données.</li>
<li>Un <strong>langage de manipulation des données (DML)</strong> pour aller chercher et mettre à jour les données.</li>
</ul>
<p>Le SQL est un langage qui n’est pas procédural. Nous spécifions les données dont nous avons besoin plutôt que comment aller les chercher. Autrement dit, nous n’avons pas à nous occuper des méthodes d’accès aux données: SQL le fait pour nous.</p>
<section id="terminalogie" class="level3">
<h3><a href="#terminalogie"><span class="header-section-number">6.2.1</span> Terminalogie</a></h3>
<p>Les standards ISO du SQL n’utilisent pas les termes formels <em>relations</em>, <em>attributs</em> et <em>tuples</em>. Ils utilisent plutôt les mots <em>tables</em>, <em>colonnes</em> et <em>rangées</em>.</p>
</section>
</section>
<section id="écrire-des-commandes-sql" class="level2">
<h2><a href="#écrire-des-commandes-sql"><span class="header-section-number">6.3</span> Écrire des commandes SQL</a></h2>
<p>Une déclaration SQL consiste de <strong>mots réservés</strong> et <strong>de mots définis par l’utilisateur</strong>. Les mots réservés font partis du langage et ont un sens fixes alors que les mots définis par l’utilisateur font références à des objets de la base de données comme les tables, colonnes, vues, indexes, etc. Les déclarations SQL ne sont pas sensibles à la casse. La seule exception est que les caractères litéraux doivent être écrits comme ils apparaissent dans la base de données.</p>
<section id="convention-de-code" class="level3">
<h3><a href="#convention-de-code"><span class="header-section-number">6.3.1</span> Convention de code</a></h3>
<p>La convention du cours utilise en partie la <strong>forme de Backus Naur (BNF)</strong>. La convention que nous allons utiliser est donc la suivante:</p>
<ul>
<li>les mots réservés sont écrits en minuscules;</li>
<li>les mots définis par l’utilisateur sont en majuscules;</li>
<li>la bar vertical (<span class="math">\(|\)</span>) indique un choix parmi des alternatives;</li>
<li>les accolades indiquent un élément requis;</li>
<li>les crochets indiquent un élément optionnel;</li>
<li>les points de suspension indique une répétition optionnelle d’un objet zéro ou plusieurs fois.</li>
</ul>
</section>
<section id="manipulation-des-données" class="level3">
<h3><a href="#manipulation-des-données"><span class="header-section-number">6.3.2</span> Manipulation des données</a></h3>
<p>Cette section traite des différentes expressions du DML du SQL:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> <span class="co">-- pour aller chercher des données dans la base de données</span>
    <span class="kw">insert</span> <span class="co">-- pour insérer des données dans une table</span>
    <span class="kw">update</span> <span class="co">-- pour mettre à jour des données dans une table</span>
    <span class="kw">delete</span> <span class="co">-- pour effacer des données d&#39;une table</span></code></pre>
<p>Pour les explications des expressions, nous allons utiliser les tables suivantes:</p>
<table>
<caption>Cas d’étude <em>DreamHome</em></caption>
<tbody>
<tr class="odd">
<td style="text-align: left;">Branch</td>
<td style="text-align: left;">(<strong>Branch</strong>, street, city, postcode)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Staff</td>
<td style="text-align: left;">(<strong>staffNo</strong>, fName, lName, position, sex, DOB, salary, branchNo)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">PropertyForRent</td>
<td style="text-align: left;">(<strong>propertyNo</strong>, street, city, postcode, type, rooms, rent,</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">ownerNo, staffNo, branchNo)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Client</td>
<td style="text-align: left;">(<strong>clientNo</strong>, fName, lName, telNo, prefType, maxRent, eMail)</td>
</tr>
<tr class="even">
<td style="text-align: left;">PrivateOwner</td>
<td style="text-align: left;">(<strong>ownerNo</strong>, fName, lName, address, telNo, eMail, password)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Viewing</td>
<td style="text-align: left;">(<strong>clientNo</strong>, propertyNo, viewDate, comment)</td>
</tr>
</tbody>
</table>
</section>
<section id="litéraux" class="level3">
<h3><a href="#litéraux"><span class="header-section-number">6.3.3</span> Litéraux</a></h3>
<p>Les litéraux sont des constantes qui sont utilisées dans des expressions SQL. Les chaines de caractères litérales doivent être entourées de guillemets simples et les litéraux numériques ne doivent pas avoir de guillemets.</p>
<p>Un exemple d’insertion de litéraux dans une table pourrait ressembler à</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">insert</span> <span class="kw">into</span> PropertyForRent(propertyNo, street, city, postcode, <span class="kw">type</span>, 
                                rooms, rent, ownerNo, staffNo, branchNo)
    <span class="kw">values</span> (<span class="st">&#39;PA14&#39;</span>, <span class="st">&#39;16 Holhead&#39;</span>, <span class="st">&#39;Aberdeen&#39;</span>, <span class="st">&#39;AB7 5SU&#39;</span>, <span class="st">&#39;House&#39;</span>, <span class="dv">6</span>, <span class="fl">650.00</span>,
            <span class="st">&#39;CO46&#39;</span>, <span class="st">&#39;SA9&#39;</span>, <span class="st">&#39;B007&#39;</span>);</code></pre>
</section>
<section id="select" class="level3">
<h3><a href="#select"><span class="header-section-number">6.3.4</span> SELECT</a></h3>
<p>L’expression <code>select</code> est utilisé pour aller chercher et afficher des données d’une ou plusieurs tables de bases de données. Elle permet de faire l’équivalent des opérations de <em>sélection</em>, <em>projecture</em> et de <em>jointure</em> de l’algèbre relationnelle.</p>
<p>L’expression <code>select</code> a la forme suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span>      [<span class="kw">distinct</span> | <span class="kw">all</span>] {* | [columnExpression [<span class="kw">as</span> newName]] [,...]}
    <span class="kw">from</span>        TableName [alias] [,...]
    [<span class="kw">where</span>      condition]
    [<span class="kw">group</span> <span class="kw">by</span>   columnList] [<span class="kw">having</span> condition]
    [<span class="kw">order</span> <span class="kw">by</span>   columnList]</code></pre>
<p>où chacune des expressions a la signification suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">from</span>        <span class="co">-- Table(s) à utiliser</span>
    <span class="kw">where</span>       <span class="co">-- Filtre rangées selon une condition</span>
    <span class="kw">group</span> <span class="kw">by</span>    <span class="co">-- Forme des groupes de rangées avec des mêmes valeurs de colonnes</span>
    <span class="kw">having</span>      <span class="co">-- Filtre les groupes selon une condition</span>
    <span class="kw">select</span>      <span class="co">-- Spécifie les colonnes qui vont apparaître dans la sortie</span>
    <span class="kw">order</span> <span class="kw">by</span>    <span class="co">-- Spécifie l&#39;ordre d&#39;affichage</span></code></pre>
<p>Il est important de retenir que l’ordre des clauses de l’expression <code>select</code> ne peut être changé et que les deux seules clauses obligatoires sont les deux premières: <code>select</code> et <code>from</code>. Les autres clauses sont optionnelles. Le résultat d’une expression <code>select</code> est une autre table.</p>
<section id="exemples-dutilisation-du-select" class="level4">
<h4><a href="#exemples-dutilisation-du-select"><span class="header-section-number">6.3.4.1</span> Exemples d’utilisation du SELECT</a></h4>
<p>Dans tous les exemples suivants, nous allons nous servir de la table <em>DreamHome</em>.</p>
<section id="aller-chercher-toutes-les-colonnes-et-rangées" class="level5">
<h5><a href="#aller-chercher-toutes-les-colonnes-et-rangées"><span class="header-section-number">6.3.4.1.1</span> Aller chercher toutes les colonnes et rangées</a></h5>
<p>Nous voulons aller chercher toutes les informations sur le personnel.</p>
<p>Comme il n’y a pas de conditions, nous n’avons pas besoin d’un <code>where</code>. Nous pouvons donc écrire cette requête comme</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, position, sex, DOB, salary, branchNo
    <span class="kw">from</span> Staff;</code></pre>
<p>Comme nous sélectionnons toutes les colonnes, nous pourrions réécrire cette requête comme</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> *
    <span class="kw">from</span> Staff;</code></pre>
<p>Nous obtiendrons la table suivante:</p>
<table>
<caption>Résultat de la requête</caption>
<thead>
<tr class="header">
<th style="text-align: left;">staffNo</th>
<th style="text-align: left;">fName</th>
<th style="text-align: left;">lName</th>
<th style="text-align: left;">position</th>
<th style="text-align: left;">sex</th>
<th style="text-align: left;">DOB</th>
<th style="text-align: left;">salary</th>
<th style="text-align: left;">branchNo</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">SL21</td>
<td style="text-align: left;">John</td>
<td style="text-align: left;">White</td>
<td style="text-align: left;">Manager</td>
<td style="text-align: left;">M</td>
<td style="text-align: left;">1-Oct-45</td>
<td style="text-align: left;">30000.00</td>
<td style="text-align: left;">B005</td>
</tr>
<tr class="even">
<td style="text-align: left;">SG37</td>
<td style="text-align: left;">Ann</td>
<td style="text-align: left;">Beech</td>
<td style="text-align: left;">Assistant</td>
<td style="text-align: left;">F</td>
<td style="text-align: left;">10-Nov-60</td>
<td style="text-align: left;">12000.00</td>
<td style="text-align: left;">B003</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SG14</td>
<td style="text-align: left;">David</td>
<td style="text-align: left;">Ford</td>
<td style="text-align: left;">Supervisor</td>
<td style="text-align: left;">M</td>
<td style="text-align: left;">24-Mar-58</td>
<td style="text-align: left;">18000.00</td>
<td style="text-align: left;">B003</td>
</tr>
<tr class="even">
<td style="text-align: left;">SA9</td>
<td style="text-align: left;">Mary</td>
<td style="text-align: left;">Howe</td>
<td style="text-align: left;">Assistant</td>
<td style="text-align: left;">F</td>
<td style="text-align: left;">19-Feb-70</td>
<td style="text-align: left;">9000.00</td>
<td style="text-align: left;">B007</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SG5</td>
<td style="text-align: left;">Susan</td>
<td style="text-align: left;">Brand</td>
<td style="text-align: left;">Manager</td>
<td style="text-align: left;">F</td>
<td style="text-align: left;">3-Jun-40</td>
<td style="text-align: left;">24000.00</td>
<td style="text-align: left;">B003</td>
</tr>
<tr class="even">
<td style="text-align: left;">SL41</td>
<td style="text-align: left;">Julie</td>
<td style="text-align: left;">Lee</td>
<td style="text-align: left;">Assistant</td>
<td style="text-align: left;">F</td>
<td style="text-align: left;">13-Jun-65</td>
<td style="text-align: left;">9000.00</td>
<td style="text-align: left;">B005</td>
</tr>
</tbody>
</table>
</section>
<section id="aller-chercher-des-colonnes-spécifiques-et-toutes-les-rangées" class="level5">
<h5><a href="#aller-chercher-des-colonnes-spécifiques-et-toutes-les-rangées"><span class="header-section-number">6.3.4.1.2</span> Aller chercher des colonnes spécifiques et toutes les rangées</a></h5>
<p>On veut la liste des salaires de tous les employés en montrant seulement les numéros d’employés, les prénoms, les noms de famille et les détails du salaire.</p>
<p>Cette requête serait écrite comme</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, salary
    <span class="kw">from</span> Staff;</code></pre>
<p>Ce qui nous donnerait la table suivante:</p>
<table>
<caption>Résultat de la requête</caption>
<thead>
<tr class="header">
<th style="text-align: left;">staffNo</th>
<th style="text-align: left;">fName</th>
<th style="text-align: left;">lName</th>
<th style="text-align: left;">salary</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">SL21</td>
<td style="text-align: left;">John</td>
<td style="text-align: left;">White</td>
<td style="text-align: left;">30000.00</td>
</tr>
<tr class="even">
<td style="text-align: left;">SG37</td>
<td style="text-align: left;">Ann</td>
<td style="text-align: left;">Beech</td>
<td style="text-align: left;">12000.00</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SG14</td>
<td style="text-align: left;">David</td>
<td style="text-align: left;">Ford</td>
<td style="text-align: left;">18000.00</td>
</tr>
<tr class="even">
<td style="text-align: left;">SA9</td>
<td style="text-align: left;">Mary</td>
<td style="text-align: left;">Howe</td>
<td style="text-align: left;">9000.00</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SG5</td>
<td style="text-align: left;">Susan</td>
<td style="text-align: left;">Brand</td>
<td style="text-align: left;">24000.00</td>
</tr>
<tr class="even">
<td style="text-align: left;">SL41</td>
<td style="text-align: left;">Julie</td>
<td style="text-align: left;">Lee</td>
<td style="text-align: left;">9000.00</td>
</tr>
</tbody>
</table>
</section>
<section id="utiliser-distinct" class="level5">
<h5><a href="#utiliser-distinct"><span class="header-section-number">6.3.4.1.3</span> Utiliser DISTINCT</a></h5>
<p>Lorsqu’on fait un <code>select</code> sur une table, les copies sont conservés. Le mot clé <code>distinct</code> permet d’éliminer les copies. Par exemple,</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> <span class="kw">distinct</span> propertyNo
    <span class="kw">from</span> Viewing;</code></pre>
<p>va seulement retourner un seul numéro de propriété par copie.</p>
</section>
<section id="champs-calculés" class="level5">
<h5><a href="#champs-calculés"><span class="header-section-number">6.3.4.1.4</span> Champs calculés</a></h5>
<p>Nous voulons avoir la liste de tous les salaires mensuels de tous les employés, montrer les numéros d’employé, les prénoms, les noms de famille et les détails des salaires.</p>
<p>Il est possible d’ajouter des opérations arithmétiques à des expressions SQL. Ainsi, pour construire la requête demandée, nous pourrions écrire</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, salary/<span class="dv">12</span>
    <span class="kw">from</span> Staff;</code></pre>
<p>ou, avec un alias,</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, salary/<span class="dv">12</span> <span class="kw">as</span> monthlySalary
    <span class="kw">from</span> Staff;</code></pre>
</section>
</section>
<section id="sélection-de-rangées-where" class="level4">
<h4><a href="#sélection-de-rangées-where"><span class="header-section-number">6.3.4.2</span> Sélection de rangées (WHERE)</a></h4>
<p>Avec l’expression <code>where</code>, nous pouvons sélectionner des rangées spécifiques. Pour ce faire, nous utilisons le mot clé <code>where</code> suivi d’un prédicat. Les prédicats de base sont les suivants:</p>
<ul>
<li><em>Comparaison</em>: Compare la valeur d’une expression avec la valeur d’une autre expression.</li>
<li><em>Recherche d’écart</em>: Teste si la valeur d’une expression se retrouve dans une certaine plage de valeurs.</li>
<li><em>Appartenance à un ensemble</em>: Teste si la valeur d’une expression est égale à celle d’un ensemble de valeurs.</li>
<li><em>Correspondance à un masque</em>: Teste si une chaîne de caractères correspond à un modèle spécifique.</li>
<li><em>Null</em>: Teste si la colonne a une valeur nulle (inconnue).</li>
</ul>
<p>Les opérateurs de comparaison suivants sont disponibles dans le langage SQL:</p>
<pre><code>    =       égal
    &lt;&gt;      pas égale
    &lt;       plus petit que
    &lt;=      plus petit ou égal
    &gt;       plus grand que
    &gt;=      plus grand ou égal</code></pre>
<p>Il y aussi les opérateurs logiques <code>AND</code>, <code>OR</code> et <code>NOT</code> qui sont disponibles. Les prioriétés des opérations sont les suivantes:</p>
<ul>
<li>Une expression est évaluée de gauche à droite.</li>
<li>Les sous-expressions entre parenthèses sont évaluées en premier.</li>
<li>Les <code>NOT</code> sont évalués avant les <code>AND</code> et les <code>OR</code>.</li>
<li>Les <code>AND</code> sont évalués avant les <code>OR</code>.</li>
</ul>
<section id="exemples-dutilisation-du-where" class="level5">
<h5><a href="#exemples-dutilisation-du-where"><span class="header-section-number">6.3.4.2.1</span> Exemples d’utilisation du WHERE</a></h5>
<p>Dans cette section, nous allons voir des exemples d’utilisation de la clause <code>where</code>.</p>
<section id="prédicat-de-comparaison" class="level6">
<h6><a href="#prédicat-de-comparaison"><span class="header-section-number">6.3.4.2.1.1</span> Prédicat de comparaison</a></h6>
<p>On souhaite avoir la liste de tous les employés avec un salaire plus grand que 10000$.</p>
<p>Nous pouvons donc utiliser la clause <code>where</code> de la manière suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, position, salary
    <span class="kw">from</span> Staff
    <span class="kw">where</span> salary &gt; <span class="dv">10000</span>;</code></pre>
<p>Ce bout de code va créer une table dont les rangées correspondent aux rangées de la table initiale dont le salaire des employés est plus grand que 10000$.</p>
</section>
<section id="prédicat-de-comparaison-composé" class="level6">
<h6><a href="#prédicat-de-comparaison-composé"><span class="header-section-number">6.3.4.2.1.2</span> Prédicat de comparaison composé</a></h6>
<p>On souhaite avoir la liste de toutes les adresses des filiales de Londres et Glasgow.</p>
<p>Nous pouvons donc utiliser la clause <code>where</code> de la manière suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> *
    <span class="kw">from</span> Branch
    <span class="kw">where</span> city = <span class="st">&#39;London&#39;</span> <span class="kw">or</span> city = <span class="st">&#39;Glasgow&#39;</span>;</code></pre>
<p>Cela va créer une table dont les rangées correspondent aux rangées de la table initiale où la ville était soit Londres ou Glasgow.</p>
</section>
<section id="prédicat-de-recherche-décart-betweennot-between" class="level6">
<h6><a href="#prédicat-de-recherche-décart-betweennot-between"><span class="header-section-number">6.3.4.2.1.3</span> Prédicat de recherche d’écart (BETWEEN/NOT BETWEEN)</a></h6>
<p>On souhaite avoir tous les employés dont le salaire se situe entre 20000$ et 30000$.</p>
<p>Nous pouvons donc utiliser la clause <code>where</code> de la manière suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, position, salary
    <span class="kw">from</span> Staff
    <span class="kw">where</span> salary <span class="kw">between</span> <span class="dv">20000</span> <span class="kw">and</span> <span class="dv">30000</span>;</code></pre>
<p>Cela va créer une table dont les rangées correspondent aux rangées de la table initiale dont le salaire des employés était entre 20000 et 30000.</p>
<p>Nous aurions aussi pu écrire</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, position, salary
    <span class="kw">from</span> Staff
    <span class="kw">where</span> salary &gt;= <span class="dv">20000</span> <span class="kw">and</span> salary &lt;= <span class="dv">30000</span>;</code></pre>
</section>
<section id="prédicat-dappartenance-à-un-ensemble-innot-in" class="level6">
<h6><a href="#prédicat-dappartenance-à-un-ensemble-innot-in"><span class="header-section-number">6.3.4.2.1.4</span> Prédicat d’appartenance à un ensemble (IN/NOT IN)</a></h6>
<p>On souhaite avoir tous les employés qui sont des managers et des superviseurs.</p>
<p>Nous pouvons donc utiliser la clause <code>where</code> de la manière suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, position
    <span class="kw">from</span> Staff
    <span class="kw">where</span> position <span class="kw">in</span> (<span class="st">&#39;Manager&#39;</span>, <span class="st">&#39;Supervisor&#39;</span>);</code></pre>
<p>Cela va créer une table dont les rangées correspondent aux rangées de la table initiale dans lesquelles le poste des employés était soit un manager ou un superviseur.</p>
<p>Nous aurions aussi pu écrire</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, position
    <span class="kw">from</span> Staff
    <span class="kw">where</span> position = <span class="st">&#39;Manager&#39;</span> <span class="kw">or</span> position = <span class="st">&#39;Supervisor&#39;</span>;</code></pre>
</section>
<section id="prédicat-de-correspondance-à-un-masque-likenot-like" class="level6">
<h6><a href="#prédicat-de-correspondance-à-un-masque-likenot-like"><span class="header-section-number">6.3.4.2.1.5</span> Prédicat de correspondance à un masque (LIKE/NOT LIKE)</a></h6>
<p>Nous voulons trouver tous les propriétaires qui ont la chaîne de caractères ‘Glasgow’ dans leur adresse.</p>
<p>Le SQL possède deux symboles pour trouver des correspondances entre des chaînes de caractères:</p>
<ul>
<li>Le caractère % représente une séquence de zéro caractère ou plus.</li>
<li>Le caractère _ représente n’importe quel caractère.</li>
</ul>
<p>Tous les autres caractères se représentent eux-mêmes.</p>
<p>Ainsi, notre requête pour résoudre notre problème serait la suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> ownerNo, fName, lName, address, telNo
    <span class="kw">from</span> PrivateOwner
    <span class="kw">where</span> address <span class="kw">like</span> <span class="st">&#39;%Glasgow%&#39;</span>; <span class="co">-- N&#39;importe quelle chaine, tant qu&#39;elle contient &#39;Glasgow&#39;</span></code></pre>
</section>
<section id="prédicat-de-recherche-de-null-is-nullis-not-null" class="level6">
<h6><a href="#prédicat-de-recherche-de-null-is-nullis-not-null"><span class="header-section-number">6.3.4.2.1.6</span> Prédicat de recherche de NULL (IS NULL/IS NOT NULL)</a></h6>
<p>Nous voulons avoir les détails sur toutes les propriétés PG4 où un commentaire n’a pas été fourni.</p>
<p>Nous pouvons donc utiliser la clause de la manière suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> clientNo, viewDate
    <span class="kw">from</span> Viewing
    <span class="kw">where</span> propertyNo = <span class="st">&#39;PG4&#39;</span> <span class="kw">and</span> <span class="kw">comment</span> <span class="kw">is</span> <span class="kw">null</span>;</code></pre>
</section>
</section>
</section>
<section id="trier-les-résultats-order-by" class="level4">
<h4><a href="#trier-les-résultats-order-by"><span class="header-section-number">6.3.4.3</span> Trier les résultats (ORDER BY)</a></h4>
<p>La clause <code>ORDER BY</code> permet de classer des éléments selon un certain ordre. La clause <code>ORDER BY</code> reçoit en arguments la liste des identifiants des colonnes séparés par des virgules à partir desquels nous voulons trier. Il y a deux ordres de tri: en ordre croissant (ASC) et en ordre décroissant (DESC). La clause <code>ORDER BY</code> doit toujours être la dernière clause d’une expression <code>SELECT</code>. Le premier élément qui apparait dans la clause est appelé la <strong>clé majeure de tri</strong>. C’est elle qui va décider de l’ordre de tri général. Si les éléments de la colonne sont uniques, un élément de tri de va être suffisant. Sinon, on peut rajouter des éléments à la clause pour spécifier l’ordre de tri. On appelle tous les éléments qui apparaissent après la clé majeure de tri des <strong>clés mineures de tri</strong></p>
<section id="exemples-dutilisation-du-order-by" class="level5">
<h5><a href="#exemples-dutilisation-du-order-by"><span class="header-section-number">6.3.4.3.1</span> Exemples d’utilisation du ORDER BY</a></h5>
<p>Dans cette section, nous verrons des exemples d’utilisation de la clause <code>ORDER BY</code>.</p>
<section id="tri-avec-une-seule-colonne" class="level6">
<h6><a href="#tri-avec-une-seule-colonne"><span class="header-section-number">6.3.4.3.1.1</span> Tri avec une seule colonne</a></h6>
<p>Nous voulons la liste du salaire des employés en ordre décroissant.</p>
<p>Nous pourrions donc écrire la clause suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo, fName, lName, salary
    <span class="kw">from</span> Staff
    <span class="kw">order</span> <span class="kw">by</span> salary <span class="kw">desc</span>;</code></pre>
</section>
<section id="tri-avec-plusieurs-colonnes" class="level6">
<h6><a href="#tri-avec-plusieurs-colonnes"><span class="header-section-number">6.3.4.3.1.2</span> Tri avec plusieurs colonnes</a></h6>
<p>Nous voulons avoir la liste des propriétés triées par le type des propriétés.</p>
<p>Nous pourrions écrire la clause suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql"><span class="kw">select</span> propertyNo, <span class="kw">type</span>, rooms, rent
<span class="kw">from</span> PropertyForRent
<span class="kw">order</span> <span class="kw">by</span> <span class="kw">type</span>;</code></pre>
<p>On obtiendrait alors la table suivante:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">propertyNo</th>
<th style="text-align: left;">type</th>
<th style="text-align: left;">rooms</th>
<th style="text-align: left;">rent</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">PL94</td>
<td style="text-align: left;">Flat</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">400</td>
</tr>
<tr class="even">
<td style="text-align: left;">PG4</td>
<td style="text-align: left;">Flat</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">350</td>
</tr>
<tr class="odd">
<td style="text-align: left;">PG36</td>
<td style="text-align: left;">Flat</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">375</td>
</tr>
<tr class="even">
<td style="text-align: left;">PG16</td>
<td style="text-align: left;">Flat</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">450</td>
</tr>
<tr class="odd">
<td style="text-align: left;">PA14</td>
<td style="text-align: left;">House</td>
<td style="text-align: left;">6</td>
<td style="text-align: left;">650</td>
</tr>
<tr class="even">
<td style="text-align: left;">PG21</td>
<td style="text-align: left;">House</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">600</td>
</tr>
</tbody>
</table>
<p>Par contre, si on précise une clé mineure de tri avec la clause suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql"><span class="kw">select</span> propertyNo, <span class="kw">type</span>, rooms, rent
<span class="kw">from</span> PropertyForRent
<span class="kw">order</span> <span class="kw">by</span> <span class="kw">type</span>, rent <span class="kw">desc</span>;</code></pre>
<p>On obtiendrait la table suivante:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">propertyNo</th>
<th style="text-align: left;">type</th>
<th style="text-align: left;">rooms</th>
<th style="text-align: left;">rent</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">PG16</td>
<td style="text-align: left;">Flat</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">450</td>
</tr>
<tr class="even">
<td style="text-align: left;">PL94</td>
<td style="text-align: left;">Flat</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">400</td>
</tr>
<tr class="odd">
<td style="text-align: left;">PG36</td>
<td style="text-align: left;">Flat</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">375</td>
</tr>
<tr class="even">
<td style="text-align: left;">PG4</td>
<td style="text-align: left;">Flat</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">350</td>
</tr>
<tr class="odd">
<td style="text-align: left;">PA14</td>
<td style="text-align: left;">House</td>
<td style="text-align: left;">6</td>
<td style="text-align: left;">650</td>
</tr>
<tr class="even">
<td style="text-align: left;">PG21</td>
<td style="text-align: left;">House</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">600</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
<section id="fonctions-sql-dagrégation" class="level4">
<h4><a href="#fonctions-sql-dagrégation"><span class="header-section-number">6.3.4.4</span> Fonctions SQL d’agrégation</a></h4>
<p>Les fonctions d’agrégation permettent d’effectuer des opérations sur des données. Il existe 5 types de fonctions d’agrégation définies par les standards ISO:</p>
<ul>
<li><code>COUNT</code>: Retourne le nombre de valeurs dans la colonne spécifiée.</li>
<li><code>SUM</code>: Retourne la somme des valeurs dans la colonne spécifiée.</li>
<li><code>AVG</code>: Retourne la moyenne des valeurs dans la colonne spécifiée.</li>
<li><code>MIN</code>: Retourne la plus petite valeur dans la colonne spécifiée.</li>
<li><code>MAX</code>: Retourne la plus grande valeur dans la colonne spécifiée.</li>
</ul>
<p>Les fonctions <code>AVG</code> et <code>SUM</code> peuvent seulement être utilisées sur des colonnes numériques. Toutes les fonctions éliminent les <em>nulls</em> avant d’effectuer leurs calculs. Il y a seulement <code>COUNT(*)</code> qui n’élimine pas les <em>nulls</em> avant de faire ses opérations.</p>
<p>Si on veut éliminer les copies, il faut utiliser le mot clé <code>DISTINCT</code> avant le nom de la colonne dans la fonction. Si on spécifie le mot clé <code>ALL</code> devant le nom des colonnes, on indique qu’on permet les copies.</p>
<section id="exemples-dutilisation-des-fonctions-sql-dagrégation" class="level5">
<h5><a href="#exemples-dutilisation-des-fonctions-sql-dagrégation"><span class="header-section-number">6.3.4.4.1</span> Exemples d’utilisation des fonctions SQL d’agrégation</a></h5>
<p>Dans cette section, nous verrons des exemples d’utilisation des fonctions SQL d’agrégation.</p>
<section id="utilisation-de-count" class="level6">
<h6><a href="#utilisation-de-count"><span class="header-section-number">6.3.4.4.1.1</span> Utilisation de <code>COUNT(*)</code></a></h6>
<p>Nous souhaitons savoir combien de propriétés coûtent plus chères que 350$ par mois.</p>
<p>Nous allons donc avoir la clause suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> staffNo <span class="fu">count</span>(salary)
    <span class="kw">from</span> Staff;</code></pre>
</section>
<section id="utilisation-de-countdistinct" class="level6">
<h6><a href="#utilisation-de-countdistinct"><span class="header-section-number">6.3.4.4.1.2</span> Utilisation de <code>COUNT(DISTINCT)</code></a></h6>
<p>Nous souhaitons savoir combien de propriétés différentes ont été vues en mai 2013.</p>
<p>Nous allons donc avoir la clause suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> <span class="fu">count</span>(<span class="kw">distinct</span> propertyNo) <span class="kw">as</span> myCount
    <span class="kw">from</span> Viewing
    <span class="kw">where</span> viewDate <span class="kw">between</span> <span class="st">&#39;1-May-13&#39;</span> <span class="kw">and</span> <span class="st">&#39;31-May-13&#39;</span>;</code></pre>
</section>
<section id="utilisation-de-count-et-sum" class="level6">
<h6><a href="#utilisation-de-count-et-sum"><span class="header-section-number">6.3.4.4.1.3</span> Utilisation de <code>COUNT</code> et <code>SUM</code></a></h6>
<p>Nous souhaitons trouver le nombre total de managers et la somme de leurs salaires.</p>
<p>Nous allons donc avoir la clause suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> <span class="fu">count</span>(staffNo) <span class="kw">as</span> myCount, <span class="fu">sum</span>(salary) <span class="kw">as</span> mySum
    <span class="kw">from</span> Staff
    <span class="kw">where</span> position = <span class="st">&#39;Manager&#39;</span>;</code></pre>
</section>
<section id="utilisation-de-min-max-et-avg" class="level6">
<h6><a href="#utilisation-de-min-max-et-avg"><span class="header-section-number">6.3.4.4.1.4</span> Utilisation de <code>MIN</code>, <code>MAX</code> et <code>AVG</code></a></h6>
<p>Nous souhaitons trouver le salaire minimum et maximum ainsi que la moyenne des salaires des employés.</p>
<p>Nous allons donc avoir la clause suivante:</p>
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">select</span> <span class="fu">min</span>(salary) <span class="kw">as</span> myMin, <span class="fu">max</span>(salary) <span class="kw">as</span> myMax, <span class="fu">avg</span>(salary) <span class="kw">as</span> myAvg
    <span class="kw">from</span> Staff;</code></pre>
<hr />
<pre class="sourceCode SQL"><code class="sourceCode sql">    <span class="kw">create</span> <span class="kw">table</span> PROPRIETE_A_LOUER
    (NUM PROPRIETE <span class="dt">varchar</span>(<span class="dv">5</span>) <span class="kw">not</span> <span class="kw">null</span>,
        PIECES <span class="dt">number</span>(<span class="dv">2</span>) <span class="kw">not</span> <span class="kw">null</span> <span class="kw">default</span> <span class="dv">4</span>,
        LOCATION <span class="dt">number</span>(<span class="dv">6</span>,<span class="dv">2</span>) <span class="kw">not</span> <span class="kw">null</span> <span class="kw">default</span> <span class="dv">600</span>, 
        NUM_PROPRIETAIRE <span class="dt">varchar</span>(<span class="dv">5</span>) <span class="kw">not</span> <span class="kw">null</span>,
        NUM_PERSONNEL <span class="dt">varchar</span>(<span class="dv">5</span>)
        NUM_FILIALE <span class="dt">char</span>(<span class="dv">4</span>) <span class="kw">not</span> <span class="kw">null</span>,
        <span class="kw">constraint</span> PK_PROPRIETE_A_LOUER <span class="kw">primary</span> <span class="kw">key</span>
        (NUM_PROPRIETE),
        <span class="kw">constraint</span> FK_PROPRIETE_NUM_PERSONNEL <span class="kw">foreign</span> <span class="kw">key</span>
        (NUM PERSONNEL) <span class="kw">references</span> PERSONNEL <span class="kw">on</span> <span class="kw">delete</span> <span class="kw">set</span> <span class="kw">null</span>,
        <span class="kw">constraint</span> CK_PIECES_RANGE <span class="kw">check</span> (PIECES <span class="kw">between</span> <span class="dv">1</span> <span class="kw">and</span> <span class="dv">15</span>),
        <span class="kw">constraint</span> CK_LOCATION_RANGE <span class="kw">check</span>(LOCATION <span class="kw">between</span> <span class="dv">0</span>  <span class="kw">and</span> 
        <span class="fl">9999.99</span>);</code></pre>
</section>
</section>
</section>
</section>
</section>
</section>
<section id="annexe" class="level1">
<h1><a href="#annexe"><span class="header-section-number">7</span> Annexe</a></h1>
<dl>
<dt><strong>Abstraction des données</strong></dt>
<dd><p>Nom donné à l’approche qui cache la définition interne des données aux utilisateurs de la base de données et expose seulement la définition externe.</p>
</dd>
<dt><strong>Administrateur de la base de données (DBA)</strong></dt>
<dd><p>Est responsable de la réalisation physique de la base de données, incluant le design physique de la base de données et l’implantation, la sécurité, le contrôle d’intégrité, la maintenance du système opérationnel et d’assurer une performance satisfaisante des applications des utilisateurs.</p>
</dd>
<dt><strong>Administrateur des données (DA)</strong></dt>
<dd><p>Est responsable de gérer les ressources de données, incluant la planification de la base de données, le développement et la maintenance des standards, politiques et procédures. Il doit aussi s’occuper du design conceptuel/logique de la base de données.</p>
</dd>
<dt><strong>Agrégation</strong></dt>
<dd><p>Applique la liste des fonctions agrégates, <span class="math">\(AL\)</span>, à la relation <span class="math">\(R\)</span> pour définir une relation à partir de la liste agrégate. <span class="math">\(AL\)</span> contient une paire (<span class="math">\(\langle \text{ fonction_agrégate } \rangle , \langle \text{ attribut } \rangle\)</span> ou plus.</p>
</dd>
<dt><strong>Algèbre relationnelle</strong></dt>
<dd><p>Langage théorique avec des opérations qui marchent sur une ou plusieurs relations pour définir une autre relation sans changer la relation originale.</p>
</dd>
<dt><strong>Anomalies d’insertion</strong></dt>
<dd><p>Anomalies de mise à jour qui peuvent survenir lors de l’insertion d’un nouveau tuple.</p>
</dd>
<dt><strong>Anomalies de mise à jour</strong></dt>
<dd><p>Problèmes qui peuvent survenir lorsqu’on met à jour une base de données qui comporte de la redondance.</p>
</dd>
<dt><strong>Anomalies de modification</strong></dt>
<dd><p>Anomalies de mise à jour qui peuvent survenir lors de la modification d’un attribut.</p>
</dd>
<dt><strong>Anomalies de suppression</strong></dt>
<dd><p>Anomalies de mise à jour qui peuvent survenir lors de la suppression d’un tuple.</p>
</dd>
<dt><strong>Application de base de données</strong></dt>
<dd><p>Une application qui interagit avec la base de données à un certain point dans son exécution.</p>
</dd>
<dt><strong>Attribut (colonne ou champ)</strong></dt>
<dd><strong>Définition 1</strong>: Propriété qui décrit un aspect de l’objet que nous souhaitons enregistrer.
</dd>
<dd><strong>Définition 2</strong>: Colonne nommée d’une relation.
</dd>
<dd><p><strong>Définition 3</strong>: Décrit des propriétés des données ou des relations entre les données qui sont importantes pour l’entreprise.</p>
</dd>
<dt><strong>Base de données (BD)</strong></dt>
<dd><p>C’est une collection de données liées logiquement et sa description, conçu dans le but de répondre aux besoins d’information d’une organisation.</p>
</dd>
<dt><strong>Base de données relationnel</strong></dt>
<dd><p>Une collection de relations normalisées avec des noms distincts de relations.</p>
</dd>
<dt><strong>Cardinalité</strong></dt>
<dd><p>Le nombre de tuples que la relation contient.</p>
</dd>
<dt><strong>Catalogue système (dictionnaire de données ou metadata)</strong></dt>
<dd><p>Le nom donné à la description des données dans une base de données.</p>
</dd>
<dt><strong>Clé alternative (AK)</strong></dt>
<dd><p>Clé candidate qui n’a pas été choisie comme la clé primaire.</p>
</dd>
<dt><strong>Clé candidate (CK)</strong></dt>
<dd><p>Une superclé tel qu’aucun sous-ensemble propre est une superclé dans la relation.</p>
</dd>
<dt><strong>Clé composée</strong></dt>
<dd><p>Une clé candidate qui possède plus qu’un attribut.</p>
</dd>
<dt><strong>Clé primaire (PK)</strong></dt>
<dd><p>Clé candidate choisie pour identifier chaque tuple de manière unique dans la relation.</p>
</dd>
<dt><strong>Clé étrangère</strong></dt>
<dd><p>Un attribut, ou un ensemble d’attributs, à l’intérieur d’une relation qui correspond à la clé candidate d’une relation (possiblement la même).</p>
</dd>
<dt><strong>Compatible à l’union</strong></dt>
<dd><p>Quand les schémas de deux relations concordent, c’est-à-dire qu’ils ont le même nombre d’attributs avec chaque pair d’attributs correspondant ayant le même domaine.</p>
</dd>
<dt><strong>Concepteurs de bases de données logiques</strong></dt>
<dd><p>Responsables d’identifier les données (ou plutôt les entités et les attributs), les relations entre les données et les contraintes sur les données qui vont être enregistrées dans la base de données. Il doit avoir une bonne compréhension des données de l’organisation et des contraintes qui s’appliquent sur celles-ci.</p>
</dd>
<dt><strong>Concepteurs de bases de données physiques</strong></dt>
<dd><p>Décident comment la conception logique de la base de données va être physiquement implantée.</p>
</dd>
<dt><strong>Contraintes d’intégrité</strong></dt>
<dd><p>Restrictions sur l’ensemble des valeurs permises pour les attributs des relations.</p>
</dd>
<dt><strong>Contraintes générales</strong></dt>
<dd><p>Règles additionnelles spécifiées par les utilisateurs ou les administrateurs de bases de données de la base de données qui définissent ou contraignent des aspects de l’entreprise.</p>
</dd>
<dt><strong>Contraintes</strong></dt>
<dd><p>Règles de cohérence que la base de données ne peut enfreindre.</p>
</dd>
<dt><strong>Degré</strong></dt>
<dd><p>Le nombre d’attributs que la relation contient.</p>
</dd>
<dt><strong>Deuxième forme normale (2NF)</strong></dt>
<dd><strong>Définition</strong>: Une relation qui est dans la première forme normale et dont chaque attribut qui n’est pas une clé primaire est dépendant de la clé primaire.
</dd>
<dd><p><strong>Définition générale</strong>: Une relation qui est dans la première forme normale et dans laquelle tous les attributs qui ne font pas parties d’une clé candidate est <em>complètement dépendant</em> de n’importe quelle clé candidate.</p>
</dd>
<dt><strong>Différence</strong></dt>
<dd><p>Opération binaire de l’algèbre relationnelle qui définit une relation qui consiste des tuples qui sont dans la relation <span class="math">\(R\)</span>, mais pas dans la relation <span class="math">\(S\)</span>. <span class="math">\(R\)</span> et <span class="math">\(S\)</span> doivent être compatibles à l’union.</p>
</dd>
<dt><strong>Division</strong></dt>
<dd><p>Opération de l’algèbre relationnelle qui définit une relation à partir des attributs <span class="math">\(C\)</span>, où <span class="math">\(C\)</span> est l’ensemble des attributs de <span class="math">\(R\)</span> qui ne sont pas des attributs de <span class="math">\(S\)</span>, qui consiste à l’ensemble des tuples de <span class="math">\(R\)</span> qui concordent avec <em>tous</em> les tuples de <span class="math">\(S\)</span>.</p>
</dd>
<dt><strong>Domaine</strong></dt>
<dd><p>L’ensemble des valeurs allouées pour un ou plusieurs attributs.</p>
</dd>
<dt><strong>Décomposition d’opérations complexes</strong></dt>
<dd><p>Opération de l’algèbre relationnelle qui donne un nouveau nom à <span class="math">\(S\)</span> pour l’expression <span class="math">\(E\)</span>, et nomme optionnellement les attributs en <span class="math">\(a_1, a_2, \dots, a_n\)</span>. C’est une opération qui permet de donner un nom au résultat d’une opération relationnelle.</p>
</dd>
<dt><strong>Dépendance fonctionnelle (DF)</strong></dt>
<dd><p>Décrit le lien entre les attributs d’une relation.</p>
</dd>
<dt><strong>Dépendance fonctionnelle complète</strong></dt>
<dd><strong>Définition 1</strong>: Une dépendance fonctionnelle dans laquelle le déterminant à le nombre minimal d’attribut pour avoir une dépendance fonctionnelle avec les attributs à droite de la flèche.
</dd>
<dd><strong>Définition 2</strong>: Indique que si <span class="math">\(A\)</span> et <span class="math">\(B\)</span> sont des attributs d’une relation, <span class="math">\(B\)</span> est complètement fonctionnellement dépendant de <span class="math">\(A\)</span> si <span class="math">\(B\)</span> est fonctionnellement dépendant de <span class="math">\(A\)</span>, mais pas aucun sous-ensemble de <span class="math">\(A\)</span>.
</dd>
<dd><p><strong>Définition 3</strong>: Soit <span class="math">\(A\)</span> et <span class="math">\(B\)</span>, deux attributs d’une relation et <span class="math">\(C \subset A\)</span>, alors <span class="math">\((A \mapsto B) \land \neg (C \mapsto B)\)</span>.</p>
</dd>
<dt><strong>Dépendance multi-valuée</strong></dt>
<dd><p>Représente une dépendence entre des attributs (par exemple, <span class="math">\(A\)</span>, <span class="math">\(B\)</span> et <span class="math">\(C\)</span>) dans une relation, tel que pour chaque valeur de <span class="math">\(A\)</span>, il y un ensemble de valeurs <span class="math">\(B\)</span> et un ensemble de valeurs pour <span class="math">\(C\)</span>. Par contre, l’ensemble de valeurs de <span class="math">\(B\)</span> et <span class="math">\(C\)</span> sont indépendants chacun des autres.</p>
</dd>
<dt><strong>Dépendance partielle (DP)</strong></dt>
<dd><strong>Définition 1</strong>: Une dépendance fonctionnelle dans laquelle un des attributs peut être enlevé du déterminant et la dépendance fonctionnelle est encore valide.
</dd>
<dd><p><strong>Définition 2</strong>: Soit <span class="math">\(A\)</span> et <span class="math">\(B\)</span>, deux attributs d’une relation et <span class="math">\(C \subseteq A\)</span>, alors <span class="math">\(C \mapsto B\)</span>.</p>
</dd>
<dt><strong>Dépendance transitive (DT)</strong></dt>
<dd><strong>Définition 1</strong>: Si <span class="math">\(A\)</span>, <span class="math">\(B\)</span> et <span class="math">\(C\)</span> sont des attributs d’une relation tel que si <span class="math">\(A \mapsto B\)</span> et <span class="math">\(B \mapsto C\)</span>, alors <span class="math">\(C\)</span> est dépendant transitif de <span class="math">\(A\)</span> via <span class="math">\(B\)</span> (si <span class="math">\(A\)</span> n’est pas fonctionnellement dépendant de <span class="math">\(B\)</span> ou <span class="math">\(C\)</span>).
</dd>
<dd><p><strong>Définition 2</strong>: Soit <span class="math">\(A\)</span>, <span class="math">\(B\)</span> et <span class="math">\(C\)</span>, des attributs d’une relation tel que <span class="math">\((A \mapsto B) \land (B \mapsto C) \Rightarrow (A \mapsto C)\)</span>, si <span class="math">\(\neg (B \mapsto A) \lor \neg (C \mapsto A)\)</span></p>
</dd>
<dt><strong>Déterminant</strong></dt>
<dd><p>L’attribut, ou le groupe d’attributs, du côté gauche de la flèche d’une dépendance fonctionnelle.</p>
</dd>
<dt><strong>Entité</strong></dt>
<dd><p>Objet distinct (une personne, un endroit, une chose, un concept ou un événement) dans l’organisation qui doit être représenté dans la base de données.</p>
</dd>
<dt><strong>Equijointure</strong></dt>
<dd><p>Cas particulier de <span class="math">\(\theta\)</span>-join. C’est le cas où le prédicat <span class="math">\(F\)</span> contient seulement l’égalité (<span class="math">\(=\)</span>).</p>
</dd>
<dt><strong>Fermeture</strong></dt>
<dd><p>L’ensemble de toutes les dépendances fonctionnelles sous-entendues par un ensemble de dépendences fonctionnelles <span class="math">\(X\)</span>. Notée <span class="math">\(X^+\)</span>.</p>
</dd>
<dt><strong>Forme non normalisée (UNF)</strong></dt>
<dd><p>Une table qui contient une ou plusieurs répétitions de groupe.</p>
</dd>
<dt><strong>Forme normale de Boyce-Codd</strong></dt>
<dd><p>Une relation dont <em>tous</em> les <em>déterminants</em> sont des <em>clés candidates</em>.</p>
</dd>
<dt><strong>Indépendance des données</strong></dt>
<dd><p>La séparation de la description des données des applications rendant ainsi les applications immunisées aux changement de la description des données.</p>
</dd>
<dt><strong>Intersection</strong></dt>
<dd><p>Opération binaire de l’algèbre relationnelle qui définit une relation consistant de l’ensemble de tous les tuples qui sont à la fois dans <span class="math">\(R\)</span> et <span class="math">\(S\)</span>. <span class="math">\(R\)</span> et <span class="math">\(S\)</span> doivent être compatibles à l’union.</p>
</dd>
<dt><strong>Intégrité d’entité</strong></dt>
<dd><p>Règle d’intégrité qui stipule que, dans une relation de base, aucun attribut de la clé primaire ne peut être nul.</p>
</dd>
<dt><strong>Intégrité référentielle</strong></dt>
<dd><p>Règle d’intégrité qui stipule que, si une clé étrangère existe dans une relation, soit la valeur de la clé étrangère correspond à la valeur d’une clé candidate d’un tuple dans sa relation maison ou la valeur de la clé étrangère doit être complètement nulle.</p>
</dd>
<dt><strong>Jointure externe</strong></dt>
<dd><p>Jointure dans laquelle les tuples de <span class="math">\(R\)</span> qui n’ont pas de valeurs correspondantes avec les attributs en commun avec <span class="math">\(S\)</span> ne sont pas inclus dans la relation résultante. Les valeurs manquantes dans la deuxième relation sont mises à <em>null</em>.</p>
</dd>
<dt><strong>Jointure naturelle</strong></dt>
<dd><p>Equijointure des deux relations <span class="math">\(R\)</span> et <span class="math">\(S\)</span> sur tous leurs attributs communs <span class="math">\(x\)</span>. Une occurence de chacun des attributs communs est enlevée des résultats.</p>
</dd>
<dt><strong>Jointure theta (<span class="math">\(\theta\)</span>-join)</strong></dt>
<dd><p>Opération de l’algèbre relationnelle qui définit une relation qui contient les tuples satisfants le prédicat <span class="math">\(F\)</span> à partir du résultat du produit cartésien de <span class="math">\(R\)</span> et <span class="math">\(S\)</span>. Le prédicat <span class="math">\(F\)</span> est de la forme <span class="math">\(R.a_i~\theta~S.b_i\)</span> où <span class="math">\(\theta\)</span> peut être un des opérateur de comparaison (<span class="math">\(&lt; \)</span>, <span class="math">\(\leq\)</span>, <span class="math">\(&gt;\)</span>, <span class="math">\(\geq\)</span>, <span class="math">\(=\)</span>, <span class="math">\(\neq\)</span>).</p>
</dd>
<dt><strong>Langage de définition des données (DDL)</strong></dt>
<dd><p>Permet aux utilisateurs de spécifier les types, les structures et les contraintes à appliquer sur les données qui seront entreposées dans la base de données.</p>
</dd>
<dt><strong>Langage de manipulation des données (DML)</strong></dt>
<dd><p>Permet aux utilisateurs d’insérer, de mettre à jour, d’effacer et d’aller chercher des données dans la base de données.</p>
</dd>
<dt><strong>Langage de requête</strong></dt>
<dd><p>Permet de faire les opérations des langages de manipulation des données. Un exemple de langage de requête est le <em>SQL</em>.</p>
</dd>
<dt><strong>Normalisation</strong></dt>
<dd><strong>Définition 1</strong>: Une technique pour produire un ensemble de relations avec des propriétés désirables selon les besoins de données de l’entreprise.
</dd>
<dd><p><strong>Définition 2</strong>: Une technique formelle pour analyser les relations basée sur leur clé primaire (ou clés candidates) et les dépendances fonctionnelles.</p>
</dd>
<dt><strong>Null</strong></dt>
<dd><p>Représente une valeur pour un attribut qui est présentement inconnu ou pas applicable pour ce tuple.</p>
</dd>
<dt><strong>Opérations de jointure</strong></dt>
<dd><strong>Définition textuelle</strong>: Opération de l’algèbre relationnelle qui est équivalente à appliquer l’opération de sélection avec le prédicat de jointure au résultat du produit cartésien des deux relations d’entrée.
</dd>
<dd><p><strong>Définition mathématique</strong>: Si <span class="math">\(F\)</span> est le prédicat de jointure et <span class="math">\(R\)</span> ainsi que <span class="math">\(S\)</span> sont deux relations, alors l’opération de jointure entre les deux relations peut être décrite comme <span class="math">\(\sigma_{F}(R \times S)\)</span>.</p>
</dd>
<dt><strong>Première forme normale (1NF)</strong></dt>
<dd><p>Une relation dans laquelle l’intersection de chaque ligne et colonne contient seulement une valeur.</p>
</dd>
<dt><strong>Produit cartésien</strong></dt>
<dd><p>Opération binaire de l’algèbre relationnelle qui définit une relation qui est la concaténation de tous les tuples de la relation <span class="math">\(R\)</span> avec tous les tuples de la relation <span class="math">\(S\)</span>.</p>
</dd>
<dt><strong>Programme d’application</strong></dt>
<dd><p>Un programme informatique qui interagit avec la base de données en envoyant des requêtes (la plupart du temps des instructions <em>SQL</em>) au système de gestion des bases de données.</p>
</dd>
<dt><strong>Projection</strong></dt>
<dd><p>Opération unaire de l’algèbre relationnelle qui s’applique sur une seule relation <span class="math">\(R\)</span> et définie une relation qui contient un sous-ensemble vertical de <span class="math">\(R\)</span>. Elle extrait les valeurs des attributs spécifiés et élimine les copies.</p>
</dd>
<dt><strong>Quatrième forme normale</strong></dt>
<dd><p>Une relation dont toutes les dépendences multi-valuées non-triviales <span class="math">\(A \twoheadrightarrow B\)</span> ont comme propriété que <span class="math">\(A\)</span> est une clé candidate de la relation.</p>
</dd>
<dt><strong>Regroupement</strong></dt>
<dd><p>Groupe les tuples de la relation <span class="math">\(R\)</span> par les attributs de groupement, <span class="math">\(GA\)</span>, et applique ensuite la liste de fonctions agrégates <span class="math">\(AL\)</span> pour définir une nouvelle relation. <span class="math">\(AL\)</span> contient une paire (<span class="math">\(\langle \text{ fonction_agrégate } \rangle , \langle \text{ attribut } \rangle\)</span> ou plus. La relation résultante contient les attributs de groupement <span class="math">\(GA\)</span> avec le résultat de chacune des fonctions agrégates.</p>
</dd>
<dt><strong>Relation (table ou fichier)</strong></dt>
<dd><strong>Définition 1</strong>: Une association entre plusieurs entités.
</dd>
<dd><p><strong>Définition 2</strong>: Table avec des lignes et des colonnes.</p>
</dd>
<dt><strong>Relation de base</strong></dt>
<dd><strong>Définition 1</strong>: Relation qui correspond à une entité dans le schéma conceptuel.
</dd>
<dd><p><strong>Définition 2</strong>: Relation nommée qui correspond à une entité dans le schéma conceptuel, dont les tuples sont entreposés physiquement dans la base de données.</p>
</dd>
<dt><strong>Relation virtuelle (relation dérivée)</strong></dt>
<dd><p>Relation qui n’existe pas par elle-même, mais qui peut être dérivée dynamiquement d’une ou plusieurs relations de base.</p>
</dd>
<dt><strong>Règles d’affaires</strong></dt>
<dd><p>Les contraintes d’une organisation sur les données.</p>
</dd>
<dt><strong>Règles d’intégrité</strong></dt>
<dd><p>Contraintes ou restrictions qui s’appliquent sur toutes les instances de la base de données.</p>
</dd>
<dt><strong>Schéma conceptuel (modèle conceptuel)</strong></dt>
<dd><p>L’ensemble de tous les schémas de la base de données.</p>
</dd>
<dt><strong>Schéma de base de données relationnel</strong></dt>
<dd><p>Un ensemble de schémas de relation avec chacun un nom distinct.</p>
</dd>
<dt><strong>Schéma de relation</strong></dt>
<dd><p>Une relation nommée définie par un ensemble d’attributs et de paires de noms de domaines.</p>
</dd>
<dt><strong>Schéma</strong></dt>
<dd><p>Structure de la base de données.</p>
</dd>
<dt><strong>Semi-jointure</strong></dt>
<dd><p>Définit une relation qui contient les tuples de <span class="math">\(R\)</span> qui participent dans la jointure de <span class="math">\(R\)</span> avec <span class="math">\(S\)</span> satisfaisant le prédicat <span class="math">\(F\)</span>.</p>
</dd>
<dt><strong>Superclé</strong></dt>
<dd><p>Attribut, ou un ensemble d’attributs, qui identifient de manière unique un tuple dans une relation.</p>
</dd>
<dt><strong>Système de base de données</strong></dt>
<dd><p>L’ensemble des applications qui interagissent avec la base de données et le système de gestion de base de données.</p>
</dd>
<dt><strong>Système de gestion de base de données (DBMS ou SGBD (en français))</strong></dt>
<dd><p>Un logiciel qui permet aux utilisateurs de définir, maintenir et contrôler l’accès à la base de données.</p>
</dd>
<dt><strong>Sélection</strong></dt>
<dd><p>Opération unaire de l’algèbre relationnelle qui s’applique sur une seule relation <span class="math">\(R\)</span> et définit une relation qui contient seulement les tuples de <span class="math">\(R\)</span> qui satisfont la condition spécifée (le <em>prédicat</em>).</p>
</dd>
<dt><strong>Troisième forme normale (3NF)</strong></dt>
<dd><strong>Définition</strong>: Une relation qui est dans la première et deuxième forme normale et dans laquelle aucun attribut qui ne fait pas partie de la clé primaire est transitivement dépendant de la clé primaire.
</dd>
<dd><p><strong>Définition générale</strong>: Une relation qui est dans la première et deuxième forme normale et dans laquelle aucun attribut qui ne fait pas partie d’une clé candidate est transitivement dépendant d’une clé candidate.</p>
</dd>
<dt><strong>Tuple (ligne ou archive)</strong></dt>
<dd><p>Nom donné à une ligne dans une relation (ou table).</p>
</dd>
<dt><strong>Union</strong></dt>
<dd><p>L’union de deux relations <span class="math">\(R\)</span> et <span class="math">\(S\)</span> définit une relation qui contient tous les tuples de <span class="math">\(R\)</span> ou de <span class="math">\(S\)</span> ou bien des deux relations. Les tuples copies sont éliminés. <span class="math">\(R\)</span> et <span class="math">\(S\)</span> doivent être compatibles à l’union.</p>
</dd>
<dt><strong>Utilisateurs naïfs</strong></dt>
<dd><p>Ignorent tout du système de gestion de bases de données. Ils accèdent à la base de données par des programmes spécifiques. Ils utilisent les opérations de bases de données en appuyant sur des boutons ou en entrant des commandes simples.</p>
</dd>
<dt><strong>Utilisateurs sophistiqués</strong></dt>
<dd><p>Familiés avec la structure de la base de données et des installations fournies par le système de gestion de bases de données. Ils sont capable d’utiliser un langage de requêtes comme le <em>SQL</em> pour exécuter les opérations requises. Ils sont parfois même capables d’écrire des applications pour leur propre usage.</p>
</dd>
<dt><strong>Vue</strong></dt>
<dd><p>Résultat dynamique d’une ou plusieurs opérations opérant sur les relations de base afin de produire une autre relation. Une vue est une <em>relation virtuelle</em> qui n’existe pas nécessairement dans la base de données mais qui peut être produite sur demande par un utilisateur donné au moment de la requête.</p>
</dd>
</dl>
</section>
<script>
    document.getElementById("TOC").className = "mobile-hidden";

    var button = document.getElementById("toggle-nav");

    button.addEventListener("click", function() {
        var tableOfContents = document.getElementById("TOC");
        var navbar = document.getElementsByClassName("navbar")[0];
        if (tableOfContents.className === "") {
            navbar.id = "";
            tableOfContents.className = "mobile-hidden";
        }
        else {
            navbar.id = "fixed-navbar";
            tableOfContents.className = "";
        }
    }, false);
</script>
</body>
</html>
